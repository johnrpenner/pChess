// pChess 2.0 UCI// Globals & Constants// Written by: John Roland Penner <johnrolandpenner-at-gmail-dot-com>// This file is released under the GNU public license, 2012// Created: March 22, 2010 (Toronto Island)// Updated as of: June 6, 2012//===| CONSTANTS |=============================================_version$ = "2.0"_devLog = _false_buildPPC = _false_buildAsUCIengine    = _false_logCommandsReceived = _false_whitee = 1_blackk = -1_Fischer = 1_Classic = 0_defaultGameType = 0_noSuchSquare = 99// maximal game constraints_maxMoves = 256_maxGameMoves = 250_maxAttacks = 80_maxBookOpenings = 12000_maxBookDepth = 95_maxWords = 99 // max# words in parse Book_maxUCIwords = 512_usePollTime2 = 1     // enable use of a second timer_maxEvalTime = 900000          // 15 minutes in milliseconds// HASH.scoreTypebegin enum 0 _lowerBound_exactScore_upperBoundend enum// evaluation options_gDepth = 5     // default negaMax search depth_minQSearchDepth = -18 // quiescence search depth_mateScore = 65535_iAmMateScore = -65535_iAmInCheckScore = -16383_stalemateScore = 0_infinity = 2147483647// engine options_useMoveSort = _true     //always on -- much faster! _useQuiescence = _true     //search for recaptures (always yes)_iDeep = _true_useHashTable = _true_showHash = _false_rndBook = _true     //if false, it will pick the LONGEST match// piece weights_pawnWt = 100     //pawn weight_bishopWt = 330     //bishop weight_knightWt = 320     //knight weight_rookWt = 500     //rook weight_queenWt = 900     //queen weight_kingWt = 4000     //C.Shannon: greater than sum of other terms// eval.switches_eval01material = _true_eval02mobility = _true_evalCastleBonus = _true_evalPawnTropism = _true_evalKingGravity = _true_evalKingSafety = _true_evalKnightTropism = _true_evalBishopPair = _true// not Working_evalHitsUs = _false_evalNextGenHits = _false_evalNextGenReHits = _false  //this is REALLY SLOW!!// weight of evals_wtMobility = 1     'Shannon's weight for Mobility was 1/10 pawnWt_wtHitsUs = 9     'Penalty: (#HitUs & ourPieceWt)/9_castleBonus = 10     'weight of 10 * _castleBonus_wtTropism = 1     'scale x Tropsim Scores by this amount_wtKingGravity = 10     'scale x King Gravity (of targets 2, 3)_wtPassedPawn = 22     'weight of Passed Pawn_wtDoubledPawn = 11     'Penalty for Doubled Pawn_wtKingShelter = 6                        'Bonus for Each Pawn Sheltering a Castled King_wtBishopPair = 40     'Bonus for Bishop Pair_wtnextGenHits = 10     'Bonus: (#nextGenHits * enemyPieceWt)/10_wtnextGenReHits = 9     'Bonus: (#ReHits * enemyPieceWt)/9_wtGeschutzed = 10     'Bonus: (weightOfGeschutzed Piece)/10// GUI Constants_WinX = 40_WinY = 98// _WinSizeX = 480// _WinSizeY = 650_WinSizeX = 934_WinSizeY = 560_FontFace = 0_FontSize = 13_MonoFace = 4_MonoSize = 12_fileDate = _true#if _buildPPC == _true_CheqFont = 14558                        'Necessary, if Font Not Bundled (OSX 10.4)#endif_CheqSize = 58_boardStyle = 0    '(0=Adobe Cheq Font; 1=ASCII)_stdNotation = _true     'set to _false for algebraicNotation_penWidth = 2     'width for baord grid (should be 2)_brainWidth = 1     'width for visualBrain lines; 3=fat_dispEchoSpace = _True     'whether to show FROM square_overLines = _False                        'show overlay lines_axisLabels = _True_castleOhOh = _False// location of history display_lineHeight = 16     'pixels_histY = 100_histX0 = 555_histX1 = 590_histX2 = 640_histXX = 750_histYY = 470// location of capturedPieces display_CheqCaptureSize = 24_captHeight = 24_captY = 105_captX0 = 750_captX1 = 840_captX2 = 790_captX3 = 880_captXX = 930_captYY = 470// default preferences_gFlip = 0     'white starts at the bottom_audioBrain = 0_visualBrain = 1     'default ON_hyperView = 0'default OFF_Speech = _true     'default ON_gUseBook = 1     'use book if loaded_debug = 1                                'default ON_displayCaptures = _true     'highlight captured//===| GLOBALS |========================================================//sqValues: 0=empty, 1=Pawn, 2=Bishop, 3=kNight, 4=Rook, 5=Queen, 6=Kingbegin globalsbegin enum 0_empty_pawn_bishop_knight_rook_queen_kingend enumbegin record boardRecorddim as long who2move     '+1 white or -1 blackdim as long halfMoves     'total number of halfMovesdim as long square[63]     'piece values: 1=pawn; 2=bishop..dim as boolean wCastleKside, wCastleQside, wHasCastleddim as boolean bCastleKside, bCastleQside, bHasCastleddim as long enPassantSq '_noSuchSquare = 99 if not applicabledim as boolean fischerdim as long rookSq1, rookSq2     //not actually a SQ -- it is a COLUMN (A-H)     //but we internally count from the whiteSq. dim as long fiftyCountdim as UInt64 hashCodeend recordbegin record moveRecorddim as long fromSquaredim as long toSquaredim as long capturePiecedim as long promoPiecedim as long moveScoreend recordbegin record hashRecorddim as UInt64 hashCodedim as moveRecord recommendedMovedim as long scoredim as UInt8 depthdim as UInt8 scoreTypeend recordbegin record stringBuffer// positionStr with 255 moves > 1530 chars = str255 * 6; thus str[5].dim as long indexdim as str255 str[5]end recordbegin record gameRecord// PGN Info saved with gamedim as str255 tourndim as str255 sitedim as str255 datedim as str255 rounddim as str255 whitedim as str255 blackdim as str255 resultdim as str255 variantdim as str255 gameFENend record// PREFERENCESdim as long gDepthdim as long gFlipdim as long audioBraindim as long visualBraindim as long hyperViewdim as long gUseBookdim as long gDebugdim as long gBoardStyledim as boolean gOverLinesdim as boolean gSpeechdim as boolean gUseMoveSortdim as boolean gUseQuiescencedim as long winX, winYdim as long noteTable(63)// FONT EMBED#if _buildPPC == _false#define ATSFontContext       as UInt32#define ATSFontFormat        as UInt32#define ATSOptionFlags       as UInt32#define ATSFontContainerRef  as UInt32#define ATSFontFamilyRef     as UInt32_kATSFontFormatUnspecified = 0_kATSOptionFlagsDefault = 0_kATSFontContextLocal = 2dim as ATSFontFamilyRef gCheqFont#endif// game variablesdim as long gPieceWt(6)dim as str255 gPieceName(6)dim as long gMovesMade, gNodes, gqNodesdim as str255 userStart, userTime, computerTimedim as boolean gPromotiondim as boardRecord gBoarddim as gameRecord gGamedim as long gMoveCountdim as long gDispCountdim as long gWho2Movedim as long gDispFlipdim as boolean gInCheckdim as boolean gDirtyFlag// global variables for evaluation (battleVariables)dim as long gWtTropismdim as long gCastleBonusdim as long gWtKingGravitydim as long gWtPassedPawndim as long gWtKingShelterdim as long gWtDoubledPawn// pawn tropismdim as long gWhitePawnTropism(63), gBlackPawnTropism(63)// knight tropismdim as long gWhiteKnightTropism(63), gBlackKnightTropism(63)// king gravity masks and fieldsdim as long kZone2(15), kZone3(8), kZone220(15), kZone320(8)dim as long sq2Mask(63), maskBoard(119)// movement vectors and masksdim as long wPawnVect(5), wPawnMask(5), bPawnVect(5), bPawnMask(5)dim as long bishopVect(3), bishopMask(3), knightVect(7), knightMask(7)dim as long rookVect(3), rookMask(3), kingVect(7), kingMask(7)// timer and interuptsdim as Boolean sAbortSearchdim as long gMaxEvalTime// book relatedbegin record bookRecorddim as str255 Titledim as str255 moveChainend recorddim as bookRecord gBook(_maxBookOpenings)dim as long numBookMovesdim as str255 gameChaindim as str255 gBookTitle// gameBoards() to store the game board history. dim as boardRecord gameBoards(_maxGameMoves)// gMoveList() holds the opening book linedim as moveRecord gMoveList(_maxGameMoves)// HASH declarationsdim as ^hashRecord gHashTabledim as UInt64 gPieceHashCode(63, 6, 2), gEnPassantHashCode, gSideHashCode//dim as UInt64  gCastleKSideHashCode, gCastleQSideHashCode// HASH statisticsdim as UInt64  gNumPositionsSavedInHashTable, gNumSearchesOfHashTabledim as UInt64  gNumPositionsFoundInHashTable, gNumPositionsNotFoundInHashTabledim as UInt64  gNumPositionsUseableInHashTable, gNumHashTableMovesUsed// Board & Piece Coloursdim as Short bgB_board, bgG_board, bgR_boarddim as Short bgB_bBoard, bgG_bBoard, bgR_bBoarddim as Short bgB_bPiece, bgG_bPiece, bgR_bPiecedim as Short bgB_wPiece, bgG_wPiece, bgR_wPiecedim as Short fgB_board, fgG_board, fgR_boarddim as Short fgB_bPiece, fgG_bPiece, fgR_bPiecedim as Short fgB_wPiece, fgG_wPiece, fgR_wPiecedim as Short bgB_highlight, bgG_highlight, bgR_highlightdim as Short fgB_highlight, fgG_highlight, fgR_highlightend globals//===| FN PROTOTYPES |=========================================// generally, a routine must precede the function which calls it. // by including it here as a FN prototype, they can exist out-of-order// this solves the: cant call non-preceding function problem. def fn move2Algebraic(theMove as ^moveRecord) as str255def fn staticEval ( board as ^boardRecord )def fn copyBoard( source as ^boardRecord, dest as ^boardRecord )def fn generateRawMoves(board as ^boardRecord, moves(_maxMoves) as moveRecord, numMoves as long)def fn generateLegalMoves(board as ^boardRecord, moves(_maxMoves) as moveRecord )def fn sq2X(index as long)def fn sq2Y(index as long)#if _buildAsUCIEngine == _falsedef fn displayBoard(board as ^boardRecord)def fn visualBrainz(theMove as ^moveRecord)def fn showHelpdef fn speak(speech as str255, hold as long)def fn playSound( fName as Str255 )def FN displayOverlay(board as ^boardRecord, moves(_maxMoves) as moveRecord, numMoves as long, overlayInfo as boolean)def FN gameHistorydef FN speakMove(StdMoveIn as str255, inBoard as ^boardRecord)#endifdef fn parseMove(moveStr as str255)def fn makeMove(board as ^boardRecord, theMove as ^moveRecord)def fn numElements(a as str255)def fn getWords( a as str255, words(_maxWords) as str255 )def fn loadBook as OSStatusdef fn matchBook(moveChain as str255)def fn pickBook(moveChain as str255) as str255def fn toFEN as str255def fn checkTest(theBoard as ^boardRecord)def fn CheckForAbortSignaldef fn PollTimedef fn PollTime2def fn SetAbortSearchdef fn ClearAbortSearchdef fn IsSearchAborteddef fn SetupPollTime( interval as Duration, driftFree as Boolean )def fn SetupPollTime2( interval as Duration, driftFree as Boolean )def fn initBoard_classic (board as ^boardRecord)def fn timeAdd(tOne as str255, tTwo as str255) as str255def fn timeDelta(tStart as str255, tEnd as str255) as str255def fn Milliseconds as longdef fn userMove( moveStr as str255 )def fn computerMove(useBookOpenings as boolean) as str255def fn isAttacked( querySquare as long, theBoard as ^boardRecord) as booleandef FN move2Std(theMove as ^moveRecord, theBoard as ^boardRecord) as str255def FN hashBoard( inBoard as ^boardRecord) as str255def fn quitPeadef fn setupPosition( UCIcmd as ^stringBuffer )def fn infoToGUI ( moveIndex as long, dispMove as str255, depth as long, moveScore as long, nodes as long )def fn Milliseconds as long