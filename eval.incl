// pChess 1.8// Evaluation Module 2.8// Written By John Roland Penner <johnrolandpenner-at-gmail-dot-com>// This file is released under the GNU public license, 2011. // Updated as of: October 4, 2011local FN staticEval( board as ^boardRecord )/* Claude Shannon (1949):    f(p) = 200(K-K') + 9(Q-Q') + 5(R-R') + 3(B-B'+N-N') + 1(P-P')          - 0.5(D-D'+S-S'+I-I') + 0.1(M-M') + ...     KQRBNP = number of kings, queens, rooks, bishops, knights and pawns     D,S,I  = doubled, blocked and isolated pawns     M      = Mobility (the number of legal moves) */dim as long querySquare, pieceTypedim as long wP, wB, wN, wR, wQ, wKdim as long bP, bB, bN, bR, bQ, bKdim as long who2hold, wM, bMdim as long materialScore, positionalScore, mobilityScoredim as long hitsUsScore, wHitsUsScore, bHitsUsScoredim as long staticScore, numMoves, numRepliesdim as boardRecord scoreBoarddim as moveRecord moves(_maxMoves)dim as moveRecord replyMoves(_maxMoves)dim as long z, n, n2, fromPiecedim as long rehitScore// NOTE: used for kingGravity, but declared globally, // are: sq2mask(63) and maskBoard(119) -- i believe this// is faster than redeclaring them everytime in the loop. dim as long wKingSq, bKingSq, kingField(63), testSqdim as long wKingSq120, bKingSq120, testSq120dim as long kingGravityScore, wKingGravity, bKingGravity// initialize scoring setupstaticScore = 0positionalScore = 0wKingSq=_noSuchSquarebKingSq=_noSuchSquare//======================================================// FIRST Evaluator: MATERIAL ScorematerialScore = 0long if _eval01material = _truewP=0: wB=0: wN=0: wR=0: wQ=0: wK=0bP=0: bB=0: bN=0: bR=0: bQ=0: bK=0for querySquare = 0 to 63pieceType = board.square[querySquare]select case pieceTypecase 1 : wP++case 2 : wB++case 3 : wN++case 4 : wR++case 5 : wQ++case 6 : wK++ : wKingSq = querySquare     'used in kingGravitycase -1 : bP++case -2 : bB++case -3 : bN++case -4 : bR++case -5 : bQ++case -6 : bK++ : bKingSq = querySquare     'used in kingGravityend selectnext querySquarematerialScore = gPieceWt(6)*(wK-bK) + gPieceWt(5)*(wQ-bQ) + gPieceWt(4)*(wR-bR) + gPieceWt(3)*(wN-bN) + gPieceWt(2)*(wB-bB) + gPieceWt(1)*(wP-bP) end if//==================================================// Evaluators: MOBILITY | KING GRAVITY | KING SAFETY// fn copyBoard(board, scoreBoard)who2hold = scoreBoard.who2movekingGravityScore=0 : wKingGravity=0 : bKingGravity=0// WHITE MOBILITY scorescoreBoard.who2move = 1numMoves = 0 : blockZero( moves(0), sizeof( moveRecord ) )wM = fn generateRawMoves(scoreBoard, moves(0), numMoves )long if (_evalKingGravity = _true)// begin white kingGRAVITY: initialize the kingField()//blockZero( kingField(0), sizeof( kingField(0) )for z = 0 to 63kingField(z) = 0next zbKingSq120 = sq2Mask(bKingSq)// cycle thru kZone2, and test if each vector is on the boardfor z = 0 to 15testSq = bKingSq + kZone2(z)testSq120 = bKingSq120 + kZone220(z)if (testSq120 < 0) then testSq120 = 0if (testSq120 > 119) then testSq120 = 119if ( maskBoard(testSq120) = 1 ) then kingField(testSq) = 2next z// cycle thru kZone3, and test if each vector is on the boardfor z = 0 to 8testSq120 = bKingSq120 + kZone320(z)testSq = bKingSq + kZone3(z)if (maskBoard(testSq120) = 1 ) then kingField(testSq) = 3next z// finished creating the white king target; // now its time to see how many moves hit it. for z = 0 to wM-1wKingGravity = wKingGravity + kingField( moves.toSquare(z) )next zend if// KING SAFETYlong if (_evalKingSafety = _true)// white king safety evallong if (who2hold == _whitee)long if (wKingSq == 2) or (wKingSq == 1)if (board.square[9] > 0) then wKingGravity += gWtKingShelterif (board.square[10] > 0) then wKingGravity += gWtKingShelterend iflong if (wKingSq == 6)if (board.square[13] > 0) then wKingGravity += gWtKingShelterif (board.square[14] > 0) then wKingGravity += gWtKingShelterend ifend ifend if // BLACK MOBILITY scorescoreBoard.who2move = -1numMoves = 0 : blockZero( moves(0), sizeof( moveRecord ) )bM = fn generateRawMoves(scoreBoard, moves(0), numMoves )long if (_evalKingGravity = _true)// begin BLACK kingGRAVITY: initialize the kingField()for z = 0 to 63kingField(z) = 0next zwKingSq120 = sq2Mask(wKingSq)// cycle thru kZone2, and test if each vector is on the boardfor z = 0 to 15testSq = wKingSq + kZone2(z)testSq120 = wKingSq120 + kZone220(z)if (testSq120 < 0) then testSq120 = 0if (testSq120 > 119) then testSq120 = 119if ( maskBoard(testSq120) = 1 ) then kingField(testSq) = 2next z// cycle thru kZone3, and test if each vector is on the boardfor z = 0 to 8testSq120 = wKingSq120 + kZone320(z)testSq = wKingSq + kZone3(z)if (maskBoard(testSq120) = 1 ) then kingField(testSq) = 3next z// finished creating the black king target; // now its time to see how many moves hit it. for z = 0 to bM-1bKingGravity = bKingGravity + kingField( moves.toSquare(z) )next zend if// KING SAFETY// FIND: this eval feature needs update for fischer!!long if (_evalKingSafety = _true)// black king safety evallong if (who2hold == _blackk)long if (bKingSq == 57) or (bKingSq == 58)if (board.square[49] < 0) then bKingGravity += gWtKingShelterif (board.square[50] < 0) then bKingGravity += gWtKingShelterend iflong if (bKingSq == 62)if (board.square[53] < 0) then bKingGravity += gWtKingShelterif (board.square[54] < 0) then bKingGravity += gWtKingShelterend ifend ifend if// reset who2move and score mobilityscoreBoard.who2move = who2holdmobilityScore = (wM-bM)kingGravityScore = (wKingGravity - bKingGravity) * gWtKingGravity//=======================================================================// CASTLE BONUS Evaluator// we want to promote castling - but not into peril. // hence, it should promote castling, but only into a sheltered position. // rnbq1rk1/pp3ppp/2p2b2/3p4/Q2P4/2N2N2/PP2PPPP/R3KB1R w KQ -// the above FEN should NOT castle to queenside (a disaster!); rather e3!// FIND: this eval feature needs update for fischer!!dim as long castleScore, wCastleScore, bCastleScorecastleScore = 0 : wCastleScore = 0 : bCastleScore = 0long if _evalCastleBonus = _true//if board.wHasCastled = _true then wCastleScore = 10 else wCastleScore = -5long if (board.wHasCastled)long if ( (wKingSq<>2) and (wKingSq<>6) ) or ( (wKingSq=2) and (board.square[10] = 1) ) or ( (wKingSq=6) and (board.square[14] = 1) )wCastleScore = gCastleBonusxelsewCastleScore = -5end ifend if//if board.bHasCastled = _true then bCastleScore = 10 else bCastleScore = -5long if (board.bHasCastled)long if ( (bKingSq<>58) and (bKingSq<>62) ) or ( (bKingSq=58) and (board.square[50] = -1) ) or ( (bKingSq=62) and (board.square[54] = -1) )bCastleScore = gCastleBonusxelsebCastleScore = -5end ifend ifend if//castleScore = (wCastleScore - bCastleScore) * gCastleBonuscastleScore = (wCastleScore - bCastleScore)//========================================================// PAWN Evaluator (PAWN TROPISM / PASSED / DOUBLED)// A Passed Pawn increases in strength as the // number of pieces on the board diminishes.  (Capablanca)// pawn tester FEN: 8/pppppppp/8/8/8/8/PPPPPPPP/8 w KQkqdim as long rank, offset, passed, doubleddim as long tropismScore, wTropism, bTropismtropismScore = 0 : wTropism = 0 : bTropism = 0long if _evalPawnTropism = _truefor querySquare = 0 to 63pieceType = board.square[querySquare]// WHITE PAWN Testslong if pieceType = 1rank=0 : passed=0 : doubled=0 : offset=0rank = fn sq2Y(querySquare)// add white pawn tropismwTropism = wTropism + gWhitePawnTropism(querySquare)long if querySquare < 56// check for doubled white pawnsif board.square[querySquare + 8 ] = 1 then doubled = 1// check for white passed pawnpassed = 1for z = 1 to (7-rank)offset = 8 * zlong if (querySquare - offset) <= 63if board.square[querySquare + offset ] <> 0 then passed = 0 : exit nextend ifnext zend ifif doubled = 1 then wTropism = wTropism -gWtDoubledPawn : doubled = 0if passed = 1 then wTropism = wTropism + gWtPassedPawn : passed = 0end if// BLACK PAWN Testslong if pieceType = -1rank=0 : passed=0 : doubled=0 : offset=0rank = fn sq2Y(querySquare)//add black pawn tropismbTropism = bTropism + gBlackPawnTropism(querySquare)long if querySquare > 7// check for doubled black pawnsif board.square[querySquare - 8 ] = -1 then doubled = 1// check for black passed pawnpassed = 1for z = 1 to rankoffset = 8 * zlong if (querySquare - offset) => 0if board.square[querySquare - offset ] <> 0 then passed = 0 : exit nextend ifnext zend ifif doubled = 1 then bTropism = bTropism - gWtDoubledPawn : doubled = 0if passed = 1 then bTropism = bTropism + gWtPassedPawn : passed = 0end ifnext querySquaretropismScore = (wTropism-bTropism) * gWtTropismend if//==========================================// KNIGHT TROPISM Evaluatordim as long knightTropismScore, wKnightTropism, bKnightTropismknightTropismScore = 0 : wKnightTropism = 0 : bKnightTropism = 0long if ( _evalKnightTropism )for querySquare = 0 to 63pieceType = board.square[querySquare]if pieceType = 3 then wKnightTropism += gWhiteKnightTropism(querySquare)if pieceType =-3 then bKnightTropism += gBlackKnightTropism(querySquare)next querySquareknightTropismScore = (wKnightTropism - bKnightTropism)end if//==========================================// BISHOP PAIR Evaluator// An unpaired bishop and knight are of equal value.. // The bishop pair has an average value of half a pawn. // (GM Larry Kaufman, The Evaluation of Material Imbalances, Chess Life, 1999)dim as long wBishopPairScore, bBishopPairScore, bishopPairScorewBishopPairScore = 0 : bBishopPairScore = 0 : bishopPairScore = 0long if ( _evalBishopPair )if (wB > 2) then wBishopPairScore += _wtBishopPairif (bB > 2) then bBishopPairScore += _wtBishopPairend ifbishopPairScore = (wBishopPairScore - bBishopPairScore)//==========================================// HITS-US Evaluator// Penalty for everything that Hits Us. // _wtHitsUs = 4     'Penalty: (#HitUs & ourPieceWt)/4hitsUsScore = 0long if _evalHitsUs = _true//score white HITSwHitsUsScore = 0long if (board.who2move = 1)for n = 0 to 63long if (board.square[n] > 0) and ( fn isAttacked(n, board) )wHitsUsScore += gPieceWt(abs(board.square[n]))  'THIS WORKS!!end ifnext nend if//score black HITSbHitsUsScore = 0long if (board.who2move = -1)for n = 0 to 63long if (board.square[n] < 0) and ( fn isAttacked(n, board) )bHitsUsScore += gPieceWt(abs(board.square[n]))  'THIS WORKS!!end ifnext nend ifhitsUsScore = (wHitsUsScore - bHitsUsScore) / _wtHitsUsend if//==========================================// nextGenHits Evaluator// Bonus for everything our Next Moves Can Hit// _wtnextGenHits = 10     'Bonus: (#directHits * enemyPieceWt)/10//==========================================// nextGenReHits Evaluator// Penalty if Enemy Piece Can Hit Our MoveTodim as long wRehitScore, bRehitScorerehitScore = 0long if _evalNextGenReHits = _true//score white REHITSwRehitScore = 0//scoreBoard = boardfn copyBoard(board, scoreBoard)who2hold = scoreBoard.who2movescoreBoard.who2move = 1numMoves = 0 : blockZero( moves(0), sizeof( moveRecord ) )numMoves = fn generateLegalMoves(scoreBoard, moves(0) )for n = 0 to numMoves-1scoreBoard = boardFN makeMove( scoreBoard, moves(n) )numReplies = 0 : blockZero( replyMoves(0), sizeof( moveRecord ) )numReplies = fn generateLegalMoves(scoreBoard, replyMoves(0) )for n2 = 0 to numReplies-1long if replyMoves.toSquare(n2) = moves.toSquare(n)fromPiece = scoreBoard.square[moves.toSquare(n)]wRehitScore = wRehitScore - (gPieceWt(fromPiece) * fromPiece)end ifnext n2next n//score black REHITSbRehitScore = 0//scoreBoard = boardfn copyBoard(board, scoreBoard)who2hold = scoreBoard.who2movescoreBoard.who2move = -1numMoves = 0 : blockZero( moves(0), sizeof( moveRecord ) )numMoves = fn generateLegalMoves(scoreBoard, moves(0) )for n = 0 to numMoves-1scoreBoard = boardFN makeMove( scoreBoard, moves(n) )numReplies = 0 : blockZero( replyMoves(0), sizeof( moveRecord ) )numReplies = fn generateLegalMoves(scoreBoard, replyMoves(0) )for n2 = 0 to numReplies-1long if replyMoves.toSquare(n2) = moves.toSquare(n)fromPiece = scoreBoard.square[moves.fromSquare(n)]wRehitScore = wRehitScore - (gPieceWt(fromPiece) * fromPiece)end ifnext n2next nreHitScore = (wRehitScore - bRehitScore) / _wtnextGenReHitsend if//==========================================// Sum all the Evaluative Scores and Invert for Black -- // because we must return the score relative to the side2move (!!)positionalScore = mobilityScore + kingGravityScorepositionalScore = positionalScore - hitsUsScore + castleScorepositionalScore = positionalScore - rehitScore + tropismScorepositionalScore = positionalScore + knightTropismScorepositionalScore = positionalScore + bishopPairScorepositionalScore = positionalScore / 2     'normalize to ~160 centiPawnsstaticScore = (materialScore + positionalScore) * board.who2Moveif (_devLog) then print "   " materialScore*board.who2Move " + " positionalscore*board.who2Move " = " (materialScore + positionalscore)*board.who2Moveend FN = staticScore