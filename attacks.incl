// pChess 2.0 - Attack Generators (Move Generator with Just the Beef)// By John Roland Penner <johnrolandpenner-at-gmail-dot-com>// Created: November 12, 2010 (Toronto Island)// Updated: July 30, 2012local fn wPawnAttacks( querySquare as long, theBoard as ^boardRecord, attackedSquares(_maxMoves) as long, numMoves as long, pieceColour as long )dim as long moveIndex, pieceMoves, fromYdim as long testMask, newMask, testSquarepieceMoves = 0//pawn NW (captures)testMask = sq2Mask (querySquare)newMask = testMask + wPawnMask(0)testSquare = querySquare + wPawnVect(0)long if (maskBoard(newMask) = 1 )long if theBoard.square[testSquare] < 0moveIndex = numMoves + pieceMovesattackedSquares(moveIndex) = testSquarepieceMoves++end ifend if//pawn NE (captures)testMask = sq2Mask (querySquare)newMask = testMask + wPawnMask(1)testSquare = querySquare + wPawnVect(1)long if (maskBoard(newMask) = 1 )long if theBoard.square[testSquare] < 0moveIndex = numMoves + pieceMovesattackedSquares(moveIndex) = testSquarepieceMoves++end ifend if//pawn enPassant-West (captures)testMask = sq2Mask (querySquare)newMask = testMask + wPawnMask(4)testSquare = querySquare + wPawnVect(4)fromY = fn sq2Y(querySquare)long if (maskBoard(newMask) = 1 )long if (fromY = 4) and (testSquare = theBoard.enPassantSq)moveIndex = numMoves + pieceMovesattackedSquares(moveIndex) = querySquare + 7 //legal cause Y=6 and enPasSq=onBoardpieceMoves++end ifend if//pawn enPassant-East (captures)testMask = sq2Mask (querySquare)newMask = testMask + wPawnMask(5)testSquare = querySquare + wPawnVect(5)fromY = fn sq2Y(querySquare)long if (maskBoard(newMask) = 1 )long if (fromY = 4) and (testSquare = theBoard.enPassantSq)moveIndex = numMoves + pieceMovesattackedSquares(moveIndex) = querySquare + 9 //legal cause Y=5 and enPasSq=onBoardpieceMoves++end ifend ifend fn = pieceMoveslocal fn bPawnAttacks( querySquare as long, theBoard as ^boardRecord, attackedSquares(_maxMoves) as long, numMoves as long, pieceColour as long )dim as long moveIndex, pieceMoves, fromYdim as long testMask, newMask, testSquarepieceMoves = 0//black pawn SW (captures)testMask = sq2Mask (querySquare)newMask = testMask + bPawnMask(0)testSquare = querySquare + bPawnVect(0)long if (maskBoard(newMask) = 1 )long if theBoard.square[testSquare] > 0moveIndex = numMoves + pieceMovesattackedSquares(moveIndex) = testSquarepieceMoves++end ifend if//black pawn SE (captures)testMask = sq2Mask (querySquare)newMask = testMask + bPawnMask(1)testSquare = querySquare + bPawnVect(1)long if (maskBoard(newMask) = 1 )long if theBoard.square[testSquare] > 0moveIndex = numMoves + pieceMovesattackedSquares(moveIndex) = testSquarepieceMoves++end ifend if//pawn enPassant-East (captures)testMask = sq2Mask (querySquare)newMask = testMask + bPawnMask(4)testSquare = querySquare + bPawnVect(4)fromY = fn sq2Y(querySquare)long if (maskBoard(newMask) = 1 )long if (fromY = 3) and (testSquare = theBoard.enPassantSq)moveIndex = numMoves + pieceMovesattackedSquares(moveIndex) = querySquare - 7 //legal cause Y=3 and enPasSq=onBoardpieceMoves++end ifend if//pawn enPassant-West (captures)testMask = sq2Mask (querySquare)newMask = testMask + bPawnMask(5)testSquare = querySquare + bPawnVect(5)fromY = fn sq2Y(querySquare)long if (maskBoard(newMask) = 1 )long if fromY = 3 and testSquare = theBoard.enPassantSqmoveIndex = numMoves + pieceMovesattackedSquares(moveIndex) = querySquare - 9 //legal cause Y=3 and enPasSq=onBoardpieceMoves++end ifend ifend fn = pieceMoveslocal fn bishopAttacks( querySquare as long, theBoard as ^boardRecord, attackedSquares(_maxMoves) as long, numMoves as long, pieceColour as long )dim as long testSquare, moveIndexdim as long pieceMoves, pieceHitdim as long vectorCount, testMask, newMaskpieceMoves = 0for vectorCount = 0 to 3pieceHit = 0testSquare = querySquareDO//start by hitting ourselves onceif (pieceHit < 2) and ( (theBoard.square[testSquare] * pieceColour) > 0 ) then pieceHit++//bishop capturelong if (pieceHit < 2) and ( (theBoard.square[testSquare] * pieceColour) < 0 )pieceHit++moveIndex = numMoves + pieceMovesattackedSquares(moveIndex) = testSquarepieceMoves++end if//set the next bishap vector and Do the Doodle Doo..testMask = sq2Mask(testSquare)newMask = testMask + bishopMask(vectorCount)testSquare = testSquare + bishopVect(vectorCount)until (piecehit=2) or (maskBoard(newMask) = -1 )next vectorCountend fn = pieceMoveslocal fn rookAttacks( querySquare as long, theBoard as ^boardRecord, attackedSquares(_maxMoves) as long, numMoves as long, pieceColour as long )dim as long testSquare, moveIndexdim as long pieceMoves, pieceHitdim as long vectorCount, testMask, newMaskpieceMoves = 0for vectorCount = 0 to 3pieceHit = 0testSquare = querySquareDO//start by hitting ourselves onceif (pieceHit < 2) and ( (theBoard.square[testSquare] * pieceColour) > 0 ) then pieceHit++//rook capturelong if (pieceHit < 2) and ( (theBoard.square[testSquare] * pieceColour) < 0 )pieceHit++moveIndex = numMoves + pieceMovesattackedSquares(moveIndex) = testSquarepieceMoves++end if//set the next rook vector and Do the Doodle Doo..testMask = sq2Mask(testSquare)newMask = testMask + rookMask(vectorCount)testSquare = testSquare + rookVect(vectorCount)until (piecehit=2) or (maskBoard(newMask) = -1 )next vectorCountend fn = pieceMoveslocal fn knightAttacks( querySquare as long, theBoard as ^boardRecord, attackedSquares(_maxMoves) as long, numMoves as long, pieceColour as long )dim as long moveIndex, pieceMovesdim as long testMask, newMask, testSquare, vectorCountpieceMoves = 0for vectorCount = 0 to 7testMask = sq2Mask (querySquare)newMask = testMask + knightMask(vectorCount)testSquare = querySquare + knightVect(vectorCount)long if (maskBoard(newMask) = 1 )long if ((theBoard.square[testSquare] * pieceColour) < 0)moveIndex = numMoves + pieceMovesattackedSquares(moveIndex) = testSquarepieceMoves++end ifend ifnext vectorCountend fn = pieceMoveslocal fn kingAttacks( querySquare as long, theBoard as ^boardRecord, attackedSquares(_maxMoves) as long, numMoves as long, pieceColour as long )dim as long moveIndex, pieceMovesdim as long testMask, newMask, testSquare, vectorCountpieceMoves = 0for vectorCount = 0 to 7testMask = sq2Mask (querySquare)newMask = testMask + kingMask(vectorCount)testSquare = querySquare + kingVect(vectorCount)long if (maskBoard(newMask) = 1 )long if ( (theBoard.square[testSquare] * pieceColour) < 0 )moveIndex = numMoves + pieceMovesattackedSquares(moveIndex) = testSquarepieceMoves++end ifend ifnext vectorCountend fn = pieceMoveslocal fn isAttacked( querySquare as long, theBoard as ^boardRecord) as booleandim as Boolean attackeddim as long attackedSquares(_maxAttacks)dim as long n, sq, numMoves, pieceTypeattacked = _truepieceType = theBoard.square[querySquare]for sq = 0 to 63//white pawn attackslong if (theBoard.square[sq] = 1) and (theBoard.who2move = 1)numMoves = 0numMoves = fn wPawnAttacks( sq, theBoard, attackedSquares(0), numMoves, theBoard.who2move )for n = 0 to numMoves-1if attackedSquares(n) = querySquare then exit fnnext n end if//black pawn attackslong if (theBoard.square[sq] = -1) and (theBoard.who2move = -1)numMoves = 0numMoves = fn bPawnAttacks( sq, theBoard, attackedSquares(0), numMoves, theBoard.who2move )for n = 0 to numMoves-1if attackedSquares(n) = querySquare then exit fnnext n end if//bishop (and diagonal queen) attackslong if (theBoard.square[sq] * theBoard.who2move = 2) or (theBoard.square[sq] * theBoard.who2move = 5)numMoves = 0numMoves = fn bishopAttacks( sq, theBoard, attackedSquares(0), numMoves, theBoard.who2move )for n = 0 to numMoves-1if attackedSquares(n) = querySquare then exit fnnext n end if//rook (and perpendicular queen) attackslong if (theBoard.square[sq] * theBoard.who2move = 4) or (theBoard.square[sq] * theBoard.who2move = 5)numMoves = 0numMoves = fn rookAttacks( sq, theBoard, attackedSquares(0), numMoves, theBoard.who2move )for n = 0 to numMoves-1if attackedSquares(n) = querySquare then exit fnnext n end if//knight attackslong if (theBoard.square[sq] * theBoard.who2move = 3)numMoves = 0numMoves = fn knightAttacks( sq, theBoard, attackedSquares(0), numMoves, theBoard.who2move )for n = 0 to numMoves-1if attackedSquares(n) = querySquare then exit fnnext n end if//king attackslong if (theBoard.square[sq] * theBoard.who2move = 6)numMoves = 0numMoves = fn kingAttacks( sq, theBoard, attackedSquares(0), numMoves, theBoard.who2move )for n = 0 to numMoves-1if attackedSquares(n) = querySquare then exit fnnext n end ifnext sqattacked = _falseend fn = attacked