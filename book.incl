// pChess 1.9.4// Opening Book Routines// Written By John Roland Penner <johnrolandpenner-at-gmail-dot-com>// This file is released under the GNU public license, 2011. // Created: May 14, 2010 (Toronto Island)// Updated as of: February 18, 2012local FN loadBook as OSStatusdim as str255 filePathdim as FSRef appFolderRef, refdim as OSStatus errdim as long n, z, markdim as str255 a,bdim as str255 buildChaindim as str255 words(_maxWords)dim as long numEle, y, y2//zero out the global booknumBookMoves = 0 : blockZero( gBook(0), sizeof( bookRecord ) )err = _NoErr#if (_buildAsUCIengine == _false)filePath = "pChess.app/Contents/Resources/pBook.txt"#endif#if (_buildAsUCIengine == _true)filePath = "pBook.txt"#endiffn FD_ApplicationDirectoryGetFSRef( @appFolderRef )#if (_buildAsUCIengine == _false)fn FD_PathGetFSRef( fn CFSTR( "pChess.app/Contents/Resources/pBook.txt" ), @appFolderRef, @ref )#endif#if (_buildAsUCIengine == _true)fn FD_PathGetFSRef( fn CFSTR( "pBook.txt" ), @appFolderRef, @ref )#endif//Open the Book Filelong if (filePath)open "R",1,@ref#if _buildAsUCIEngine == _falseedit$(8) = "Loading Book.."#endifn=0 : b="" : mark=0while ( eof(1) == 0 )line input #1, a//print n;along if (a<>"") and (left$(a,1) <> "[") and (left$(a,2)<>"//")long if left$(a,2) = "{ "// this is a titled entry (i.e. starts with '{ ')a = right$(a, len(a)-2 )for z=1 to len(a)if mid$(a,z,1)="}" then mark=z : exit nextnext zgBook.Title(numBookMoves) = left$(a,mark-1)gBook.moveChain(numBookMoves) = right$(a,(len(a)-(mark+1)))numBookMoves++n++xelse// otherwise, add the line as an untitled entrygBook.Title(numBookMoves) = ""gBook.moveChain(numBookMoves) = anumBookMoves++n++end if// we must strip out the move numbers to build move chains// against which to compare the gameChain. this assumes NO SPACES // between number.and move. example: 1.d4 Nf6 2.Nf3 e6 3.c4 b6...numEle = fn getWords( gBook.moveChain(numBookMoves-1), words(0) )for y = 0 to numEle-1long if (words(y)<>"")for y2 = 1 to len( words(y) )if mid$( words(y), y2, 1 ) = "." then words(y) = right$( words(y), len(words(y))-y2 )next y2end ifnext ybuildChain = ""for y = 0 to numEle-1buildChain += words(y) + " "next ygBook.moveChain(numBookMoves-1) = buildChainend ifwendclose #1// Announce that it all Got LoadedgUseBook = _true#if _buildAsUCIEngine == _falsedim as str255 tempmenu 3,18,_checkededit$(8) = "Opening Book Loaded - " + str$(numBookMoves-1) + " openings."temp = "Opening Book Loaded - " + str$(numBookMoves-1) + " openings."fn speak(temp, 0) : edit$(8)=temp : edit$(9)=""#endifXELSE// User Cancelled#if _buildAsUCIEngine == _falsewindow #1#endifexit fnend ifend FN = errlocal FN matchBook(moveChain as str255)dim as long z, z2, n, n2, numMatchesdim as bookRecord tempBook(_maxBookOpenings)dim as long shortest, highPick, pickIndexdim as str255 bookPicknumMatches = 0n = fn numElements(moveChain)for z = 0 to numBookMoves-1n2 = fn numElements(gBook.moveChain(z))long if n2 => nfor z2 = len(gBook.moveChain(z)) to len(moveChain) step -1// the start of the string must equal the current moveChainlong if (left$(gBook.moveChain(z), z2) = moveChain) and (len(gBook.moveChain(z)) => (len(moveChain)) )tempBook(numMatches) = gBook(z)numMatches++end ifnext z2end ifnext z// and then we pick the shortest opening line // that matches the current gameChain bookPick = "" : highPick = 0 : pickIndex = 0shortest = 255long if numMatches => 1for z2 = 0 to numMatches-1long if len(tempBook.moveChain(z2)) < shortestshortest = len(tempBook.moveChain(z2))pickIndex = z2end ifnext z2// normally, it picks the SHORTEST opening, this makes it random. if (_rndBook = _True) then pickIndex = rnd(numMatches)// naughty using global variables for something like this.. :-PgBookTitle = tempBook.Title(pickIndex)end ifend FN = numMatcheslocal FN pickBook(moveChain as str255) as str255dim as long z, z2, z3, n, n2, numMatchesdim as long highPick, pickIndex, longestdim as bookRecord tempBook(_maxBookOpenings)dim as str255 bookPickdim as long numWordsdim as str255 words(_maxWords)// first we find all the opening lines that match..numMatches = 0n = fn numElements(moveChain)for z = 0 to numBookMoves-1n2 = fn numElements(gBook.moveChain(z))long if n2 => nfor z2 = len(gBook.moveChain(z)) to len(moveChain) step -1// the start of the string must equal the current moveChainlong if (left$(gBook.moveChain(z), z2) = moveChain) and (len(gBook.moveChain(z)) => (len(moveChain)) )tempBook(numMatches) = gBook(z)numMatches++end ifnext z2end ifnext z// and then we pick the longest opening line // that contains at least one more move.. bookPick = "" : highPick = 0 : pickIndex = 0longest = 0long if numMatches => 1for z2 = 0 to numMatches-1long if len(tempBook.moveChain(z2)) > longestlongest = len(tempBook.moveChain(z2))pickIndex = z2end ifnext z2// normally, it picks the LONGEST opening, this makes it random. long if (_rndBook = _True)pickIndex = rnd(numMatches)end if//zero out the wordsfor z3 = 0 to _maxWordswords(z3)=""next z3//get the moves in the longest string, // and extract the next WORD as the next move.numWords = fn getWords(tempBook.moveChain(pickIndex), words(0) )bookPick = words(gBoard.halfMoves)// naughty using global variables for something like this.. :-PgBookTitle = tempBook.Title(pickIndex)end ifend FN = bookPick