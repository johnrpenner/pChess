// pChess 1.9// Hash Tables 1.0, Modelled on RChess Hash Tables by Robert Purves// John Roland Penner <johnrolandpenner-at-gmail-dot-com>// This file is released under the GNU public license, 2011. // Created: April 22, 2011 (Toronto Island)// Updated as of: November 11, 2011/*//--| TO DO |-----------------------//+ setup hash in declarations+ setup hash.incl+ call initHashCodes from main+ call initHashTable from computerMove()+ add hash to search.incl+ add hash to fn makeMove()+ add FN putSuppliedMoveFirst+ rewrite fn computerSearch() to use itterative deepening- full hash support in FN makeMove()     + side-to-move ( not(board.hashCode) )     - K and R moves in castling     - castling rights     - P movement and capture in e.p. move     - change of e.p. status*///===| DECLARATIONS |=============================================== #define BitBoard as UInt64_hashSeed = 515198     // arbitrary_hashTableSize = 2^21 // 64 MB_hashIndexMask = _hashTableSize - 1_positionNotFound           = -_maxLong_positionFoundButNotUseable = _maxLong//===| FUNCTIONS |================================================== // 64 bit Zobrist Hashinglocal fn Rnd64 as UInt64'~'1dim as UInt64  bb = rnd( 65536 ) - 1b = (b << 16) or (rnd( 65536 ) - 1)b = (b << 16) or (rnd( 65536 ) - 1)b = (b << 16) or (rnd( 65536 ) - 1)end fn = blocal fn initHashCodes'~'1dim as long sq, piece, siderandomize _hashSeedfor piece = 1 to 6for side = -1 to 1 step 2for sq = 0 to 63gPieceHashCode(sq, piece, 1 - side) = fn Rnd64next sqnext sidenext piece// gCastleKSideHashCode = fn Rnd64// gCastleQSideHashCode = fn Rnd64gEnPassantHashCode = fn Rnd64gSideHashCode = fn Rnd64end fnlocal fn initHashTable'~'1long if ( gHashTable == 0 ) gHashTable = fn malloc( _hashTableSize*sizeof( hashRecord ) )if ( gHashTable == 0 ) then shutdown "initHashTable failed"end ifBlockZero( gHashTable, _hashTableSize*sizeof( hashRecord ) )// initialize statistics on hash activitygNumPositionsSavedInHashTable = 0gNumSearchesOfHashTable = 0gNumPositionsFoundInHashTable = 0gNumPositionsNotFoundInHashTable = 0gNumPositionsUseableInHashTable = 0gNumHashTableMovesUsed = 0end fnlocal fn findHash( hashCode as UInt64, outMove as ^moveRecord, alpha as long, beta as long, depth as long )'~'1dim as long      i, scoredim as Boolean   useablexref theHashTable(_maxLong) as hashRecordgNumSearchesOfHashTable++theHashTable = gHashTablei = hashCode and _hashIndexMask // simple hashing functionscore = _positionNotFound#if _useHashTable == _falseexit fn#endiflong if ( theHashTable.hashCode(i) == hashCode )// hitscore = _positionFoundButNotUseableuseable = _falselong if ( theHashTable.depth(i) >= depth )useable = (theHashTable.scoreType(i) == _exactScore)if not( useable ) then useable = (theHashTable.scoreType(i) == _upperBound and theHashTable.score(i) < alpha)if not( useable ) then useable = (theHashTable.scoreType(i) == _lowerBound and theHashTable.score(i) >= beta)end iflong if ( useable )// bullseye (jackpot)score = theHashTable.score(i)gNumPositionsUseableInHashTable++xelseBlockMoveData( @theHashTable.recommendedMove(i), outMove, sizeof( moveRecord ) )gNumPositionsFoundInHashTable++end ifxelse// missgNumPositionsNotFoundInHashTable++end ifend fn = scorelocal fn saveHash( hashCode as UInt64, inMove as ^moveRecord, alpha as long, origAlpha as long, beta as long, depth as long )'~'1dim as long     ixref theHashTable(_maxLong) as hashRecordtheHashTable = gHashTablei = hashCode and _hashIndexMask // simple hashing functionif ( theHashTable.depth(i) > depth ) then exit fn // don't overwrite a pre-existing entry that was searched more deeplytheHashTable.hashCode(i)        = hashCodetheHashTable.recommendedMove(i) = inMovetheHashTable.score(i)           = alphatheHashTable.depth(i)           = depthlong if ( alpha == origAlpha )theHashTable.scoreType(i) = _upperBoundxelseif ( alpha >= beta ) then theHashTable.scoreType(i) = _lowerBound else theHashTable.scoreType(i) = _exactScoreend ifgNumPositionsSavedInHashTable++end fn