/*===| pChess |==============================================================// *  *  pChess 2.0 (white rabbit edition) *  Released under the GNU Public License 2012 *  By: John Roland Penner <johnrolandpenner-at-gmail-dot-com> *  Created: February 9, 2010 (Toronto Island) *  Updated: July 30, 2012 *  *//*===| THANKS |==============================================================// *  *  People to Thank as Sources upon which I drew, include:  *  Robert Purves, Mentoring, Spandrel Chess and FutureBasic, 2010-2011.  *  Claude Shannon, Programming a Computer for Playing Chess, 1949.  *  Craig S. Bruce and Kevin Phillips, KC Chess, 1990.  *  Colin Frayn, Computer Chess Programming Theory, August 2005.  *  Tom Kerrigan, Tom Kerrigans Simple Chess Program (TSCP), 1997.  *  Ed Schroder, How Rebel Plays Chess, 2004.  *  John Renner, Adobe Systems, for Use of: CHEQ Font, 1989. ** *  John Penner Sr, and Gregory Steiner for many challenging games of Real Chess. *  Rosie Shaw, for Beta Testing and Excellent Companionship, August 2009.  *  Kinga Burjan, for Beta Testing and Support, 2010.  *  Brendan Ferguson, for Release Management and Code Scrubbing.  *  */#if (_buildAsUCIEngine == _false)#if (_devLog)include "ConsoleWindow"#endif// default file name and versionoutput file "pChess" : override _versionString$ = "2.0"/*For best speed (assuming Intel), use the following build settings [RP]: [1] set 'Optimization' to Fastest[2] set 64-bit mode by putting -m64 in 'More compiler options'[3] for Core i5 and i7 CPU, append  -DHAS_POPCNT  to 'More compiler options'[4] for best clang build, 'Source-file combining' OFF and use -flto    -m64 -DHAS_POPCNT -flto*///===| INCLUDES |=============================================================//// Graphics Depend on the existence of Adobe's free 'CHEQ' font// Designed by John Renner for Adobe Systems in 1989: // http://tug.ctan.org/tex-archive/fonts/chess/cheq/// SPEECH INCLUDEinclude "Tlbx SpeechSynthesis.Incl"// TIMER INCLUDEinclude "Tlbx Timer.incl"// SOUND INCLUDESinclude "Tlbx MoreFilesX.incl"include resources "psnd Check.aif"include resources "psnd Mate.aif"include resources "psnd Promotion.aif"// QUARTZ INCLUDEinclude "Quartz.incl"// NIB RESOURCE INCLUDES (from 'SimpleNib.bas')include "Tlbx IBCarbonRuntime.incl"include resources "main.nib"#if _buildPPC == _false// FONT EMBED INCLUDES (requires OSX 10.5)  include "Util_FileDirectory.incl"  include resources "Fonts" // in which lives the CHEQ Font  toolbox fn ATSFontActivateFromFileReference ( const FSRef *iFile, ATSFontContext iContext, ATSFontFormat iFormat, pointer iRefCon, ATSOptionFlags iOptions, ATSFontContainerRef *oContainer) = OSStatus  toolbox fn ATSFontFamilyFindFromQuickDrawName( ConstStr255Param iName ) = ATSFontFamilyRef#endif// OPENING BOOKinclude resources "pBook.txt"// SOURCE FILE INCLUDESinclude "declares.incl"include "display.inclinclude "moves.incl"include "attacks.incl"include "eval.incl"include "search.incl"include "book.incl"include "prefs.incl"include "perft.incl"// DEBUG LOG#if _logCommandsReceiveddim as FSSpec  gLogFilefn FSMakeFSSpec( system( _aplVRefNum ), system( _aplParID ), "pChess.log", @gLogFile )open "O", 99, @gLogFile#endif//===| FUNCTIONS |============================================================//local fn hasSpeechMgr     // non-zero for Speech Mgr (gcc4.0 not 4.2)dim @ speechAttr as shortend fn = fn Gestalt(_"ttsc",speechAttr) = _noErrlocal fn speak(speech as str255, hold as long)dim as long talktalk = 0long if gSpeech = _True//long if fn hasSpeechMgrlong if hold = _True talk = fn SpeakString (speech) while fn SpeechBusy wendxelse talk = fn SpeakString (speech)end if//end ifend ifend fn = talk#if _buildPPC == _falselocal modelocal fn ActivateFontFromResourcesFile( fontFileName as CFStringRef )// compatibility note: this function REQURIES OSX 10.5dim as CFURLRef          resourcesCFURL, urldim as FSRef             resourcesFSRef,fileRefdim as OSStatus          err : err = _dirNFErrresourcesCFURL = fn CFBundleCopyResourcesDirectoryURL( fn CFBundleGetMainBundle )url            = fn CFURLCreateCopyAppendingPathComponent( _kCFAllocatorDefault, resourcesCFURL, @"Fonts", _false )CFRelease( resourcesCFURL )long if ( url )fn CFURLGetFSRef( url, @resourcesFSRef )CFRelease( url )err = fn FD_PathGetFSRef( fontFileName, @resourcesFSRef, @fileRef )if ( err == _noErr ) then err = fn ATSFontActivateFromFileReference( @fileRef, _kATSFontContextLocal, _kATSFontFormatUnspecified, 0, _kATSOptionFlagsDefault, #0 )end ifend fn = err#endif// Confirmation Dialogue// Robert Purves, October 17, 2005// Returns _zTrue if user clicks the right-hand (action) button, else _falselocal modelocal fn confirmDialogue( message as Str255, explanation as Str255, actionBtnTitle as Str255, otherBtnTitle as Str255 )'~'1dim as AlertStdAlertParamRec  paramRecdim as SInt16                 itemHitdim as Boolean                confirmedBlockZero( @paramRec, sizeof( paramRec ) )//paramRec.cancelText  = _kAlertDefaultCancelTextparamRec.cancelText  = @otherBtnTitleparamRec.defaultText = @actionBtnTitle//paramRec.defaultButton = _kAlertStdAlertCancelButtonparamRec.defaultButton = 1paramRec.cancelButton = 2fn StandardAlert( _kAlertCautionAlert, message, explanation, @paramRec, @itemHit )confirmed = ( itemHit == _kAlertStdAlertOKButton )end fn = confirmed// these four functions used by TIMER Interupt (supplied by R.Purves)local fn ClearAbortSearchsAbortSearch = _falseend fnlocal fn SetAbortSearchsAbortSearch = _trueend fnlocal fn IsSearchAbortedend fn = sAbortSearchlocal modelocal fn CheckForAbortSignalif inkey$=chr$(27) then fn SetAbortSearch     // ESC key/*dim as EventRef     evntif ( fn CheckEventQueueForUserCancel() ) then fn SetAbortSearch// CarbonEvents equivalent of HandleEventswhile ( fn ReceiveNextEvent( 0, #0, 0.0, _true, @evnt ) == _noErr )fn SendEventToEventTarget( evnt, fn GetEventDispatcherTarget() )ReleaseEvent( evnt )wend*/end fn/*play a movie sound synchronously (this function does not return until the movie is done)*/local fn PlayMovieSoundFromFSSpec( fs as ^FSSpec )dim as OSStatus          errdim as Movie           @ theSounddim as short           @ fileRefNumerr = fn OpenMovieFile( #fs, @fileRefNum, _fsRdPerm )long if ( err == _noErr )err = fn NewMovieFromFile( @theSound, fileRefNum, #0, #0,  1, #0 )long if ( err == _noErr )err = fn CloseMovieFile( fileRefNum )long if ( err == _noErr )GoToBeginningOfMovie( theSound )StartMovie( theSound )doMoviesTask( theSound, 0 )delay 17 until ( fn IsMovieDone( theSound ) )DisposeMovie( theSound )end ifend ifend ifend fn = err/*inName is name of file in stand-alone app's folder,or in bundled app's Contents/Resources folder*/local fn FSSpecFromSupportFileName( inName as Str255, outSpec as ^FSSpec )dim as OSStatus          errdim as CFURLRef          urldim as FSRef             fsRefdim as CFStringRef       cfStrdim as Boolean           refOKerr = _fnfErrcfStr = fn CFStringCreateWithPascalString( _kCFAllocatorDefault, inName, _kCFStringEncodingMacRoman )url = fn CFBundleCopyResourceURL( fn CFBundleGetMainBundle(), cfStr, 0, 0 )CFRelease( cfStr )if ( url == 0 ) then exit fnrefOK = fn CFURLGetFSRef( url, @fsRef )CFRelease( url )if ( refOK ) then err = fn FSGetCatalogInfo( @fsRef,  0, #0, #0, #outSpec, #0 )end fn = err  local fn playSound( fName as Str255 )dim as FSSpec            theSpecdim as OSStatus          errerr = fn FSSpecFromSupportFileName( fName, @theSpec )if ( err ==  _noErr ) then err = fn PlayMovieSoundFromFSSpec( @theSpec )end fn = errlocal modelocal fn Milliseconds as long // time in ms since prog startdim as UnsignedWide usbegin globalsdim as double       sProgStartTimeend globalslong if ( sProgStartTime == 0.0 )Microseconds( @us )sProgStartTime = 4294967296.0*us.hi + us.loend ifMicroseconds( @us )end fn = (4294967296.0*us.hi + us.lo - sProgStartTime)*1e-3local FN timeAdd(tOne as str255, tTwo as str255) as str255dim as long totalStartSecs, totalEndSecs, totalSecsdim as long startSec, startMin, startHrdim as long endSec, endMin, endHrdim as long deltaHr, deltaMin, deltaSecdim dum as str255startHr = val(mid$(tOne,1,2))startMin = val(mid$(tOne,4,2))startSec = val(mid$(tOne,7,2))totalStartSecs = startSec + startMin*60 + startHr *3600endHr = val(mid$(tTwo,1,2))endMin = val(mid$(tTwo,4,2))endSec = val(mid$(tTwo,7,2))totalEndSecs = endSec + endMin*60 + endHr*3600totalSecs = totalStartSecs + totalEndSecsdeltaHr = int(totalSecs / 3600)deltaMin = int( (totalSecs - (deltaHr*3600)) / 60 )deltaSec = totalSecs - (deltaHr*3600) - (deltaMin*60)dum = right$(str$(deltaHr),len(str$(deltaHr))-1) + ":"long if deltaMin < 10dum = dum + "0" + right$(str$(deltaMin),len(str$(deltaMin))-1) + ":"xelsedum = dum + right$(str$(deltaMin),len(str$(deltaMin))-1) + ":"end iflong if deltaSec < 10dum = dum + "0" + right$(str$(deltaSec),len(str$(deltaSec))-1)xelsedum = dum + right$(str$(deltaSec),len(str$(deltaSec))-1)end ifif deltaHr < 10 then dum = "0" + dumend fn = dumlocal FN timeDelta(tStart as str255, tEnd as str255) as str255dim as long startSec, startMin, startHrdim as long endSec, endMin, endHrdim as long totalStartSecs, totalEndSecsdim as long delta, deltaHr, deltaMin, deltaSecdim dum as str255startHr = val(mid$(tStart,1,2))startMin = val(mid$(tStart,4,2))startSec = val(mid$(tStart,7,2))totalStartSecs = startSec + startMin*60 + startHr *3600endHr = val(mid$(tEnd,1,2))endMin = val(mid$(tEnd,4,2))endSec = val(mid$(tEnd,7,2))totalEndSecs = endSec + endMin*60 + endHr*3600// IF IT ROLLS PAST MIDNIGHT > WE ASSUME NEXT DAYlong if totalEndSecs > totalStartSecs delta = totalEndSecs - totalStartSecsxelsedelta = (86400-totalStartSecs)+ totalEndSecsend ifif totalEndSecs = totalStartSecs then delta = 0deltaHr = int(delta / 3600)deltaMin = int( (delta - (deltaHr*3600)) / 60 )deltaSec = delta - (deltaHr*3600) - (deltaMin*60)dum = right$(str$(deltaHr),len(str$(deltaHr))-1) + ":"long if deltaMin < 10dum = dum + "0" + right$(str$(deltaMin),len(str$(deltaMin))-1) + ":"xelsedum = dum + right$(str$(deltaMin),len(str$(deltaMin))-1) + ":"end iflong if deltaSec < 10dum = dum + "0" + right$(str$(deltaSec),len(str$(deltaSec))-1)xelsedum = dum + right$(str$(deltaSec),len(str$(deltaSec))-1)end ifif deltaHr < 10 then dum = "0" + dumend fn = dumlocal modelocal FN copyBoard( source as ^boardRecord, dest as ^boardRecord )//dest.previousBoard = source // if you needed a linked listblockMoveData( source, dest, sizeof( boardRecord ) )end fnlocal FN resetPGN// initialize PGN game infogGame.tourn = ""gGame.site = ""gGame.date = ""gGame.round = ""gGame.white = ""gGame.black = ""gGame.result = "*"gGame.variant = ""gGame.gameFEN = ""end fnLOCAL FN initBoard_classic (board as ^boardRecord)dim as str255 defaultMovedim as long n fn speak("Classic Initialized", 0)defaultMove = ""edit$(8) = "Processing..."// initialize game statescomputerTime = "00:00:00"userTime = "00:00:00"userStart = time$gPromotion = _falsegameChain = ""gMoveCount = 0gDispCount = gMoveCountgWho2Move = _whiteegDispFlip = _whitee// classic should use bookgUseBook=_truemenu 3,18,_checked// stuff to record the game history in gameBoards()blockZero( gameBoards(0), sizeof(boardRecord) )// zero out move historyblockZero( gMoveList(0), sizeof(moveRecord) )// clear out first movegMoveList.fromSquare(0) = _noSuchSquaregMoveList.toSquare(0) = _noSuchSquaregMoveList.capturePiece(0) = 0gMoveList.promoPiece(0) = 0gMoveList.moveScore(0) = 0blockZero( board, sizeof( boardRecord ) )board.who2move = _whiteeboard.halfMoves = 0board.enPassantSq = _noSuchSquareboard.fiftyCount = 0board.hashCode = 0board.fischer = _falseboard.rookSq1 = _noSuchSquareboard.rookSq2 = _noSuchSquareboard.wCastleKside = _true     'start out able to castleboard.wCastleQside = _true     'start out able to castleboard.bCastleKside = _true     'start out able to castleboard.bCastleQside = _true     'start out able to castleboard.wHasCastled = _falseboard.bHasCastled = _false//setup pawnsfor n = 0 to 7board.square[n+8] = 1board.square[n+48] = -1 next n//init Classicboard.square[0] = 4 : board.square[56] = -4board.square[1] = 3 : board.square[57] = -3board.square[2] = 2 : board.square[58] = -2board.square[3] = 5 : board.square[59] = -5board.square[4] = 6 : board.square[60] = -6board.square[5] = 2 : board.square[61] = -2board.square[6] = 3 : board.square[62] = -3board.square[7] = 4 : board.square[63] = -4// make initial entry into the PREV NEXT historygameBoards(gMoveCount) = gBoardgDirtyFlag = _falsewindow #1, "pChess " + _version$edit$(8) = "Ready"edit$(9) = defaultMoveend fnLOCAL FN initBoard_fischer (board as ^boardRecord)dim as str255 defaultMovedim as long zdim as long diceSlots(8)dim as long dice1, dice2, dice3, dice4, dice5dim as long wIndx, bIndxdim as long slot, spaceCountdim as long qIndx, n1Indx, n2Indxdim as long r1Indx, kIndx, r2Indxfn speak("Fischer Initialized", 0)defaultMove = ".d4" edit$(8) = "Fischer:" edit$(9) = defaultMove// initialize game statescomputerTime = "00:00:00"userTime = "00:00:00"userStart = time$gPromotion = _falsegMoveCount = 0gDispCount = gMoveCountgWho2Move = _whiteegDispFlip = _whiteegameChain = ""gGame.variant = "[Variant " + chr$(34) + "fischerandom" + chr$(34) + "]"gGame.gameFEN = ""// disable opening book (fischer cant use it)gUseBook=_false : menu 3,18,1// stuff to record the game history in gameBoards()blockZero( gameBoards(0), sizeof(boardRecord) )// zero out move historyblockZero( gMoveList(0), sizeof(moveRecord) )// clear out first movegMoveList.fromSquare(0) = _noSuchSquaregMoveList.toSquare(0) = _noSuchSquaregMoveList.capturePiece(0) = 0gMoveList.promoPiece(0) = 0gMoveList.moveScore(0) = 0// zero out the boardblockZero( board, sizeof( boardRecord ) )board.who2move = _whiteeboard.halfMoves = 0board.enPassantSq = _noSuchSquareboard.fiftyCount = 0board.hashCode = 0board.fischer = _trueboard.rookSq1 = _noSuchSquareboard.rookSq2 = _noSuchSquareboard.wCastleKside = _true     'start out able to castleboard.wCastleQside = _true     'start out able to castleboard.bCastleKside = _true     'start out able to castleboard.bCastleQside = _true     'start out able to castleboard.wHasCastled = _falseboard.bHasCastled = _false// roll in the fischer board (method by: Hans Bodlaender)for z=1 to 8diceSlots(z)=0next z     //zip out the dice slotsdice1=rnd(4)     //white bishopedit$(8) = edit$(8) + str$(dice1)wIndx = (2*dice1)     //diceSpace to boardSpacediceSlots(wIndx)=2     //fill the slot w/bishopdice2=rnd(4)     //black bishopedit$(8) = edit$(8) + str$(dice2)bIndx = (2*dice2)-1     //diceSpace to boardSpacediceSlots(bIndx)=2     //fill the slot w/bishopdice3=rnd(6)      //queenedit$(8) = edit$(8) + str$(dice3)slot=0 : spaceCount=0while spaceCount < dice3slot++if diceSlots(slot)=0 then spaceCount++wendqIndx=slotdiceSlots(qIndx)=5dice4=rnd(5)     //first knightedit$(8) = edit$(8) + str$(dice4)slot=0 : spaceCount=0while spaceCount < dice4slot++if diceSlots(slot)=0 then spaceCount++wendn1Indx=slotdiceSlots(n1Indx)=3dice5=rnd(4)     //second knightedit$(8) = edit$(8) + str$(dice5)slot=0 : spaceCount=0while spaceCount < dice5slot++if diceSlots(slot)=0 then spaceCount++wendn2Indx=slotdiceSlots(n2Indx)=3// remaining squares will be rook-king-rookspaceCount=0 : r1Indx=0 : kIndx=0 : r2Indx=0for slot = 1 to 8if diceSlots(slot)=0 and spaceCount=2 then r2Indx = slot : spaceCount++if diceSlots(slot)=0 and spaceCount=1 then kIndx = slot : spaceCount++if diceSlots(slot)=0 and spaceCount=0 then r1Indx = slot : spaceCount++next zdiceSlots(r1Indx) = 4diceSlots(kIndx) = 6diceSlots(r2Indx) = 4// update the boardRecord with the rookSqboard.rookSq1 = r1Indx-1board.rookSq2 = r2Indx-1// assign the diceSlots to the boardArray()for z = 1 to 8board.square[z-1] = diceSlots(z)board.square[z+7] = 1board.square[z+47] = -1 board.square[z+55] = -diceSlots(z)next z// make initial entry into the PREV NEXT historygameBoards(gMoveCount) = gBoard// setup game FEN stringgGame.gameFEN = fn toFENwindow #1, "pChess " + _version$gDirtyFlag = _falseend fnlocal fn alphaCol(column as long)//returns ascii values for ABCDEFGHdim as long alphaColalphaCol = 32if column = 1 then alphaCol = 97if column = 2 then alphaCol = 98if column = 3 then alphaCol = 99if column = 4 then alphaCol = 100if column = 5 then alphaCol = 101if column = 6 then alphaCol = 102if column = 7 then alphaCol = 103if column = 8 then alphaCol = 104end fn = alphaCollocal FN colVal(a as str255)dim as long xx=-1if a="a" or a="A" then x=1if a="b" or a="B" then x=2if a="c" or a="C" then x=3if a="d" or a="D" then x=4if a="e" or a="E" then x=5if a="f" or a="F" then x=6if a="g" or a="G" then x=7if a="h" or a="H" then x=8end FN = xlocal FN speakMove(StdMoveIn as str255, inBoard as ^boardRecord)dim as str255 StdMovedim as boardRecord theBoarddim as str255 pieceType, AlgebMovedim as str255 fromStr, toStrdim as str255 buildSuffix, buildStrdim as long x1, y1, strLengthdim as long numMoves, querySquaredim as moveRecord moves(_maxMoves)dim as str255 disAmbigStdMove = StdMoveInAlgebMove = "" : buildStr = "" : buildSuffix = ""FN copyBoard(inBoard, theBoard)// trap castling moves (we like the 'oh oh')long if (_castleOhOh)if (StdMove="O-O") or (StdMove="O-O-O") then fn speak(StdMove, _True) : exit fnxelseif (StdMove="O-O") then fn speak("Castle, King Side", _True) : exit fnif (StdMove="O-O-O") then fn speak("Castle, Queen Side", _True) : exit fnend if// determine suffixesif (right$(StdMove, 1) = "+") then buildSuffix = " Check! "if (right$(StdMove, 1) = "#") then buildSuffix = " Check Mate! Game Over "// strip suffixesstrLength = len(StdMove)while ( right$(StdMove, 1) = "+" ) or ( right$(StdMove, 1) = "#" )strLength --StdMove = left$(StdMove, strLength)wend// remove pawn promotion suffixlong if mid$(StdMove, len(StdMove)-1, 1) = "=" StdMove = left$(StdMove, len(StdMove)-2)buildSuffix = " queen promotion" + buildSuffixend if// strip it all down to find out the toStringfromStr = "" : toStr = right$(StdMove, 2)// it is a simple pawn movelong if len(StdMove)=2buildStr = "Pawn to " + toStr + buildSuffixfn speak(buildStr, _True)exit fnend if// disambiguate pawn moves, and send them on into the regular parser// this should take in moves like: axb5, dxc4 --to-be-like-this--> Paxb5, Pdxc4if (asc(mid$(StdMove, 1, 1)) > 96) and (asc(mid$(StdMove, 1, 1)) < 105) and (mid$(StdMove, 2, 1) = "x") then StdMove = "P" + StdMove// All Moves (expect simple pawn moves)long if ( len(StdMove) > 2 ) pieceType = mid$(StdMove, 1, 1)select pieceTypecase "P"buildStr = gPieceName(1)case "B"buildStr = gPieceName(2)case "N"buildStr = gPieceName(3)case "R"buildStr = gPieceName(4)case "Q"buildStr = gPieceName(5)case "K"buildStr = gPieceName(6)end select// algebraic toString coming in > querySquare[0-63] going out. x1 = fn colVal(mid$(toStr,1,1))y1 = val(mid$(toStr,2,1))if x1 < 1 or x1 > 8 then AlgebMove = "" : fn speak ("err " + buildStr, _false) : exit fnif y1 < 1 or y1 > 8 then AlgebMove = "" : fn speak ("err " + buildStr, _false) : exit fnblockZero( moves(0), sizeof( moveRecord ) )numMoves = 0 : querySquare = (x1-1) + (y1-1)*8numMoves = fn isTarget(querySquare, inBoard, moves(0), pieceType )// disambiguate here, before getting move2Algebraic()long if (numMoves = 2)// relies on the fact that it will be there if there is > 1 move!!disAmbig = mid$(StdMove, 2, 1)// for the better diction of the speech synthesizerselect disAmbigcase "a"disAmbig = "eh"case "b"disAmbig = "bee"case "c"disAmbig = "sea"case "d"disAmbig = "dee"case "e"disAmbig = "eee"case "f"disAmbig = "ef"case "g"disAmbig = "gee"case "h"disAmbig = "h"end selectbuildStr = buildStr + "on " + disAmbig + " "long if mid$(StdMove, 3, 1) = "x" buildStr = buildStr + "takes "xelsebuildStr = buildStr + "to "end ifbuildStr = buildStr + toStr + buildSuffixfn speak(buildStr, _False)exit fnxelselong if mid$(StdMoveIn, 2, 1) = "x" buildStr = buildStr + "takes "xelsebuildStr = buildStr + "to "end ifbuildStr = buildStr + toStr + buildSuffixfn speak(buildStr, _False)exit fnend ifend ifend fnlocal FN move2Algebraic(theMove as ^moveRecord) as str255dim as str255 moveStrdim as long fromX, fromYdim as long toX, toYmoveStr = ""fromX = fn sq2X(theMove.fromSquare) +1fromY = fn sq2Y(theMove.fromSquare) +1toX = fn sq2X(theMove.toSquare) +1toY = fn sq2Y(theMove.toSquare) +1moveStr = chr$(fn alphaCol(fromX))moveStr = moveStr + chr$(fromY + 48)moveStr = moveStr + chr$(fn alphaCol(toX))moveStr = moveStr + chr$(toY + 48)end fn = moveStr// NOTE! you must feed move2Std a board from BEFORE the move has been made!// as it can not disambiguate a move when the piece has already been moved. // thus, you typically call with something like: // moveDisp1 = fn move2Std( gMoveList(n), gameBoards(n-1) )local FN move2Std(theMove as ^moveRecord, theBoard as ^boardRecord) as str255dim as str255 AlgebMove, StdMovedim as str255 buildStr, pieceStrdim as long pieceTypedim as long checkReturndim as long numMovesdim as moveRecord moves(_maxMoves)dim as str255 Algeb1, Algeb2, toStrdim as boardRecord checkBoarddim as boolean gPromoTempAlgebMove = fn move2Algebraic( theMove )long if (_stdNotation == _true)buildStr = ""pieceType = theBoard.square[theMove.fromSquare]select abs(pieceType)case 0 : pieceStr = ""case 1 : pieceStr = ""case 2 : pieceStr = "B"case 3 : pieceStr = "N"case 4 : pieceStr = "R"case 5 : pieceStr = "Q"case 6 : pieceStr = "K"end selectbuildStr = pieceStr// DISAMBIGUATION iF necessary. // example 1: the following fen should yield the move: Nbxc6// fen: rnbnkb1r/p1p2ppp/2B5/4N3/4P1q1/1PN5/P1PP1PPP/R2QKB1R b KQkq// example 2: the following fen should yield the move: Rcxe8// fen: 2r1N1r1/2pn1k2/Bp6/p2p2Pp/P1NP1p1P/1P3P2/8/2R3K1 b -// example 3: the move Nd7 is ambiguous, so it should be: Nbd7// fen: rnbqkb1r/pp3p1p/3p1np1/2pP4/8/2N5/PP1NPPPP/R1BQKB1R b KQkqtoStr = right$(AlgebMove, 2)numMoves = 0 : blockZero( moves(0), sizeof( moveRecord ) )numMoves = fn isTarget(theMove.toSquare, theBoard, moves(0), pieceStr )long if (numMoves > 1) and (abs(pieceType) > 1)Algeb1 = FN move2Algebraic( moves(0) )Algeb2 = FN move2Algebraic( moves(1) )// FILE [A..D] is the same, thus disambig with RANK[1..6]long if ( mid$(Algeb1, 1, 1) = mid$(Algeb2, 1, 1) )if theMove.fromSquare = moves.fromSquare(0) then buildStr = buildStr + mid$(Algeb1, 2, 1)if theMove.fromSquare = moves.fromSquare(1) then buildStr = buildStr + mid$(Algeb2, 2, 1)xelse// otherwise disambiguate with FILE[A..D]if theMove.fromSquare = moves.fromSquare(0) then buildStr = buildStr + mid$(Algeb1, 1, 1)if theMove.fromSquare = moves.fromSquare(1) then buildStr = buildStr + mid$(Algeb2, 1, 1)end ifend if// indicate CAPTURE with a 'x' (pawns will always disambiguate with a FILE[A..H] )if ( abs(pieceType) == 1) and ( theMove.capturePiece <> 0 ) then buildStr = left$(AlgebMove, 1) + "x"if ( abs(pieceType) > 1 ) and ( theMove.capturePiece <> 0 ) then buildStr = buildStr + "x"// destination square only comes after all the abovebuildStr = buildStr + toStr// test for check/mate/stale// disambiguation requires board BEFORE the move// check testing requires board AFTER the movecheckBoard = theBoardgPromoTemp = gPromotion : gPromotion = _falsefn makeMove ( checkBoard, theMove )// suffix pawn-queen promotionif gPromotion = _true then buildStr = buildStr + "=Q"gPromotion = gPromoTemp// throw away all the above finegaling if it is actually a castling move// yes, we had to do all the above finegaling, in order to get the fromPiece// BUG (fixed): e1g1 should NOT = O-O: R7/p2k4/1pn5/2p1p3/7r/8/P6P/4R2K w -if ((AlgebMove="e1g1") or (AlgebMove="e8g8")) and (abs(theBoard.square[theMove.fromSquare])=6) then buildStr="O-O"if ((AlgebMove="e1c1") or (AlgebMove="e8c8")) and (abs(theBoard.square[theMove.fromSquare])=6) then buildStr="O-O-O"// fischer castlingif (theBoard.fischer == _true) and (abs(theBoard.square[theMove.fromSquare])=6) and (abs(theBoard.square[theMove.toSquare])=4) and ( (theMove.toSquare = theBoard.rookSq1) or (theMove.toSquare = theboard.rookSq1+56) ) then buildStr="O-O-O"if (theBoard.fischer == _true) and (abs(theBoard.square[theMove.fromSquare])=6) and (abs(theBoard.square[theMove.toSquare])=4) and ( (theMove.toSquare = theBoard.rookSq2) or (theMove.toSquare = theboard.rookSq2+56) ) then buildStr="O-O"// suffix checkcheckReturn = fn checkTest(checkBoard)if checkReturn = 1 then buildStr = buildStr + "+"if checkReturn = 2 then buildStr = buildStr + "#"if checkReturn = 3 then buildStr = buildStr + "-"StdMove = buildStrxelseStdMove = AlgebMoveend ifend fn = StdMovelocal FN std2algebraic(StdMoveIn as str255, inBoard as ^boardRecord) as str255dim as boardRecord theBoarddim as str255 pieceType, AlgebMovedim as str255 fromStr, toStr, StdMovedim as long x1, y1dim as long strLengthdim as long numMoves, querySquaredim as moveRecord moves(_maxMoves)dim as str255 disAmbig, Algeb1, Algeb2// FEN: r2q1rk1/pp2ppbp/1np2np1/2Q3B1/3PP1b1/2N2N2/PP3PPP/3RKB1R w -AlgebMove = "" : StdMove = StdMoveInFN copyBoard(inBoard, theBoard)// trap castling movesif (StdMove="O-O") and (theBoard.who2move == 1) then AlgebMove="e1g1" : exit fnif (StdMove="O-O") and (theBoard.who2move == -1) then AlgebMove="e8g8" : exit fnif (StdMove="O-O-O") and (theBoard.who2move == 1) then AlgebMove="e1c1" : exit fnif (StdMove="O-O-O") and (theBoard.who2move == -1) then AlgebMove="e8c8" : exit fn// remove check suffixesstrLength = len(StdMove)while ( right$(StdMove, 1) = "+" ) or ( right$(StdMove, 1) = "#" )strLength --StdMove = left$(StdMove, strLength)wend// remove pawn promotion suffixif mid$(StdMove, len(StdMove)-1, 1) = "=" then StdMove = left$(StdMove, len(StdMove)-2)// strip it all down to find out the toStringfromStr = "" : toStr = right$(StdMove, 2)// it is a simple pawn movelong if len(StdMove)=2pieceType = "P"// algebraic string coming in > square[0-63] going out. x1 = fn colVal(mid$(toStr,1,1))y1 = val(mid$(toStr,2,1))if x1 < 1 or x1 > 8 then AlgebMove = "" : exit fnif y1 < 1 or y1 > 8 then AlgebMove = "" : exit fnblockZero( moves(0), sizeof( moveRecord ) )numMoves = 0 : querySquare = (x1-1) + (y1-1)*8numMoves = fn isTarget(querySquare, theBoard, moves(0), pieceType )if (numMoves = 1) then AlgebMove = FN move2Algebraic( moves(0) ) : exit fnend if// disambiguate pawn moves, and send them on into the regular parser// this should take in moves like: axb5, dxc4 --to be like this--> Paxb5, Pdxc4if (asc(mid$(StdMove, 1, 1)) > 96) and (asc(mid$(StdMove, 1, 1)) < 105) and (mid$(StdMove, 2, 1) = "x") then StdMove = "P" + StdMove// All Moves (expect simple pawn moves)long if ( len(StdMove) > 2 ) pieceType = mid$(StdMove, 1, 1)// algebraic toString coming in > querySquare[0-63] going out. x1 = fn colVal(mid$(toStr,1,1))y1 = val(mid$(toStr,2,1))if x1 < 1 or x1 > 8 then AlgebMove = "" : exit fnif y1 < 1 or y1 > 8 then AlgebMove = "" : exit fnblockZero( moves(0), sizeof( moveRecord ) )numMoves = 0 : querySquare = (x1-1) + (y1-1)*8numMoves = fn isTarget(querySquare, theBoard, moves(0), pieceType )if (numMoves = 1) then AlgebMove = FN move2Algebraic( moves(0) ) : exit fn// disambiguate here, before getting move2Algebraic()long if (numMoves = 2)// relies on the fact that it will be there if there is > 1 move!!disAmbig = mid$(StdMove, 2, 1)Algeb1 = FN move2Algebraic( moves(0) )Algeb2 = FN move2Algebraic( moves(1) )// disAmbig character is a FILE [a..h]long if (asc(disAmbig) > 96) and (asc(disAmbig) < 105) if disAmbig = mid$(Algeb1, 1, 1) then AlgebMove = Algeb1if disAmbig = mid$(Algeb2, 1, 1) then AlgebMove = Algeb2exit fnend if// disAmbig character is a RANK [1..8]long if (asc(disAmbig) > 48) and (asc(disAmbig) < 57) if disAmbig = mid$(Algeb1, 2, 1) then AlgebMove = Algeb1if disAmbig = mid$(Algeb2, 2, 1) then AlgebMove = Algeb2exit fnend ifend ifend if// now that we know the FROM square, we can figure out if it is castling!end fn = AlgebMove// TRIM > removes leading and trailing spaces (brendan ferguson)local fn trim (trimStr as str255) as str255dim as long strLengthstrLength = len(trimStr)// remove leading spaceswhile left$(trimStr, 1) = " "strLength --trimStr = right$(trimStr, strLength)wend// remove trailing spaceswhile right$(trimStr, 1) = " "strLength --trimStr = left$(trimStr, strLength)wendend fn = trimStrlocal fn numElements(a as str255)dim as long z, numSpaces// remove preceeding and trailing spacesa = fn trim(a)long if (len(a) => 1 )numSpaces = 1for z=1 to len(a)if mid$(a,z,1) = " " then numSpaces++next zxelsenumSpaces = 0end ifend fn = numSpaces// FN getWords() ASSUMES there is exactly ONE SPACE between words!!local fn getWords( a as str255, words(_maxWords) as str255 )dim as long numWords, z, mark1, mark2mark1 = 1 : mark2 = 1numWords = 0for z=0 to _maxWordswords(z)=""next z// strip leading and trailing spacesa = fn trim(a)for z = 1 to len(a)long if mid$(a,z,1)=" " or z=len(a)long if z=len(a)mark2 = zwords(numWords) = mid$(a, mark1, mark2-mark1+1)numWords++mark1 = mark2+1xelsemark2 = zwords(numWords) = mid$(a, mark1, mark2-mark1)numWords++mark1 = mark2+1end ifend ifnext zend fn = numWordslocal fn notDot( a as str255 ) as booleandim as boolean notAdotdim as long nnotAdot = _truefor n = 0 to len(a)if mid$(a, n, 1) = "." then notAdot = _false : exit fnnext nend fn = notAdotlocal FN toFEN as str255dim as str255 fen, bf, a, kqdim as long x, y, z, repdim as long n, thePiecedim as boardRecord fenBoarddim as str255 wRookAside, wRookHside, bRookAside, bRookHsidefen="" : bf="" : kq="" : n=0// the user may expect to see a FEN of the currently displayed boardlong if (gMoveCount = gDispCount)fn copyBoard(gBoard, fenBoard)xelsefn copyBoard( gameBoards(gDispCount), fenBoard )end if// generate the Raw FENfor y = 8 to 1 step -1for x = 1 to 8n = (y*8 - (9-x))thePiece = fenBoard.square[n]if thePiece = 0 then bf = bf + "-"if thePiece = 1 then bf = bf + "P"if thePiece = 2 then bf = bf + "B"if thePiece = 3 then bf = bf + "N"if thePiece = 4 then bf = bf + "R"if thePiece = 5 then bf = bf + "Q"if thePiece = 6 then bf = bf + "K"if thePiece = -1 then bf = bf + "p"if thePiece = -2 then bf = bf + "b"if thePiece = -3 then bf = bf + "n"if thePiece = -4 then bf = bf + "r"if thePiece = -5 then bf = bf + "q"if thePiece = -6 then bf = bf + "k"next xif y>1 then bf = bf + "/"next y// compact the raw FEN to regular FENz=0 : rep=0while z < len(bf)rep = 0inc(z)a = mid$(bf, z, 1)long if a = "-" rep = 0 while mid$(bf, z + rep, 1) = "-"  inc(rep) wend z = z + (rep-1)xelse fen = fen + aend ifif (rep > 0) then fen = fen + right$(str$(rep), len(str$(rep))-1 )wend// set COLOUR TO MOVElong if fenBoard.who2move = 1fen = fen + " w"xelsefen = fen + " b"end if// set CASTLING options// classic castling optionslong if (fenBoard.fischer == _false)if fenBoard.wCastleKside = _true then kq = kq + "K"if fenBoard.wCastleQside = _true then kq = kq + "Q"if fenBoard.bCastleKside = _true then kq = kq + "k"if fenBoard.bCastleQside = _true then kq = kq + "q"if kq="" then kq="-"fen = fen + " " + kqend if// fischer castling optionslong if (fenBoard.fischer == _true)wRookAside = "" : wRookHside = "" : bRookAside = "" : bRookHside = ""// set the column identifiers against which we match castling-flags if (fenBoard.rookSq1 <> _noSuchSquare) then wRookAside = chr$(65+fenBoard.rookSq1)if (fenBoard.rookSq2 <> _noSuchSquare) then wRookHside = chr$(65+fenBoard.rookSq2)if (fenBoard.rookSq1 <> _noSuchSquare) then bRookAside = chr$(97+fenBoard.rookSq1)if (fenBoard.rookSq2 <> _noSuchSquare) then bRookHside = chr$(97+fenBoard.rookSq2)// set the actual FEN flagsif fenBoard.wCastleQside = _true then kq = kq + wRookAsideif fenBoard.wCastleKside = _true then kq = kq + wRookHsideif fenBoard.bCastleQside = _true then kq = kq + bRookAsideif fenBoard.bCastleKside = _true then kq = kq + bRookHsideif kq="" then kq="-"fen = fen + " " + kqend if// set enPassant squareif fenBoard.enPassantSq = _noSuchSquare then fen = fen + " -"if fenBoard.enPassantSq = 24 then fen = fen + " a3"if fenBoard.enPassantSq = 25 then fen = fen + " b3"if fenBoard.enPassantSq = 26 then fen = fen + " c3"if fenBoard.enPassantSq = 27 then fen = fen + " d3"if fenBoard.enPassantSq = 28 then fen = fen + " e3"if fenBoard.enPassantSq = 29 then fen = fen + " f3"if fenBoard.enPassantSq = 30 then fen = fen + " g3"if fenBoard.enPassantSq = 31 then fen = fen + " h3"if fenBoard.enPassantSq = 32 then fen = fen + " a6"if fenBoard.enPassantSq = 33 then fen = fen + " b6"if fenBoard.enPassantSq = 34 then fen = fen + " c6"if fenBoard.enPassantSq = 35 then fen = fen + " d6"if fenBoard.enPassantSq = 36 then fen = fen + " e6"if fenBoard.enPassantSq = 37 then fen = fen + " f6"if fenBoard.enPassantSq = 38 then fen = fen + " g6"if fenBoard.enPassantSq = 39 then fen = fen + " h6"end fn = fenlocal fn fromFEN(fen as str255)dim board as boardRecorddim as str255 a, bf, kq, colour2movedim as long x, y, zdim as long n// Fischer FEN Detection Variablesdim as long wKingSq, bKingSqdim as long wRookCounter, bRookCounterdim as long wRook(64), bRook(64)      // there should NEVER be >64 rooks!dim as long numWordsdim as str255 bEnd, words(_maxWords)// Initialize Game StatescomputerTime = "00:00:00"userTime = "00:00:00"userStart = time$gPromotion = _falsegMoveCount = 0gDispCount = gMoveCountgameChain = ""// Fischer FEN detection variables :: initializebKingSq = _noSuchSquare : wKingSq = _noSuchSquarewRook(0) = _noSuchSquare : wRook(1) = _noSuchSquarebRook(0) = _noSuchSquare : bRook(1) = _noSuchSquarewRookCounter = 0 : bRookCounter = 0// disable opening bookgUseBook=_false : menu 3,18,1// stuff to record the game history in gameBoards()blockZero( gameBoards(0), sizeof(boardRecord) )// zero out move historyblockZero( gMoveList(0), sizeof(moveRecord) )// clear out first movegMoveList.fromSquare(0) = _noSuchSquaregMoveList.toSquare(0) = _noSuchSquaregMoveList.capturePiece(0) = 0gMoveList.promoPiece(0) = 0gMoveList.moveScore(0) = 0blockZero( board, sizeof( boardRecord ) )board.who2move = _whiteeboard.halfMoves = 0board.enPassantSq = _noSuchSquareboard.fiftyCount = 0board.hashCode = 0board.fischer = _trueboard.rookSq1 = _noSuchSquareboard.rookSq2 = _noSuchSquareboard.wCastleKside = _false     //cant castle unless FEN allows itboard.wCastleQside = _falseboard.wHasCastled  = _trueboard.bCastleKside = _falseboard.bCastleQside = _falseboard.bHasCastled  = _truea="" : bf="" : colour2move=""// break down the FEN into word elementsnumWords = fn getWords( fen, words(0) )// and expand the FEN$ into raw FENfor z = 1 to len( words(0) )a = mid$(fen, z, 1)long if val(a) > 0bf = bf + string$(val(a),"-")xelsebf = bf + aend ifnext z// maintaining the end part in original formbEnd = right$( fen, len(fen) - 72 )bf = bf + " " + bEnd// then drop the raw FEN into the boardRecordz = 1for y = 8 to 1 step -1for x = 1 to 8a = mid$(bf, z, 1)n = (y*8 - (9-x))if a="-" then board.square[n] = 0if a="P" then board.square[n] = 1if a="B" then board.square[n] = 2if a="N" then board.square[n] = 3if a="R" then board.square[n] = 4 : wRook(wRookCounter) = n : wRookCounter++if a="Q" then board.square[n] = 5if a="K" then board.square[n] = 6 : wKingSq = nif a="p" then board.square[n] = -1if a="b" then board.square[n] = -2if a="n" then board.square[n] = -3if a="r" then board.square[n] = -4 : bRook(bRookCounter) = n : bRookCounter++if a="q" then board.square[n] = -5if a="k" then board.square[n] = -6 : bKingSq = nz++next xz++next y// use info garnered above to setup for FISCHER FEN decodingif (wRookCounter > 0) and (wRook(0) < wKingSq) then board.rookSq1 = wRook(0) else board.rookSq2 = wRook(0)if (wRookCounter > 1) and (wRook(wRookCounter-1) > wKingSq) then board.rookSq2 = wRook(wRookCounter-1) else board.rookSq1 = wRook(wRookCounter-1)if (bRookCounter > 0) and (bRook(0) < bKingSq) then board.rookSq1 = bRook(0) - 56 else board.rookSq2 = bRook(0) - 56if (bRookCounter > 1) and (bRook(bRookCounter-1) > bKingSq) then board.rookSq2 = bRook(bRookCounter-1) - 56 else board.rookSq1 = bRook(bRookCounter-1) - 56// set colour to movelong if ( numWords => 1 )colour2move = words(1)if colour2move = "w" or colour2move = "W" then board.who2move = 1 : gFlip = _falseif colour2move = "b" or colour2move = "b" then board.who2move = -1 : gFlip = _trueend if// set castling optionslong if ( numWords => 2 )kq = words(2)long if (kq = "-")board.wCastleKside = _falseboard.wCastleQside = _falseboard.bCastleKside = _falseboard.bCastleQside = _falseboard.wHasCastled = _trueboard.bHasCastled = _trueend if// classic castling assignmentsfor z = 1 to len(kq)if mid$(kq, z, 1) = "K" then board.wCastleKside = _true : board.wHasCastled = _falseif mid$(kq, z, 1) = "Q" then board.wCastleQside = _true : board.wHasCastled = _falseif mid$(kq, z, 1) = "k" then board.bCastleKside = _true : board.bHasCastled = _falseif mid$(kq, z, 1) = "q" then board.bCastleQside = _true : board.bHasCastled = _falsenext z// fischer castling assignments// rook squares relative to king determined from above FEN// FEN: bqnbrnkr/pppppppp/8/8/8/8/PPPPPPPP/BQNBRNKR w Eh -dim as str255 wRookAside, wRookHside, bRookAside, bRookHsidewRookAside = "" : wRookHside = "" : bRookAside = "" : bRookHside = ""// set the column identifiers against which we match castling-status bits. if (board.rookSq1 <> _noSuchSquare) then wRookAside = chr$(65+board.rookSq1)if (board.rookSq2 <> _noSuchSquare) then wRookHside = chr$(65+board.rookSq2)if (board.rookSq1 <> _noSuchSquare) then bRookAside = chr$(97+board.rookSq1)if (board.rookSq2 <> _noSuchSquare) then bRookHside = chr$(97+board.rookSq2)for z = 1 to len(kq)if mid$(kq, z, 1) = wRookAside then board.wCastleQside = _true : board.wHasCastled = _falseif mid$(kq, z, 1) = wRookHside then board.wCastleKside = _true : board.wHasCastled = _falseif mid$(kq, z, 1) = bRookAside then board.bCastleQside = _true : board.bHasCastled = _falseif mid$(kq, z, 1) = bRookHside then board.bCastleKside = _true : board.bHasCastled = _falsenext zend if// decode enPassant square// For example, Pawn at c4 should have 2 possible moves: // 8/7p/p5pb/4k3/P1pPn3/8/P5PP/1rB2RK1 b - d3long if ( numWords => 3 )if words(3) = "-" then board.enPassantSq = _noSuchSquare : exit ifif words(3) = "a3" then board.enPassantSq = 24 : exit ifif words(3) = "b3" then board.enPassantSq = 25 : exit ifif words(3) = "c3" then board.enPassantSq = 26 : exit ifif words(3) = "d3" then board.enPassantSq = 27 : exit ifif words(3) = "e3" then board.enPassantSq = 28 : exit ifif words(3) = "f3" then board.enPassantSq = 29 : exit ifif words(3) = "g3" then board.enPassantSq = 30 : exit ifif words(3) = "h3" then board.enPassantSq = 31 : exit ifif words(3) = "a6" then board.enPassantSq = 32 : exit ifif words(3) = "b6" then board.enPassantSq = 33 : exit ifif words(3) = "c6" then board.enPassantSq = 34 : exit ifif words(3) = "d6" then board.enPassantSq = 35 : exit ifif words(3) = "e6" then board.enPassantSq = 36 : exit ifif words(3) = "f6" then board.enPassantSq = 37 : exit ifif words(3) = "g6" then board.enPassantSq = 38 : exit ifif words(3) = "h6" then board.enPassantSq = 39 : exit ifend if// assign result to the gBoardfn copyBoard(board, gBoard)// make initial entry into history and displaygMoveCount = 0 : gDispCount = 0gameBoards(gMoveCount) = gBoard// remember to set the gameFEN if there was onegGame.gameFEN = fengGame.variant = "[Variant " + chr$(34) + "fischerandom" + chr$(34) + "]"// this has not yet been savedgDirtyFlag = _true// display the new boardfn displayBoard(gameBoards(gDispCount))fn clearScreenuserStart = time$edit$(9)=""end fn'~'2//local FN openFile( finderOpen as boolean ) as OSStatuslocal FN openFile( finderOpen as boolean )dim as str255 fileNamedim as FSRef parentFolderRefdim as OSStatus errdim as long n, z, numLineWordsdim as long x1, y1, x2, y2dim as str255 a, b, moveStrdim as str255 loadedMoves(_maxGameMoves)dim as str255 words(_maxGameMoves)dim as moveRecord theMovedim as boolean fischerFlagdim as str255 fischerFENdim as moveRecord moves(3)// exclusive to finderOpendim as FSSpec specdim as short count, index, actiondim as OSType typeerr = _NoErrfischerFlag = _falsefischerFEN = ""FN resetPGN// get the the file with FILE > OPENif (finderOpen==_false) then fileName = Files$( _FSRefOpen,, "pGame.pgn", parentFolderRef )//fn FD_PathGetFSRef( fn CFSTR( "pChess Game.txt" ), @appRef, @ref )// get the file Drag and Dropped onto the app iconlong if ( finderOpen )count = 0action = FinderInfo( count, spec, type )select ( action )case _finderInfoOpenfor index = 1 to countFinderInfo( index, spec, type )fileName = spec.name//fn doSomethingWithFile( spec )//print index, spec.name, mki$(type)next indexcase _finderInfoPrint// ...end select//ClearFinderInfo()end iflong if (fileName)if (finderOpen==_false) then open "R", 1, @parentFolderRefif (finderOpen) then open "R", 1, @spec//--| read in a .PGN file |-----n=0 : b=""while ( eof(1) == 0 )line input #1, a// load PGN Infolong if (left$(a,1)="[")if (left$(a,6) = "[Event") then gGame.tourn = mid$(a, 9, (len(a)-10) )if (left$(a,5) = "[Site") then gGame.site = mid$(a, 8, (len(a)-9) )if (left$(a,5) = "[Date") then gGame.date = mid$(a, 8, (len(a)-9) )if (left$(a,6) = "[Round") then gGame.round = mid$(a, 9, (len(a)-10) )if (left$(a,6) = "[White") then gGame.white = mid$(a, 9, (len(a)-10) )if (left$(a,6) = "[Black") then gGame.black = mid$(a, 9, (len(a)-10) )if (left$(a,7) = "[Result") then gGame.result = mid$(a, 10, (len(a)-11) )if (left$(a,8) = "[Variant") then gGame.variant = mid$(a, 11, (len(a)-12) )long if (left$(a,5) = "[FEN ")fischerFlag = _truefischerFEN = mid$( a, 7, len(a)-8 )gGame.gameFEN = fischerFENend ifend if// title the game widowwindow #1, gGame.white + " vs " + gGame.black + " (" + gGame.result + ")"// legacy fischer support (pChess 0.9.4 - 1.9.2)long if (left$(a,8) = "// FEN: ") fischerFlag = _truefischerFEN = right$( a, len(a)-8 )gGame.gameFEN = fischerFENend if// load the moveslong if (a<>"") and (left$(a,2) <> "//") and (left$(a,1)<>"[")numLineWords = fn getWords( a, words(0) )for z = 0 to (numLineWords-1)// screen out move numbers with notDot()long if (fn notDot(words(z)))loadedMoves(n) = words(z)n++end ifnext zend ifwendclose #1XELSEexit fn     // User Cancelledend if// log the loaded moves#if _LogCommandsReceivedfor z = 0 to nprint #99, "> "; z, loadedMoves(z)next z#endif//-----(end of .pea read)-----// PLAY THE LOADED GAME into the gameBoards()// initialize the boardlong if (fischerFlag=_true)fn fromFEN( fischerFEN )xelsefn initBoard_classic(gBoard)end if// cycle through all the loaded moves, // and make the moves into the gameBoards()for z = 0 to nmoveStr = fn std2algebraic( loadedMoves(z), gBoard )// algebraic string coming in > [0-63] going out. x1 = fn colVal(mid$(moveStr,1,1))y1 = val(mid$(moveStr,2,1))x2 = fn colVal(mid$(moveStr,3,1))y2 = val(mid$(moveStr,4,1))if x1 < 1 or x1 > 8 then moveStr="" : beep : exit nextif y1 < 1 or y1 > 8 then moveStr="" : beep : exit nextif x2 < 1 or x2 > 8 then moveStr="" : beep : exit nextif y2 < 1 or y2 > 8 then moveStr="" : beep : exit next// Move TO MAKEtheMove.fromSquare = (x1-1) + (y1-1)*8theMove.toSquare = (x2-1) + (y2-1)*8theMove.capturePiece = gBoard.square[theMove.toSquare]theMove.moveScore = 0FN makeMove(gBoard, theMove)// first: record the Move into the gMoveListgMoveList(gBoard.halfMoves) = theMove// second: record the Move into the gameBoardsgMoveCount++ : gDispCount = gMoveCountgameBoards(gMoveCount) = gBoard// third: record the Move into gameChain (to compare against opening book)long if gameChain = "" gameChain = moveStrxelsegameChain = gameChain + " " + moveStrend ifnext z// remember to set the gameFEN if there was onelong if (fischerFEN <> "")  gGame.gameFEN = fischerFEN gGame.variant = "[Variant " + chr$(34) + "fischerandom" + chr$(34) + "]"end if// DISPLAY GAME (starting at zero)// set us up at the start of the game // and show us the board & history //gDispCount = 0fn speak("Game Loaded. " + str$(gMoveCount) + " Plies" , 0)edit$(8) = "Move: " + str$(gDispCount) + " of" + str$(gMoveCount)edit$(8) = edit$(8) + chr$(13) + "Game Loaded"edit$(9) = ""fn clearScreenfn displayBoard(gameBoards(gDispCount))// display the overlay of the last movemoves(0) = gMoveList(gDispCount)fn displayOverlay(gameBoards(gDispCount), moves(0), 1, _false )fn gameHistorygDirtyFlag = _false     //this has been saved//end FN = errend FNlocal FN saveFile as OSStatusdim as OSStatus errdim as FSRef parentFolderRefdim as str255 fileNamedim as str255 a, whiteName, blackNamedim as long n, mvNumdim as str255 moveDisp1, moveDisp2dim as long z, breakPosdim as long checkFlagdim as boolean vsFlagdim as str255 resultStra="" : mvNum = 0err = _Noerr// figure out who is white, and who is black// edit$(9) = "Koruga vs Rosamund" is the form. a = edit$(9) : breakPos = 0 : vsFlag = _falsewhiteName = "" : blackName = ""for z = 0 to (len(a)-1)if mid$(a, z, 2) = "vs" then vsFlag = _true : breakPos = z : exit nextnext z// user entered nothingif (a="") then whiteName = "White" : blackName = "Black"// magoolong if (a<>"") and (vsFlag == _false)whiteName = ablackName = "pChess"end if// vs magoolong if (a<>"") and (breakPos = 0) and (vsFlag == _true)whiteName = "pChess"blackName = right$(a, len(a)-3 )end if// foo vs magoolong if (a<>"") and (breakPos > 1) and (vsFlag == _true)whiteName = left$(a, breakPos-2)blackName = right$(a, len(a)-(breakPos+2) )end if// PGN defaultsif gGame.tourn = "" then gGame.tourn = "?"if gGame.site = "" then gGame.site = "?"if gGame.date = "" then gGame.date = date$("yyyy.MM.d")if gGame.round = "" then gGame.round = "?"if (_fileDate == _true) and (whiteName = "pChess") then whiteName = "pChess " + _version$if (_fileDate == _true) and (blackName = "pChess") then blackName = "pChess " + _version$long if (gGame.white = "") and (gGame.black = "")gGame.white = whiteNamegGame.black = blackNameend if// if user entered something, then use it. long if (len(a)>0)gGame.white = whiteNamegGame.black = blackNameend if// RESULT (1=check; 2=mate; 3=stale)resultStr = "*" : gGame.result = resultStrcheckFlag = fn checkTest(gBoard)if (checkFlag = 2) and (gBoard.who2move = 1) then gGame.result = "0-1"if (checkFlag = 2) and (gBoard.who2move = -1) then gGame.result = "1-0"if (checkFlag = 3) then gGame.result = "1/2-1/2"// write the file in .PGN format. // with one move per line (easier to read)// supports arbitrary FEN startpos stringsif (_fileDate == _true) then fileName = Files$(_FSRefSave,,"pGame " + gGame.white + " vs " + gGame.black + " (" + gGame.date + ").pgn", parentFolderRef)if (_fileDate == _false) then fileName = Files$(_FSRefSave,,"pGame " + gGame.white + " vs " + gGame.black + ".pgn", parentFolderRef)long if (fileName)open "O",1,fileName,@parentFolderRef// PGN Headersprint #1 "[Event " + chr$(34) + gGame.tourn + chr$(34) + "]"print #1 "[Site " + chr$(34) + gGame.site + chr$(34) + "]"print #1 "[Date " + chr$(34) + gGame.date + chr$(34) + "]"print #1 "[Round " + chr$(34) + gGame.round + chr$(34) + "]"print #1 "[White " + chr$(34) + gGame.white + chr$(34) + "]"print #1 "[Black " + chr$(34) + gGame.black + chr$(34) + "]"print #1 "[Result " + chr$(34) + gGame.result + chr$(34) + "]"// FISCHER supportlong if gGame.gameFEN<>""print #1, "[Variant " + chr$(34) + "fischerandom" + chr$(34) + "]"print #1, "[FEN " + chr$(34) + gGame.gameFEN + chr$(34) + "]"end if// spacerprint #1, ""// LIST THE MOVESlong if (gBoard.halfMoves mod 2) = 1//whites are oddfor n = 1 to (gBoard.halfMoves -1) step 2mvNum = (int((n+1)/2))//print #1, right$(str$(mvNum), len(str$(mvNum))-1 ); ". "; gMoveList(n); "  "; gMoveList(n+1)moveDisp1 = fn move2Std( gMoveList(n), gameBoards(n-1) )moveDisp2 = fn move2Std( gMoveList(n+1), gameBoards(n+0) )print #1, right$(str$(mvNum), len(str$(mvNum))-1 ); ". "; moveDisp1; " "; moveDisp2next nmoveDisp1 = fn move2Std( gMoveList(n), gameBoards(n-1) )print  #1,right$(str$(mvNum+1), len(str$(mvNum+1))-1 ); ". "; moveDisp1xelse//blacks are evenfor n = 1 to gBoard.halfMoves step 2mvNum = (int((n+1)/2))moveDisp1 = fn move2Std( gMoveList(n), gameBoards(n-1) )moveDisp2 = fn move2Std( gMoveList(n+1), gameBoards(n+0) )print #1, right$(str$(mvNum), len(str$(mvNum))-1 ); ". "; moveDisp1; " "; moveDisp2next nend ifprint #1, gGame.resultclose #1// title the game widowwindow #1, gGame.white + " vs " + gGame.black + " (" + gGame.result + ")"edit$(9) = ""fn speak("game saved", 0)gDirtyFlag = _falseXELSE// User CancelledEnd ifend FN = errlocal FN quitPea// save preferences on quitwindow #1fn CFPrefsSetLong( "winX", window(_kFBcontentLeft) )fn CFPrefsSetLong( "winY", window(_kFBcontentTop) )fn CFPrefsSetLong( "Debug", gDebug )fn CFPrefsSetLong( "Flip", gFlip )fn CFPrefsSetLong( "Audio Brain", audioBrain )fn CFPrefsSetLong( "Visual Brain", visualBrain )fn CFPrefsSetLong( "Hyperview", hyperView )fn CFPrefsSetLong( "Speech", gSpeech )fn CFPrefsSetLong( "Book", gUseBook )fn CFPrefsSetLong( "Depth", gDepth )fn CFPrefsAppSynchronize#if _logCommandsReceivedprint #99, "Preferences Saved"close #99#endifFN speak("bye", 1)#if _devLogfn e_xit( 0 ) // qdev version > quit at once!!#endifEND     // regular version of QUITend FN'~'2local FN computerMove(useBookOpenings as boolean) as str255    // COMPUTER MAKES A MOVEdim as str255 moveStr, moveStrAlgebdim as str255 startTime, endTime, elapsedTime//these are redeclared locally in computerSearch()dim as moveRecord theMovedim as str255 dispMovedim as moveRecord moves(_maxMoves)dim as long numMoves, checkFlag// TIMER Stufffn ClearAbortSearchfn SetupPollTime( 50, _false )// set up 50ms trap for ESC in Search()fn SetupPollTime2( gMaxEvalTime, _false ) // time limit set// to play soundfiledim as OSStatus err     //needed for sound filemoveStr="" : checkFlag = 0gMovesMade = 0 : gNodes = 0 : gqNodes = 0// CHECK THE OPENING BOOK long if ( gUseBook )moveStr = FN pickBook(gameChain)     // gBookTitle gets set hereif moveStr <> "" then FN parseMove( "." + moveStr ) : exit fnend if// GENERATE A MOVE WITH NEGAMAXlong if moveStr=""// is the Game Over? (return no move if it is)checkFlag = 0 : checkFlag = fn checkTest(gBoard)if checkFlag = 2 then exit fnif checkFlag = 3 then exit fnedit$(8) = "NegaMax evaluating (depth" + str$(gDepth) + ").."startTime = time$BUTTON #1, 0// castling moves require accurate check testing before generating movesgInCheck = _falseif (fn isSideToMoveInCheck( gBoard ) == _true) then gInCheck = _true// call NEGAMAX!!  :-)theMove = fn computerSearch( gBoard, gDepth )if (theMove.fromSquare = _noSuchSquare) or (theMove.toSquare = _noSuchSquare) then exit fnendTime = time$elapsedTime = fn timeDelta(startTime, endTime)// audio of moveif (audioBrain) then fn audioBrainz(theMove, theMove.moveScore)// FIRST recording: generate an algebraic moveStr for the opening book..// but it is not actually involved in making the move. moveStrAlgeb = fn move2Algebraic(theMove)moveStr = fn move2Std(theMove, gBoard) gPromotion = _false : gInCheck = _false// MAKE the ACTUAL MOVE, and Display the BoardFN makeMove(gBoard, theMove)FN displayBoard(gBoard)long if (gPromotion)// play sound for promotioncall EnterMovies()err = fn playSound( "psnd Promotion.aif" )if ( err ) then stop "PlayMovieSoundFromSupportFilename error " + str$( err )gPromotion = _falseend if// Display Overlay of the move mademoves(0) = theMove : numMoves = 1fn displayOverlay(gBoard, moves(0), numMoves, _true )// SECOND recording: the Move into the gMoveList for the history//gMoveList(gBoard.halfMoves) = moveStrgMoveList(gBoard.halfMoves) = theMove// THIRD: record the Move into the gameBoardsgMoveCount++ : gDispCount = gMoveCountgameBoards(gMoveCount) = gBoard// openingBook requires our move to be added to the gameChainlong if gameChain = "" gameChain = moveStrxelsegameChain = gameChain + " " + moveStrend if// Update the Status DisplaysdispMove = fn move2Std( theMove, gameBoards(gMoveCount - 1) )FN speakMove( dispMove, gameBoards(gMoveCount - 1) )edit$(8) = "Move: " + dispMove + " (score:" + str$(theMove.moveScore) + " " + str$(theMove.capturePiece) + ") "BUTTON #1, 1// Check for Check Mate! // FN checkTest() returns: 0=noCheck, 1=Check, 2=Mate, 3=Stale. checkFlag = 0 : checkFlag = fn checkTest(gBoard)long if (checkFlag == 1)     //CHECK//fn speak("Check!",0)edit$(8) = edit$(8) + "+ Check"// play sound for checkcall EnterMovies()err = fn playSound( "psnd Check.aif" )if ( err ) then stop "PlayMovieSoundFromSupportFilename error " + str$( err )end iflong if (checkFlag == 2)     //MATE//fn speak("Check Mate - Game Over",0)edit$(8) = edit$(8) + chr$(13) + "Check Mate - Game Over "// play sound for matecall EnterMovies()err = fn playSound( "psnd Mate.aif" )if ( err ) then stop "PlayMovieSoundFromSupportFilename error " + str$( err )end iflong if (checkFlag == 3)     //STALEfn speak("Stale Mate - End of Game",0)edit$(8) = edit$(8) + " Stale Mate"end if// show auxiliary debug infocomputerTime = fn timeAdd(computerTime, elapsedTime)edit$(8) = edit$(8) + "• Time: " + elapsedTime + chr$(13)edit$(8) = edit$(8) + "Moves:" + str$(gMovesMade) + " • Nodes:" + str$(gNodes) + " • Qui:" + str$(gqNodes) + chr$(13)//if gBookTitle<>"" then edit$(8) = edit$(8) + "Opening: " + left$(gBookTitle, 40) + chr$(13)//edit$(8) = edit$(8) + "Computer Clock: " + computerTime + " • User Clock: " + userTimeedit$(8) = edit$(8) + "Hash:" + str$(gNumPositionsSavedInHashTable) + " • Search:" + str$(gNumSearchesOfHashTable)edit$(8) = edit$(8) + " • Used:" + str$(gNumHashTableMovesUsed)fn gameHistoryuserStart = time$gDirtyFlag = _true     //this has not yet been savedgBookTitle = ""gMovesMade = 0 : gNodes = 0 : gqNodes = 0     //reset so user doesnt get left oversend ifend FN = moveStrAlgeblocal FN userMove(moveStr as str255)dim as long x1, y1, x2, y2dim as long numMovesdim as moveRecord theMovedim as moveRecord moves(_maxMoves)dim as long checkFlagdim as str255 userEnd, elapsedTimedim as str255 dispMove, MoveStrStddim as long bookMatches// to play soundfiledim as OSStatus err     //needed for sound fileblockZero( theMove, sizeof( moveRecord ) )blockZero( moves(0), sizeof( moveRecord ) )// algebraic string coming in > [0-63] going out. x1 = fn colVal(mid$(moveStr,1,1))y1 = val(mid$(moveStr,2,1))x2 = fn colVal(mid$(moveStr,3,1))y2 = val(mid$(moveStr,4,1))if x1 < 1 or x1 > 8 then edit$(8)="Invalid move" : edit$(9)="" : exit fnif y1 < 1 or y1 > 8 then edit$(8)="Invalid move" : edit$(9)="" : exit fnif x2 < 1 or x2 > 8 then edit$(8)="Invalid move" : edit$(9)="" : exit fnif y2 < 1 or y2 > 8 then edit$(8)="Invalid move" : edit$(9)="" : exit fn// Move TO MAKEtheMove.fromSquare = (x1-1) + (y1-1)*8theMove.toSquare = (x2-1) + (y2-1)*8theMove.capturePiece = gBoard.square[theMove.toSquare]// used for the opening book comparisonmoveStrStd = fn move2Std(theMove, gBoard)gPromotion = _falseFN makeMove(gBoard, theMove)FN displayBoard(gBoard)// find the static eval of the user's move//theMove.moveScore = -fn staticEval( gBoard )theMove.moveScore = -fn quiescenceSearch( gBoard, -_infinity, _infinity, gDepth )if (audioBrain = 1) then fn audioBrainz(theMove, theMove.moveScore)long if (gPromotion = _true)// play sound for promotioncall EnterMovies()err = fn playSound( "psnd Promotion.aif" )if ( err ) then stop "PlayMovieSoundFromSupportFilename error " + str$( err )gPromotion = _falseend if// Display the OverlaynumMoves = 1 : moves(0) = theMovefn displayOverlay(gBoard, moves(0), numMoves, _true )// first: record the Move into the gMoveListgMoveList(gBoard.halfMoves) = theMove// second: record the Move into the gameBoardsgMoveCount++ : gDispCount = gMoveCountgameBoards(gMoveCount) = gBoard// third: record the Move into gameChain (to compare against opening book)long if gameChain = "" gameChain = moveStrStdxelsegameChain = gameChain + " " + moveStrStdend if// see if our move matched any opening books and display matchesbookMatches = fn matchBook(gameChain)// Update Status DisplaysdispMove = fn move2Std( theMove, gameBoards(gMoveCount - 1) )FN speakMove( dispMove, gameBoards(gMoveCount - 1) )edit$(8) = "Move: " + dispMove + " (score: " + str$(theMove.moveScore) + " " + str$(theMove.capturePiece) + ") "// FN checkTest = 0-noCheck, 1-Check, 2-Mate, 3-Stale. checkFlag = 0 : checkFlag = fn checkTest(gBoard)long if checkFlag = 1     //CHECK//fn speak("Check!",0)edit$(8) = edit$(8) + "+ Check "// play sound for checkcall EnterMovies()err = fn playSound( "psnd Check.aif" )if ( err ) then stop "PlayMovieSoundFromSupportFilename error " + str$( err )end iflong if checkFlag = 2     //MATE//fn speak("Check Mate - Game Over",0)edit$(8) = edit$(8) + chr$(13) + "Check Mate - Game Over"// play sound for matecall EnterMovies()err = fn playSound( "psnd Mate.aif" )if ( err ) then stop "PlayMovieSoundFromSupportFilename error " + str$( err )end iflong if checkFlag = 3     //STALEfn speak("Stale Mate - End of Game",0)edit$(8) = edit$(8) + " Stale Mate"end ifuserEnd = time$ : elapsedTime = fn timeDelta(userStart, userEnd)userTime = fn timeAdd(elapsedTime, userTime)// show auxiliary debug infocomputerTime = fn timeAdd(computerTime, elapsedTime)edit$(8) = edit$(8) + "• Time: " + elapsedTime + chr$(13)edit$(8) = edit$(8) + "Moves:" + str$(gMovesMade) + " • Nodes:" + str$(gNodes) + " • Qui:" + str$(gqNodes) + chr$(13)if gBookTitle<>"" then edit$(8) = edit$(8) + "Book: " + left$(gBookTitle, 28) + " •" + str$(bookMatches) + " matches" + chr$(13)edit$(8) = edit$(8) + "Computer Clock: " + computerTime + " • User Clock: " + userTimefn gameHistoryedit$(9)=""gDirtyFlag = _true     'this has not yet been savedgBookTitle = ""end fnlocal FN hintMove    // COMPUTER PROVIDES A HINTdim as str255 moveStrdim as str255 startTime, endTime, elapsedTimedim as long numMoves, checkFlagdim as moveRecord moves(_maxMoves)//these are redeclared locally in computerSearch()dim as boardRecord hintBoarddim as moveRecord theMovedim as str255 dispMove// TIMER Stufffn ClearAbortSearchfn SetupPollTime( 50, _false ) // set up 50ms trap for <esc> or Command-. in Search()fn SetupPollTime2( gMaxEvalTime, _false ) // time limit set// to play soundfiledim as OSStatus err     //needed for sound filemoveStr="" : checkFlag = 0gMovesMade = 0 : gNodes = 0 : gqNodes = 0// GENERATE A MOVE WITH NEGAMAX// is the Game Over? (return no move if it is)checkFlag = 0 : checkFlag = fn checkTest(gBoard)if checkFlag = 2 then exit fnif checkFlag = 3 then exit fnedit$(8) = "NegaMax evaluating (depth" + str$(gDepth) + ").."startTime = time$// call NEGAMAX!!  :-)theMove = fn computerSearch( gBoard, gDepth )if (theMove.fromSquare = _noSuchSquare) or (theMove.toSquare = _noSuchSquare) then exit fnendTime = time$elapsedTime = fn timeDelta(startTime, endTime)// audio of moveif (audioBrain = 1) then fn audioBrainz(theMove, theMove.moveScore)// FIRST recording: generate an algebraic moveStr for the opening book..// but it is not actually involved in making the move. // moveStr = fn move2Algebraic(theMove)moveStr = fn move2Std(theMove, gBoard) gPromotion = _false : gInCheck = _false//--| end of IT |--//// HINT MOVE - original board will be restored after hintFN copyBoard(gBoard, hintBoard)FN makeMove(hintBoard, theMove)FN displayBoard(hintBoard)long if (gPromotion = _true)// play sound for promotioncall EnterMovies()err = fn playSound( "psnd Promotion.aif" )if ( err ) then stop "PlayMovieSoundFromSupportFilename error " + str$( err )gPromotion = _falseend if// Display Overlay of the hint move (i.e. show the actual HINT!)moves(0) = theMove : numMoves = 1fn displayOverlay(hintBoard, moves(0), numMoves, _true )// Update the Status DisplaysdispMove = fn move2Std( theMove, gBoard )FN speakMove( dispMove, gBoard )edit$(8) = "Hint: " + dispMove + " (score: " + str$(theMove.moveScore) + " " + str$(theMove.capturePiece) + ") "// Check for Check Mate! // FN checkTest() returns: 0=noCheck, 1=Check, 2=Mate, 3=Stale. checkFlag = 0 : checkFlag = fn checkTest(hintBoard)long if (checkFlag = 1)     //CHECK//fn speak("Check!",0)edit$(8) = edit$(8) + "+ Check"// play sound for checkcall EnterMovies()err = fn playSound( "psnd Check.aif" )if ( err ) then stop "PlayMovieSoundFromSupportFilename error " + str$( err )end iflong if (checkFlag = 2)     //MATE//fn speak("Check Mate - Game Over",0)edit$(8) = edit$(8) + chr$(13) + "Check Mate - Game Over "// play sound for matecall EnterMovies()err = fn playSound( "psnd Mate.aif" )if ( err ) then stop "PlayMovieSoundFromSupportFilename error " + str$( err )end iflong if (checkFlag = 3)     //STALEfn speak("Stale Mate - End of Game",0)edit$(8) = edit$(8) + " Stale Mate"end if// show auxiliary debug infocomputerTime = fn timeAdd(computerTime, elapsedTime)edit$(8) = edit$(8) + "• Time: " + elapsedTime + chr$(13)edit$(8) = edit$(8) + "Moves:" + str$(gMovesMade) + " • Nodes:" + str$(gNodes) + " • Qui:" + str$(gqNodes) + chr$(13)edit$(8) = edit$(8) + "Hash:" + str$(gNumPositionsSavedInHashTable) + " • Search:" + str$(gNumSearchesOfHashTable)edit$(8) = edit$(8) + " • Used:" + str$(gNumHashTableMovesUsed)fn gameHistoryuserStart = time$edit$(9) = ""end FN// eval mobility: display a tree of legal moves & static scorelocal FN showLegalMovesdim as long numMovesdim as moveRecord moves(_maxMoves)dim as long n, scoredim as str255 msg// test to see if we are in check (used ONLY for kingMove generation)gInCheck = _false : gInCheck = fn isSideToMoveInCheck( gBoard )if gInCheck = _true then fn speak("in check", 1)if gInCheck = _false then fn speak("not in check", 1)// generate the movesnumMoves = 0 : blockZero( moves(0), sizeof( moveRecord ) )numMoves = fn generateLegalMoves(gBoard, moves(0) )// display the moves (after a sort)fn displayBoard(gBoard)fn sortMoves(moves(0), numMoves)fn displayOverlay(gBoard, moves(0), numMoves, _true )//score = FN staticEval(gBoard)score = -fn quiescenceSearch( gBoard, -_infinity, _infinity, gDepth )if gBoard.who2move = 1 then msg = "White " else msg = "Black "msg = msg + "Quiescence Score:" + str$(score) + ", Mobility:" + str$(numMoves)edit$(8)=msgfor n = 0 to numMoves-1 long if abs(moves.capturePiece(n)) = 6edit$(8) = edit$(8) + chr$(13) + "King at square " + str$(moves.toSquare(n)) + " is in CHECK! "end ifnext nend FN = numMoves// display a tree of legal moves for one squarelocal FN dispPieceTree(moveStr as str255)dim as long x1, y1dim as short querySquaredim as long numMoves, numLegalMovesdim as moveRecord theMovedim as moveRecord moves(_maxMoves), movesLegal(_maxMoves)dim as boardRecord testBoarddim as long n, fromPiecedim as str255 fromTypeblockZero( theMove, sizeof( moveRecord ) )blockZero( moves(0), sizeof( moveRecord ) )blockZero( movesLegal(0), sizeof( moveRecord ) )// algebraic string coming in > square[0-63] going out. x1 = fn colVal(mid$(moveStr,1,1))y1 = val(mid$(moveStr,2,1))if x1 < 1 or x1 > 8 then edit$(8)="Invalid square" : edit$(9)="" : exit fnif y1 < 1 or y1 > 8 then edit$(8)="Invalid square" : edit$(9)="" : exit fn// find content of fromSquarequerySquare = (x1-1) + (y1-1)*8fromPiece = gameBoards.square[querySquare](gDispCount)// speak move and display board without overlayfn speak(left$(moveStr, 2), 0)fn displayBoard(gameBoards(gDispCount))// generate raw moves for the piecenumMoves = 0long if fromPiece <> 0numMoves = FN pieceTree(gameBoards(gDispCount), moves(0), numMoves, querySquare )end if// test legality of generated movesnumLegalMoves = 0for n = 0 to numMoves-1fn copyBoard ( gameBoards(gDispCount), testBoard )theMove = moves(n)fn makeMove(testBoard, theMove)if ( fn IsLegalPosition( testBoard ) ) then movesLegal(numLegalMoves) = theMove : numLegalMoves++next nfn displayOverlay(gameBoards(gDispCount), movesLegal(0), numLegalMoves, _true )select case abs(fromPiece)case 1fromType = "Pawn"case 2fromType = "Bishop"case 3fromType = "Knight"case 4fromType = "Rook"case 5fromType = "Queen"case 6fromType = "King"end selectedit$(8)=fromType + " at " + moveStr + " has" + str$(numLegalMoves) + " legal move(s)."// check for check! for n = 0 to numMoveslong if abs(moves.capturePiece(n)) = 6edit$(8) = edit$(8) + "CHECK "if (numMoves = 0) then edit$(8) = edit$(8) + "MATE! "end ifnext nend fn// display whether a square is attacked// the attack specification respects the colour of board.who2movelocal FN dispCaptureTree(moveStr as str255)dim as long x1, y1dim as short querySquaredim as boolean attacked// algebraic string coming in > square[0-63] going out. x1 = fn colVal(mid$(moveStr,1,1))y1 = val(mid$(moveStr,2,1))if x1 < 1 or x1 > 8 then edit$(8)="Invalid square" : edit$(9)="" : exit fnif y1 < 1 or y1 > 8 then edit$(8)="Invalid square" : edit$(9)="" : exit fnquerySquare = (x1-1) + (y1-1)*8attacked = _false : attacked = FN isAttacked( querySquare, gameBoards(gDispCount) )fn displayBoard(gameBoards(gDispCount))fn speak(left$(moveStr, 2), 0)long if (attacked)edit$(8) = "Square " + left$(moveStr, 2) + " is Attacked."xelseedit$(8) = "Square " + left$(moveStr, 2) + " is Not Attacked."end ifend fn// display whether a square CAN BE MOVED TO from a given board position// the function respects the colour of board.who2movelocal FN dispMoveToMoves(moveStr as str255)dim as str255 pieceTypedim as long x1, y1dim as long numMoves, querySquaredim as moveRecord moves(_maxMoves)// algebraic string coming in > square[0-63] going out. x1 = fn colVal(mid$(moveStr,1,1))y1 = val(mid$(moveStr,2,1))// find: we are trusting it is one of: PRNBQK !!pieceType="" : if len(moveStr)>2 then pieceType = mid$(moveStr, 3, 1)if x1 < 1 or x1 > 8 then edit$(8)="Invalid square" : edit$(9)="" : exit fnif y1 < 1 or y1 > 8 then edit$(8)="Invalid square" : edit$(9)="" : exit fnfn speak(left$(moveStr, 2), 0)FN displayBoard( gameBoards(gDispCount) )blockZero( moves(0), sizeof( moveRecord ) )numMoves = 0 : querySquare = (x1-1) + (y1-1)*8numMoves = fn isTarget(querySquare, gameBoards(gDispCount), moves(0), pieceType )fn displayOverlay(gameBoards(gDispCount), moves(0), numMoves, _true )edit$(8)="Square " + moveStr + " has" + str$(numMoves) + " moves targeting it."end fnlocal fn hashBoard( inBoard as ^boardRecord) as str255// returns the hash value of a board as a str. dim as str255 hashStr//hashStr = str$( inBoard.hashCode )hashStr = using "********************"; inBoard.hashCodeend fn = hashStrLOCAL FN parseMove(moveStr as str255)dim as str255 fendim as long x1, y1, x2, y2dim as moveRecord editMovedim as moveRecord theMovedim as long z, testDepthdim as long editSquare, numLegaldim as long pieceType, pieceColourdim as str255 piecedim as long tmpX, tmpYdim as long perftDepthdim as str255 tmpMovedim as long fromSquare, movePiece// simply to show Overlay when debug enableddim as long numMovesdim as moveRecord moves(_maxMoves)tmpMove = ""blockZero(theMove, sizeof( moveRecord ) )blockZero(editMove, sizeof(moveRecord))//if we havent been passed a string, check the edit fieldif moveStr="" then moveStr = edit$(9)moveStr = fn trim(moveStr)//if no move provided, then generate a move. long if moveStr="" or moveStr="go"fn displayBoard(gBoard)moveStr = fn computerMove(gUseBook)exit fnend if// PARSE the incoming stringlong if left$(moveStr,3) = "fen" and len(moveStr)=3  fen = fn toFEN  fn speak("FEN Created", 0)  edit$(8)="FEN: " + fen : edit$(9)=fen  exit fnend iflong if left$(moveStr,3) = "fen" and len(moveStr)=> 26fen = right$(moveStr, (len(moveStr)-4) )fn fromFEN(fen)fn displayBoard(gBoard)fn speak("FEN Loaded", 0)edit$(8) = "FEN: " + fenedit$(9) =  ""exit fnend iflong if moveStr="new" or moveStr="classic"FN resetPGNFN initBoard_classic(gBoard)fn clearScreenfn displayBoard(gBoard)exit fnend if long if moveStr="fischer"FN resetPGNFN initBoard_fischer(gBoard)fn clearScreenfn displayBoard(gBoard)exit fnend iflong if moveStr = "flip" or moveStr = "rotate"long if gFlip = _truegFlip = _falsefn speak("Board Flipped to White", 0)fn clearScreenfn displayBoard(gameBoards(gDispCount))// display the overlaynumMoves = 1 : moves(0) = gMoveList(gDispCount)fn displayOverlay(gameBoards(gDispCount), moves(0), numMoves, _false )edit$(8)="Board Flipped to White"edit$(9)=""exit fnxelsegFlip = _truefn speak("Board Flipped to Black", 0)fn clearScreenfn displayBoard(gameBoards(gDispCount))// display the overlaynumMoves = 1 : moves(0) = gMoveList(gDispCount)fn displayOverlay(gameBoards(gDispCount), moves(0), numMoves, _false )edit$(8)="Board Flipped to Black"edit$(9)=""exit fnend ifexit fnend ifif (moveStr = "white") then edit$(9)="" : edit$(8) = "White: " + gGame.white : exit fnif (moveStr = "black") then edit$(9)="" : edit$(8) = "Black: " + gGame.black : exit fnif (moveStr = "info") then edit$(9)="" : edit$(8) = gGame.white + " vs " + gGame.black : exit fnif (moveStr = "event") then edit$(9)="" : edit$(8) = "Event: " + gGame.tourn : exit fnif (moveStr = "site") then edit$(9)="" : edit$(8) = "Site: " + gGame.site : exit fnif (moveStr = "date") then edit$(9)="" : edit$(8) = "Date: " + gGame.date : exit fnif (moveStr = "round") then edit$(9)="" : edit$(8) = "Round: " + gGame.round : exit fnlong if (left$(moveStr,5)="white") and (len(moveStr)>5)gGame.white = right$(moveStr, len(moveStr)-6 )window #1, gGame.white + " vs " + gGame.black + " (" + gGame.result + ")"edit$(9) = "" : exit fnend iflong if (left$(moveStr,5)="black") and (len(moveStr)>5)gGame.black = right$(moveStr, len(moveStr)-6 )window #1, gGame.white + " vs " + gGame.black + " (" + gGame.result + ")"edit$(9) = "" : exit fnend iflong if (left$(moveStr,5)="event") and (len(moveStr)>5)gGame.tourn = right$(moveStr, len(moveStr)-6 )edit$(8) = "Event: " + gGame.tournedit$(9) = "" : exit fnend iflong if (left$(moveStr,4)="site") and (len(moveStr)>4)gGame.site = right$(moveStr, len(moveStr)-5 )edit$(8) = "Site: " + gGame.siteedit$(9) = "" : exit fnend iflong if (left$(moveStr,4)="date") and (len(moveStr)>4)gGame.date = right$(moveStr, len(moveStr)-5 )edit$(8) = "Date: " + gGame.dateedit$(9) = "" : exit fnend iflong if (left$(moveStr,5)="round") and (len(moveStr)>5)gGame.round = right$(moveStr, len(moveStr)-6 )edit$(8) = "Round: " + gGame.roundedit$(9) = "" : exit fnend iflong if moveStr="tree" or moveStr="mobility"numLegal = FN showLegalMovesfn speak("mobility " + str$(numLegal) + " moves", 0)edit$(9)=""exit fnend if long if moveStr="moves"edit$(8) = "Game Chain: " + gameChainfn speak("move list ", 0)end iflong if moveStr = "depth"fn speak("depth currently " + str$(gDepth), 0)edit$(8) = "NegaMax Search Depth currently: " + str$(gDepth)edit$(9)=""exit fnend iflong if len(moveStr)=7 and left$(moveStr, 5) = "depth"testDepth = val(right$(moveStr,1))if testDepth < 1 or testDepth > 8 then testDepth = 5//set the global search depthmenu 4,gDepth,_enable     //disable previous menugDepth = testDepth     //change the DEPTHmenu 4,gDepth,_checked     //show it in the menufn speak("depth set to " + str$(gDepth), 0)edit$(8) = "NegaMax Search Depth set to: " + str$(gDepth)edit$(9)=""exit fnend iflong if moveStr = "book" long if gUseBook=_truefn speak("Opening Book " + str$(numBookMoves) + " openings", 0)edit$(8)="Opening Book: " + str$(numBookMoves) + " openings"xelsefn speak("Opening Book is Off", 0)edit$(8)="Opening Book is OFF"end ifedit$(9)=""exit fnend ifif moveStr="book load" then FN loadBook : exit fnlong if moveStr = "book on" gUseBook=_truemenu 3,18,_checkedfn speak("Opening Book Enabled", 0)edit$(8)="Opening Book Enabled"edit$(9)=""exit fnend iflong if moveStr = "book off" gUseBook=_falsemenu 3,18,1fn speak("Opening Book Disabled", 0)edit$(8)="Opening Book Disabled"edit$(9)=""exit fnend iflong if moveStr = "audiobrain" or moveStr = "audio brain"if audioBrain = 0 then audioBrain = 1 : menu 3,14,_checked : edit$(8)="Audio Brain Enabled" : edit$(9)="" : fn speak("audio brain enabled", 0) : exit fnif audioBrain = 1 then audioBrain = 0 : menu 3,14,_enable : edit$(8)="Audio Brain Disabled" : edit$(9)="" : fn speak("audio brain disabled", 0) : exit fnend iflong if left$(moveStr, 14) = "visualbrain on" visualBrain = _true menu 3,15,_checked fn speak("visual brain enabled", 0) edit$(8)="Visual Brain On" edit$(9)="" exit fnend iflong if left$(moveStr, 15) = "visualbrain off" visualBrain = _false menu 3,15,1 fn speak("visual brain disabled", 0) edit$(8)="Visual Brain Off" edit$(9)="" exit fnend iflong if left$(moveStr, 12) = "hyperview on" and gDepth <= 2 hyperView = _true menu 3,16,_checked fn speak("hyper view enabled", 0) edit$(8)="Hyperview On" edit$(9)="" exit fnend iflong if left$(moveStr, 13) = "hyperview off" hyperView = _false menu 3,16,1 fn speak("hyper view disabled", 0) edit$(8) = "Hyperview Off" edit$(9)="" exit fnend iflong if moveStr = "sort" long if gUseMoveSort=_truefn speak("Sort Moves currently On", 0)edit$(8)="Sort Moves currently On"xelsefn speak("Sort Moves currently Off", 0)edit$(8)="Sort Moves currently Off"end ifedit$(9)=""exit fnend iflong if left$(moveStr, 7) = "sort on" gUseMoveSort = _true fn speak("Sort Moves Enabled", 0) edit$(8)="Sort Moves Enabled" edit$(9)="" exit fnend iflong if left$(moveStr, 8) = "sort off" gUseMoveSort = _false fn speak("Sort Moves Disabled", 0) edit$(8) = "Sort Moves Disabled" edit$(9)="" exit fnend iflong if moveStr = "qui" long if gUseQuiescence=_truefn speak("Quiescence Search currently on", 0)edit$(8)="Quiescence Search currently on"xelsefn speak("Quiescence Search currently off", 0)edit$(8)="Quiescence Search currently off"end ifedit$(9)=""exit fnend iflong if left$(moveStr, 7) = "qui on" gUseQuiescence = _true fn speak("Quiescence Search enabled", 0) edit$(8)="Quiescence Search enabled" edit$(9)="" exit fnend iflong if left$(moveStr, 8) = "qui off" gUseQuiescence = _false fn speak("Quiescence Search disabled", 0) edit$(8) = "Quiescence Search disabled" edit$(9)="" exit fnend iflong if moveStr = "time" fn speak("Max Time" + str$(gMaxEvalTime/1000) + " seconds", 0)edit$(8)="Max Time:" + str$(gMaxEvalTime/1000) + " seconds"edit$(9)=""exit fnend iflong if left$(moveStr, 5) = "time "gMaxEvalTime = val(  right$( moveStr, len(moveStr)-5 )    ) * 1000fn speak("Time set to" + str$(gMaxEvalTime/1000) + " seconds", 0)edit$(8)="Time set to:" + str$(gMaxEvalTime/1000) + " seconds" edit$(9)=""exit fnend if// UNDOCUMENTED COMMANDS: win, win reset, ascii, audioBrainlong if moveStr = "win"tmpX = window(_kFBcontentLeft)tmpY = window(_kFBcontentTop)edit$(8) = "Top:" + str$(tmpY) + ", Left:" + str$(tmpX)edit$(9)=""exit fnend iflong if moveStr = "win reset"WINDOW #1, "pChess " + _version$, (_WinX, _WinY)-(_WinX + _WinSizeX, _WinY + _WinSizeY)winX = window(_kFBcontentLeft)winY = window(_kFBcontentTop)edit$(9)=""exit fnend iflong if moveStr = "ascii"if gBoardStyle = 0 then gBoardStyle = 1 : edit$(8)="ASCII Board Enabled" : edit$(9)="" : visualBrain = 0 : fn clearScreen : fn displayBoard(gBoard) : fn speak("ask key mode", 0) : exit fnif gBoardStyle = 1 then gBoardStyle = 0 : edit$(8)="ASCII Board Disabled" : edit$(9)="" : visualBrain = 0 : fn clearScreen : fn displayBoard(gBoard) : fn speak("ask key mode disabled", 0) : exit fnend if// Performance and Debugging Toolslong if (left$(moveStr, 5) = "perft")perftDepth = val( right$( moveStr, len(moveStr)-6 ) )fn runPerft (perftDepth)edit$(9)=""exit fnend iflong if (left$(moveStr, 4) = "hash")edit$(8) = "HashCode:" + fn hashBoard( gameBoards(gDispCount) )fn speak("hash code", 0)edit$(9) = ""exit fnend iflong if moveStr = "debug"long if gDebug = 1gDebug = 0 : menu 3,19,1fn speak("debug disabled", 0)window #1winX = window(_kFBcontentLeft)winY = window(_kFBcontentTop)WINDOW #1, "pChess " + _version$, (winX, winY)-(winX + 555, winY + _WinSizeY)edit$(9)=""xelsegDebug = 1 : menu 3,19,_checkedfn speak("debug enabled", 0)WINDOW #1, "pChess " + _version$, (winX, winY)-(winX + _WinSizeX, winY + _WinSizeY)fn clearScreenfn displayBoard(gameBoards(gDispCount))// display the overlaynumMoves = 1 : moves(0) = gMoveList(gDispCount)fn displayOverlay(gameBoards(gDispCount), moves(0), numMoves, _false )edit$(9)=""end ifend if// gameBOARDS HISTORY// gameBoards() holds the whole board history for PREV NEXT. long if (moveStr = "<") or (left$(moveStr, 4) = "prev")fn prevMove : exit fnend iflong if (moveStr = ">") or (left$(moveStr, 4) = "next")fn nextMove : exit fnend iflong if (left$(moveStr, 2) = "<<") or (left$(moveStr, 5) = "first")fn firstMove : exit fnend iflong if (left$(moveStr, 2) = ">>") or (left$(moveStr, 4) = "last")fn lastMove : exit fnend if// this sets the game to continue from the currently displayed boardlong if (moveStr="now")fn setNow : exit fnend if// ? n = show history at move n// ?sq = display if square is attacked/can be moved tolong if left$(moveStr, 2) = "? "gDispCount = val(right$(moveStr, len(moveStr)-1))fn speak("move " + str$(gDispCount), 0)fn displayBoard(gameBoards(gDispCount))edit$(8) = "Move: " + str$(gDispCount) : edit$(9)=""fn gameHistory// display the overlaynumMoves = 1 : moves(0) = gMoveList(gDispCount)fn displayOverlay(gameBoards(gDispCount), moves(0), numMoves, _false )exit fnend if// ? n = show history at move n// ?sq = display if square is attacked/can be moved tolong if (left$(moveStr, 1) = "?") and ( len(moveStr)=3 or len(moveStr)=4 )//FN dispCaptureTree( right$(moveStr, 2) )FN dispMoveToMoves( right$( moveStr, len(moveStr)-1 ) )exit fnend if// BOARD EDITING// EDIT: MOVE a piece (forced move)long if len(moveStr)=5 and left$(moveStr,1)=">"x1 = fn colVal(mid$(moveStr,2,1))y1 = val(mid$(moveStr,3,1))x2 = fn colVal(mid$(moveStr,4,1))y2 = val(mid$(moveStr,5,1))if x1 < 1 or x1 > 8 then edit$(8)="Invalid square" : edit$(9)="" : exit fnif y1 < 1 or y1 > 8 then edit$(8)="Invalid square" : edit$(9)="" : exit fnif x2 < 1 or x2 > 8 then edit$(8)="Invalid square" : edit$(9)="" : exit fnif y2 < 1 or y2 > 8 then edit$(8)="Invalid square" : edit$(9)="" : exit fneditMove.fromSquare = (x1-1) + (y1-1)*8editMove.toSquare = (x2-1) + (y2-1)*8editMove.moveScore = 0gBoard.square[editMove.toSquare] = gBoard.square[editMove.fromSquare]gBoard.square[editMove.fromSquare] = 0// this ensures that the move history is also updatedgameBoards(gMoveCount) = gBoardfn speak(right$(moveStr, len(moveStr)-1 ) + " moved", 0)fn displayBoard(gBoard)edit$(8)=right$(moveStr, len(moveStr)-1 ) + " moved"edit$(9)=""exit fnend if// EDIT: DELETE a piecelong if left$(moveStr,1)="-" and len(moveStr)=3x1 = fn colVal(mid$(moveStr,2,1))y1 = val(mid$(moveStr,3,1))if x1 < 1 or x1 > 8 then edit$(8)="Invalid square" : edit$(9)="" : exit fnif y1 < 1 or y1 > 8 then edit$(8)="Invalid square" : edit$(9)="" : exit fneditSquare = (x1-1) + (y1-1)*8gBoard.square[editSquare] = 0// this ensures that the move history is also updatedgameBoards(gMoveCount) = gBoardfn speak(right$(moveStr, len(moveStr)-1 ) + " removed", 0)fn displayBoard(gBoard)edit$(8)=right$(moveStr, len(moveStr)-1 ) + " removed"edit$(9)=""exit fnend if// EDIT: ADD a piece in the format: +wqe4 or +bpe5long if left$(moveStr,1)="+" and len(moveStr)=5if mid$(moveStr,2,1)="w" then pieceColour=1 else pieceColour=-1pieceType = 0 : piece = mid$(moveStr,3,1)  if piece = "p" then pieceType = 1  if piece = "b" then pieceType = 2  if piece = "n" then pieceType = 3  if piece = "r" then pieceType = 4  if piece = "q" then pieceType = 5  if piece = "k" then pieceType = 6x1 = fn colVal(mid$(moveStr,4,1))y1 = val(mid$(moveStr,5,1))if x1 < 1 or x1 > 8 then edit$(8)="Invalid square" : edit$(9)="" : exit fnif y1 < 1 or y1 > 8 then edit$(8)="Invalid square" : edit$(9)="" : exit fneditSquare = (x1-1) + (y1-1)*8gBoard.square[editSquare] = pieceType * pieceColour// this ensures that the move history is also updatedgameBoards(gMoveCount) = gBoardfn speak(right$(moveStr, len(moveStr)-3 ) + " added", 0)fn displayBoard(gBoard)edit$(8)=right$(moveStr, len(moveStr)-3 ) + " added"edit$(9)=""exit fnend ifif moveStr="cls" then fn clearScreen : fn displayBoard(gBoard) : exit fnif left$(moveStr,3)="say" then fn speak( right$(moveStr,(len(moveStr)-4)) , 0 ) : edit$(9)="" : exit fnif moveStr="who are you?" then fn speak("Rose's Pet Robot",0) : edit$(8)="Rose's Pet Robot" : edit$(9)="" : exit fnif moveStr="who are you thinking of?" then fn speak("Love Sucks",0) : edit$(8)="Kirstie" : edit$(9)="" : exit fnif moveStr="beep" then beep : exit fn//display the number of words in a stringdim as long numWordsdim as str255 words(_maxWords)long if left$(moveStr, 1)="#" and len(moveStr) > 5moveStr = right$(moveStr, len(moveStr)-1 )  'strip out the leading charnumWords = fn getWords(moveStr, words(0) )long if (gDebug == 1)edit$(8) = "numWords =" + str$(numWords)for z = 0 to numWords-1print words(z), len(words(z))next zend ifedit$(9)="" : exit fnend if//compute a time differential// for example, entering: @hh:mm:ss hh:mm:ss// displays the differnce between first and second time. dim as str255 t1, t2long if (left$(moveStr, 1)="*") and (mid$(moveStr, 2, 1) <> "*")t1 = mid$(moveStr, 3, 8)t2 = mid$(moveStr, 12, 8)edit$(8) = "Time Delta: " + fn timeDelta(t1, t2) + "  " + t1 + " " + t2edit$(9)="" : exit fnend if//compute adding two time strings// for example, entering: @@hh:mm:ss hh:mm:ss// displays the sum of the first and second timelong if (left$(moveStr, 2)="**")t1 = mid$(moveStr, 4, 8)t2 = mid$(moveStr, 13, 8)edit$(8) = "Time Sum: " + fn timeAdd(t1, t2) + "  " + t1 + " " + t2edit$(9)="" : exit fnend iflong if moveStr="version" fn speak("pChess " + _version$, 0)edit$(8)="pChess " + _version$edit$(9)=""exit fnend ifIF moveStr="quit" or moveStr="exit" then fn quitPealong if moveStr="hint"fn displayBoard(gBoard)fn hintMoveexit fnend if// translate castling move (classical only; no fischer)if (moveStr = "OO" or moveStr = "O-O" or moveStr = "oo" or moveStr = "o-o") and gBoard.who2move = 1 then moveStr = "e1g1"if (moveStr = "OO" or moveStr = "O-O" or moveStr = "oo" or moveStr = "o-o") and gBoard.who2move = -1 then moveStr = "e8g8"if (moveStr = "OOO" or moveStr = "O-O-O" or moveStr = "ooo" or moveStr = "o-o-o") and gBoard.who2move = 1 then moveStr = "e1c1"if (moveStr = "OOO" or moveStr = "O-O-O" or moveStr = "ooo" or moveStr = "o-o-o") and gBoard.who2move = -1 then moveStr = "e8c8"// SAN (Standard Notation): prefix move with ( . ) to enter moves in Standard Notation// @StdMove - FEN: r2q1rk1/pp2ppbp/1np2np1/2Q3B1/3PP1b1/2N2N2/PP3PPP/3RKB1Rlong if (left$(moveStr, 1) = ".")FN userMove( FN std2algebraic(right$(moveStr, len(moveStr)-1), gBoard ) )exit fnend if// if len=2, then simply display a pieceTree or isTargetlong if len(moveStr)=2// algebraic string coming in > [0-63] going out. x1 = fn colVal(mid$(moveStr,1,1))y1 = val(mid$(moveStr,2,1))if x1 < 1 or x1 > 8 then edit$(8)="Invalid move" : edit$(9)="" : exit fnif y1 < 1 or y1 > 8 then edit$(8)="Invalid move" : edit$(9)="" : exit fn// find content of fromSquarefromSquare = (x1-1) + (y1-1)*8movePiece = gameBoards.square[fromSquare](gDispCount)long if (movePiece * gameBoards.who2move(gDispCount) > 0)FN dispPieceTree(moveStr)xelseFN dispMoveToMoves(moveStr)end ifend if// if none of the above, then we finally arrive at parsing the input as a MOVE. if len(moveStr)=4 then FN userMove(moveStr)//clear the input field after processingedit$(9)=""END FNLOCAL FN doMenusdim as long menuID, itemIDdim as str255 fendim as long numLegal// in order to savedim as OSStatus foodim as boolean goAhead// in order to show the Overlaydim as long numMovesdim as moveRecord moves(_maxMoves)menuID=MENU(_menuID)itemID=MENU(_itemID)select case case menuID = 0select casecase itemID = 1// display ABOUT dialogue// handled automatically by including a .nibmenu : exit fnend selectcase menuID = 1     // FILE menuselect casecase itemID = 1     //new classicfn resetPGNfn initBoard_classic(gBoard)fn clearScreenfn displayBoard(gBoard)menu : exit fncase itemID = 2     //new fischerfn resetPGNfn initBoard_fischer(gBoard)fn clearScreenfn displayBoard(gBoard)menu : exit fncase itemID = 4                         ' OPEN//foo = FN openFile(_false)FN openFile(_false)case itemID = 5                         ' SAVEfoo = FN saveFilecase itemID = 7     'load bookFN loadBookfn displayBoard(gBoard)menu : exit fncase itemID = 9     'create FENfen = fn toFENedit$(8)=fen : edit$(9)=fenfn speak("FEN Created", 0)case itemID = 10     'decode FENfen = edit$(9)fn fromFEN(fen)fn displayBoard(gBoard)fn speak("FEN Loaded", 0)edit$(8) = fencase itemID = 12     'QUIT!long if (gDirtyFlag == _true)fn speak("save game before quit?", 0)goAhead = fn confirmDialogue( "Save game before Quit?", "", "Save", "Don't Save" )if (goAhead) then foo = FN saveFileend iffn quitPeaend select//---end of FILE menu---////---/ OPTIONS menu /---//case menuID = 3select case // PARSE MOVE // MAKE MOVE //case itemID = 1fn parseMove("")exit fn// HINT MOVEcase itemID = 2fn displayBoard(gBoard)fn hintMoveexit fn// Clear Screencase itemID = 4fn clearScreenlong if (gDispCount <> gMoveCount)fn displayBoard(gameBoards(gDispCount))xelsefn displayBoard(gBoard)end if// display the overlaynumMoves = 1 : moves(0) = gMoveList(gDispCount)fn displayOverlay(gameBoards(gDispCount), moves(0), numMoves, _false )exit fn// Eval Mobilitycase itemID = 5numLegal = FN showLegalMovesfn speak("mobility " + str$(numLegal) + " moves", 0)exit fn// Flip Boardcase itemID = 6long if gFlip = _truegFlip = _falsefn speak("Board Flipped to White", 0)fn clearScreenfn displayBoard(gameBoards(gDispCount))// display the overlaynumMoves = 1 : moves(0) = gMoveList(gDispCount)fn displayOverlay(gameBoards(gDispCount), moves(0), numMoves, _false )edit$(9)=""exit fnxelsegFlip = _truefn speak("Board Flipped to Black", 0)fn clearScreenfn displayBoard(gameBoards(gDispCount))// display the overlaynumMoves = 1 : moves(0) = gMoveList(gDispCount)fn displayOverlay(gameBoards(gDispCount), moves(0), numMoves, _false )edit$(9)=""exit fnend ifexit fn// SET NOWcase itemID = 8fn setNow : exit fn// FIRST | LASTcase itemID = 9fn firstMove : exit fncase itemID = 10fn lastMove : exit fn// NEXT | PREVcase itemID = 11fn prevMove : exit fncase itemID = 12fn nextMove : exit fn// Audio Braincase itemID = 14long if audioBrain = _trueaudioBrain = _falsefn speak("audio brain disabled", 0)menu 3,14,_enablemenu : exit fnxelseaudioBrain = _truefn speak("audio brain enabled", 0)menu 3,14,_checkedmenu : exit fnend if// Visual Braincase itemID = 15long if visualBrain = _truevisualBrain = _falsefn speak("visual brain disabled", 0)menu 3,15,_enablemenu : exit fnxelsevisualBrain = _truefn speak("visual brain enabled", 0)menu 3,15,_checkedmenu : exit fnend if// Hyperviewcase itemID = 16long if hyperView = _truehyperView = _falsefn speak("hyper view disabled", 0)menu 3,16,1xelsehyperView = _truefn speak("hyper view enabled", 0)menu 3,16,_checkedend if// Speechcase itemID = 17long if gSpeech = _truefn speak("speech disabled", 0)gSpeech = _falsemenu 3,17,1xelsegSpeech = _truefn speak("speech enabled", 0)menu 3,17,_checkedend if// Use Bookcase itemID = 18long if gUseBook = _truegUseBook = _falsefn speak("opening book disabled", 0)menu 3,18,1xelsegUseBook = _truefn speak("opening book enabled", 0)menu 3,18,_checkedend if// Debugcase itemID = 19long if gDebug = 1gDebug = 0fn speak("debug disabled", 0)window #1winX = window(_kFBcontentLeft)winY = window(_kFBcontentTop)WINDOW #1, "pChess " + _version$, (winX, winY)-(winX + 555, winY + _WinSizeY)menu 3,19,1xelsegDebug = 1fn speak("debug enabled", 0)WINDOW #1, "pChess " + _version$, (winX, winY)-(winX + _WinSizeX, winY + _WinSizeY)menu 3,19,_checkedfn clearScreenfn displayBoard(gameBoards(gDispCount))// display the overlaynumMoves = 1 : moves(0) = gMoveList(gDispCount)fn displayOverlay(gameBoards(gDispCount), moves(0), numMoves, _false )end ifend selectcase menuID = 4//---/ DEPTH menu /---//menu 4, gDepth, 1gDepth = itemIDfn speak("depth set to " + str$(gDepth), 0)menu 4, gDepth,_checkededit$(8) = "NegaMax Search Depth set to: " + str$(gDepth)edit$(9)=""end selectmenuend FNLOCAL FN doDialogsdim as str255 fendim as short d0, d1// in order to save on quitdim as OSStatus foodim as Boolean goAhead// simply to show the Overlaydim as long numMovesdim as moveRecord moves(_maxMoves)d0=DIALOG(0)d1=DIALOG(d0)                                   'what dialog events?SELECT d0CASE _btnClick                            'button eventIF (d1=1) THEN FN parseMove("")     'user clicked 'Move' buttonlong if (d1=2)fen = fn toFENedit$(8)=fen : edit$(9)=fenfn speak("FEN Created", 0)exit fnend iflong if (d1=3)fen = edit$(9)fn fromFEN(fen)fn displayBoard(gBoard)fn speak("FEN Loaded", 0)edit$(8) = fenexit fnend iflong if (d1 = 4) fn prevMove : exit fnend iflong if (d1 = 5)fn setNow : exit fnend iflong if (d1 = 6) fn nextMove : exit fnend ifCASE _wndRefreshfn clearScreenfn displayBoard(gameBoards(gDispCount))// display the overlaynumMoves = 1 : moves(0) = gMoveList(gDispCount)fn displayOverlay(gameBoards(gDispCount), moves(0), numMoves, _false )CASE _wndCloselong if (d1 == 1) long if (gDirtyFlag == _true)fn speak("save game before quit?", 0)goAhead = fn confirmDialogue( "Save game before Quit?", "", "Save", "Don't Save" )if (goAhead) then foo = FN saveFileend iffn quitPea     'QUIT!end iflong if (d1 == 2) //gDebug = 0//fn speak("window two closed", 0)window close #2//menu 3,19,1end ifEND SELECT// FIND: THIS DONT WORK IN FB5 -- REWRITE FOR HITOOLBOX//if d0=_efReturn and d1=9 then FN parseMove("")   'user hit enterEND FNlocal fn initializedim as long z// Initialize Game Variables// piece names & weightsgPieceName(1) = "Pawn"   : gPieceWt(1) = _pawnWtgPieceName(2) = "Bishop" : gPieceWt(2) = _bishopWtgPieceName(3) = "Knight" : gPieceWt(3) = _knightWtgPieceName(4) = "Rook"   : gPieceWt(4) = _rookWtgPieceName(5) = "Queen"  : gPieceWt(5) = _queenWtgPieceName(6) = "King"   : gPieceWt(6) = _kingWt// WHITE PAWN TROPISM// as per: Tomasz Michniewski (Progszach)// ChessWiki > Simplified Evaluation Functiondata 0,  0,  0,  0,  0,  0,  0,  0 data 5, 10, 10,-20,-20, 10, 10,  5data 5, -5,-10,  0,  0,-10, -5,  5data 0,  0,  0, 20, 20,  0,  0,  0data 5,  5, 10, 25, 25, 10,  5,  5data 10, 10, 20, 30, 30, 20, 10, 10data 50, 50, 50, 50, 50, 50, 50, 50data  0,  0,  0,  0,  0,  0,  0,  0for z = 0 to 63read gWhitePawnTropism(z)next z// BLACK PAWN TROPSIMdata  0,  0,  0,  0,  0,  0,  0,  0data 50, 50, 50, 50, 50, 50, 50, 50data 10, 10, 20, 30, 30, 20, 10, 10data  5,  5, 10, 25, 25, 10,  5,  5data  0,  0,  0, 20, 20,  0,  0,  0data  5, -5,-10,  0,  0,-10, -5,  5data  5, 10, 10,-20,-20, 10, 10,  5data  0,  0,  0,  0,  0,  0,  0,  0for z = 0 to 63read gBlackPawnTropism(z)next z// WHITE KNIGHT TROPISM// as per: Tomasz Michniewski (Progszach)// ChessWiki > Simplified Evaluation Functiondata -40,-20,  0,  5,  5,  0,-20,-40data -30,  5, 10, 15, 15, 10,  5,-30data -30,  0, 15, 20, 20, 15,  0,-30data -30,  5, 15, 20, 20, 15,  5,-30data -30,  0, 10, 15, 15, 10,  0,-30data -30,  0, 10, 15, 15, 10,  0,-30data -40,-20,  0,  0,  0,  0,-20,-40data -50,-40,-30,-30,-30,-30,-40,-50for z = 0 to 63read gWhiteKnightTropism(z)next z// BLACK KNIGHT TROPSIMdata -50,-40,-30,-30,-30,-30,-40,-50data -40,-20,  0,  0,  0,  0,-20,-40data -30,  0, 10, 15, 15, 10,  0,-30data -30,  0, 10, 15, 15, 10,  0,-30data -30,  5, 15, 20, 20, 15,  5,-30data -30,  0, 15, 20, 20, 15,  0,-30data -30,  5, 10, 15, 15, 10,  5,-30data -40,-20,  0,  5,  5,  0,-20,-40for z = 0 to 63read gBlackKnightTropism(z)next z// sq2mask() transformation deltasdata 21, 22, 23, 24, 25, 26, 27, 28data 31, 32, 33, 34, 35, 36, 37, 38data 41, 42, 43, 44, 45, 46, 47, 48data 51, 52, 53, 54, 55, 56, 57, 58data 61, 62, 63, 64, 65, 66, 67, 68data 71, 72, 73, 74, 75, 76, 77, 78data 81, 82, 83, 84, 85, 86, 87, 88data 91, 92, 93, 94, 95, 96, 97, 98for z = 0 to 63read sq2Mask(z)next z// maskBoard() valuesdata -1,-1,-1,-1,-1,-1,-1,-1,-1,-1data -1,-1,-1,-1,-1,-1,-1,-1,-1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1,-1,-1,-1,-1,-1,-1,-1,-1,-1data -1,-1,-1,-1,-1,-1,-1,-1,-1,-1for z = 0 to 119read maskBoard(z)next z// King Tropism kZone2 Vectors (first set for 8x8; second set for 10x12)data 14, 15, 16, 17, 18, 10, 2, -6, -14, -15, -16, -17, -18, -10, -2, 6data 18, 19, 20, 21, 22, 12, 2, -8, -18, -19, -20, -21, -22, -12, -2, 8for z = 0 to 15read kZone2(z)next zfor z = 0 to 15read kZone220(z)next z// King Tropism kZone3 Vectors (first set for 8x8; second set for 10x12)data 7, 8, 9, 1, -7, -8, -9, -1, 0data 9, 10, 11, 1, -9, -10, -11, -1, 0for z = 0 to 8read kZone3(z)next zfor z = 0 to 8read kZone320(z)next z// Initialize Movement Vectors and Masks// wPawn Vectors & Masksdata 7, 9, 8, 16, -1, 1data 9, 11, 10, 20, -1, 1for z = 0 to 5read wPawnVect(z)next zfor z = 0 to 5read wPawnMask(z)next z// bPawn Vectors & Masksdata -9, -7, -8, -16, 1, -1data -11, -9, -10, -20, 1, -1for z = 0 to 5read bPawnVect(z)next zfor z = 0 to 5read bPawnMask(z)next z// bishop Vectors & Masksdata 7, 9, -7, -9data 9, 11, -9, -11for z = 0 to 3read bishopVect(z)next zfor z = 0 to 3read bishopMask(z)next z// knight Vectors & Masksdata 15, 17, 10, -6, -15, -17, -10, 6data 19, 21, 12, -8, -19, -21, -12, 8for z = 0 to 7read knightVect(z)next zfor z = 0 to 7read knightMask(z)next z// rook Vectors & Masksdata 8, 1, -1, -8data 10, 1, -1, -10for z = 0 to 3read rookVect(z)next zfor z = 0 to 3read rookMask(z)next z// king Vectors & Masksdata 7, 9, -7, -9, 8, -8, 1, -1data 9, 11, -9, -11, 10, -10, 1, -1for z = 0 to 7read kingVect(z)next zfor z = 0 to 7read kingMask(z)next z// pChess Pitch Table// IN: square 0..63 | eight note scale: A, Bb, B, C, D, E, F, G// OUT: sound pitch (negative values = notes instead of frequency)data 21, 22, 23, 24, 26, 28, 29, 31data 33, 34, 35, 36, 38, 40, 41, 43data 45, 46, 47, 48, 50, 52, 53, 55data 57, 58, 59, 60, 62, 64, 65, 67data 69, 70, 71, 72, 74, 76, 77, 79data 81, 82, 83, 84, 86, 88, 89, 91data 93, 94, 95, 96, 98, 100, 101, 103data 105, 106, 107, 108, 110, 112, 113, 115for z = 0 to 63read noteTable(z)next z// HASH: initialize the hash tablesfn initHashCodesend fnLOCAL FN initialize_UIdim as rect myRectdim as OSStatus err// NIB file handler (from 'SimpleNib.bas')dim as long niblong if ( fn CreateNibReference( fn CFSTR( "main" ), @nib ) == _noErr )fn SetMenuBarFromNib( nib, fn CFSTR( "MenuBar" ) )DisposeNibReference( nib )end if// get preferences for window positionfn CFPrefsGetLong( "winX", @winX, _WinX )fn CFPrefsGetLong( "winY", @winY, _WinY )appearance window #1, "pChess " + _version$, (winX, winY)-(winX + _WinSizeX, winY + _WinSizeY)// Default Window Colour and Font  bgB_board = 55769 : bgG_board = 46260 : bgR_board = 46260  fgB_board = 0 : fgG_board = 0 : fgR_board = 0  LONG COLOR bgB_board, bgG_board, bgR_board, _false  LONG COLOR fgB_board, fgG_board, fgR_board, _true  TEXT _FontFace, _FontSize, 0 : cls// Font Embed CHEQ FONT#if _buildPPC == _falseerr = fn ActivateFontFromResourcesFile( @"Cheq Screen" ) // filenameif ( err ) then stop "ActivateFontFromResourcesFile error " + str$( err )gCheqFont = fn ATSFontFamilyFindFromQuickDrawName( "Cheq" ) // font name#endif// setup buttons & fields  BUTTON #1, 1, "Move", (585,512)-(650,532), 1  BUTTON #4, 1, "<", (660,512)-(690,532), 1  BUTTON #5, 1, "•", (700,512)-(730,532), 1  BUTTON #6, 1, ">", (740,512)-(770,532), 1  BUTTON #2, 1, ">FEN", (780,512)-(840,532), 1  BUTTON #3, 1, "<FEN", (850,512)-(910,532), 1//std out  setRect( myRect, 555, 20, 910, 87 )  edit field 8,, @myRect, _statFramed, 16//std in  setRect( myRect, 560, 475, 910, 495 )  edit field 9,, @myRect, _framedNoCR, 16// setup menus  MENU 1,0,1, "File"  menu 1,1,1, "New Classic/N"  menu 1,2,1, "New Fischer"  menu 1,3,0, "-"  menu 1,4,1, "Open.../O"  menu 1,5,1, "Save As.../S"  menu 1,6,0, "-"  menu 1,7,1, "Load Opening Book/L"  menu 1,8,0, "-"  menu 1,9,1, "Board to FEN/F"  menu 1,10,1, "FEN to Board/G"  menu 1,11,0, "-"  MENU 1,12,1, "Quit/Q"  EDIT MENU 2  menu 3,0,1, "Options"  menu 3,1,1, "Move/M"  menu 3,2,1, "Hint"  menu 3,3,0, "-"  menu 3,4,1, "Clear Screen/E"  menu 3,5,1, "Eval Mobility/T"  menu 3,6,1, "Flip Board/R"  menu 3,7,0, "-"  menu 3,8,1, "Set Now/P"  menu 3,9,1, "First Move/1"  menu 3,10,1, "Last Move/2"  menu 3,11,1, "Prev/["  menu 3,12,1, "Next/]"  menu 3,13,0, "-"  menu 3,14,0, "Audio Brain/U"  menu 3,15,1, "Visual Brain/B"  menu 3,16,1, "HyperView"  menu 3,17,1, "Speech Enabled"  menu 3,18,1, "Use Opening Book"  menu 3,19,1, "Debug Pane/D"  menu 4,0,1, "Depth"  menu 4,1,1, "Depth 1"  menu 4,2,1, "Depth 2"  menu 4,3,1, "Depth 3"  menu 4,4,1, "Depth 4"  menu 4,5,1, "Depth 5"  menu 4,6,1, "Depth 6"  menu 4,7,1, "Depth 7"  menu 4,8,1, "Depth 8"  menu 4,9,1, "Depth 9"// INITIALIZE Variable Defaults from Preferences, and Set Menus  fn CFPrefsGetLong( "Flip", @gFlip, _gFlip )  fn CFPrefsGetLong( "Audio Brain", @audioBrain, _audioBrain ) : if (audioBrain == 1) then menu 3,14,_checked else menu 3,14,_enable   fn CFPrefsGetLong( "Visual Brain", @visualBrain, _visualBrain ) : if (visualBrain == 1) then menu 3,15,_checked else menu 3,15,_enable  fn CFPrefsGetLong( "Hyperview", @hyperView, _hyperView ) : if (hyperView == 1) then menu 3,16,_checked else menu 3,16,_enable  fn CFPrefsGetLong( "Speech", @gSpeech, _Speech ) : if (gSpeech == 1) then menu 3,17,_checked else menu 3,17,_enable  fn CFPrefsGetLong( "Book", @gUseBook, _gUseBook ) : if (gUseBook == 1) then menu 3,18,_checked else menu 3,18,_enable  fn CFPrefsGetLong( "Debug", @gDebug, _debug ) : if (gDebug == 1) then menu 3,19,_checked else menu 3,19,_enable  fn CFPrefsGetLong( "Depth", @gDepth, _gDepth ) : menu 4,gDepth,_checked// default low-level preferences  gUseMoveSort = _useMoveSort  gUseQuiescence = _useQuiescence  gMaxEvalTime = _maxEvalTime  gBoardStyle = _boardStyle  gOverLines = _overLines// Debug Panefn CFPrefsGetLong( "Debug", @gDebug, _debug )long if (gDebug == 1) // get preferences for window positionfn CFPrefsGetLong( "winX", @winX, _WinX )fn CFPrefsGetLong( "winY", @winY, _WinY )window #1, "pChess " + _version$, (winX, winY)-(winX + _WinSizeX, winY + _WinSizeY)end if// Load the OPENING BOOKif (gUseBook == _true) then FN loadBook// global variables for evaluationgWtTropism = _wtTropismgCastleBonus = _castleBonusgWtKingGravity = _wtKingGravitygWtPassedPawn = _wtPassedPawngWtDoubledPawn = _wtDoubledPawngWtKingShelter = _wtKingShelter// and start the gameFN resetPGNFN initBoard_classic(gBoard)FN displayBoard(gBoard)end fn//==| MAIN |======= FN initializeFN initialize_UION MOUSE  FN mouseTrapON DIALOG FN doDialogsON MENU   FN doMenusON FinderInfo FN openFiledoHandleEventsuntil (gFBquit)#endif