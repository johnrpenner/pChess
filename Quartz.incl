/*  Util_Quartz.incl    rp 20110318  Bernie Wylde  Update 20121107 - fixed clang warnings*/include "Tlbx CoreGraphics.incl"begin record QuartzRGBAdim as single  red, green, blue, alphaend recordbegin record QuartzLineDashInfodim as single  phasedim as Handle  lengthsdim as long    countend recordbegin record QuartzLineInfodim as single              widthdim as long                capdim as QuartzLineDashInfo  dashend recordbegin record QuartzShadowInfodim as CGSize   offsetdim as single   colors[3], blurdim as Boolean  isColor, setdim &end recordbegin record QuartzTransLayerInfodim as Boolean  set, begindim &end recordbegin record QuartzInfodim as CGContextRef           ctxdim as CGPathDrawingMode      drawModedim as QuartzLineInfo         linedim as CGPoint                lastPointdim as CGPoint                ratiodim as QuartzRGBA             strokeColor, fillColordim as QuartzShadowInfo       shadowdim as QuartzTransLayerInfo   transLayerend record'~Angle conversiondef fn QuartzBradsToDegrees( brads as single ) as double = ( brads / 256 * 360 )def fn QuartzDegreesToRadians( degrees as single ) as double = ( degrees * PI / 180.0 )def fn QuartzBradsToRadians( brads as single ) as double = ( ( brads * 2 * PI ) / 256 )'~Quartz infolocal fn QuartzGetInfo( info as ^QuartzInfo, set as Boolean )// FBtoC: function name changed from QuartzInfo to avoid clash with record of same name'~'1begin globalsdim as QuartzInfo  sQuartzInfoend globalslong if ( set )BlockMove( info, @sQuartzInfo, sizeof( QuartzInfo ) )xelseBlockMove( @sQuartzInfo, info, sizeof( QuartzInfo ) )end ifend fnlocal modelocal fn QuartzSetDefaults'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )BlockZero( info, sizeof(QuartzInfo) )info.drawMode = _kCGPathStrokeinfo.line.width = 1.0info.line.cap = _kCGLineCapRoundinfo.ratio.x = 1.0info.ratio.y = 1.0info.strokeColor.alpha = 1.0info.fillColor.alpha = 1.0info.shadow.colors[3] = 1.0fn QuartzGetInfo( @info, _zTrue )end fn'~Pathlocal modelocal fn QuartzBeginPath( fillFlag as Boolean, strokeFlag as Boolean, info as ^QuartzInfo  )'~'1dim as CGColorSpaceRef   colorSpaceRefdim as CGColorRef        colorReffn QuartzGetInfo( info, _false )long if ( fn QDBeginCGContext( window( _wndPort ), info.ctx ) == _noErr )CGContextSaveGState( info.ctx )CGContextTranslateCTM( info.ctx, 0.0, window( _height ) )CGContextScaleCTM( info.ctx, 1.0, -1.0 )// shadowlong if ( info.shadow.set )colorRef = 0long if ( info.shadow.isColor )colorSpaceRef = fn CGColorSpaceCreateDeviceRGB()colorRef      = fn CGColorCreate( colorSpaceRef, @info.shadow.colors[0] )CGContextSetShadowWithColor( info.ctx, info.shadow.offset, info.shadow.blur, colorRef )CGColorRelease( colorRef )CGColorSpaceRelease( colorSpaceRef )xelseCGContextSetShadow( info.ctx, info.shadow.offset, info.shadow.blur )end ifend if// transparency layer/*long if ( info.transLayer.set )long if ( info.transLayer.begin == _false )fn CGContextBeginTransparencyLayer( info.ctx, 0 )info.transLayer.begin = _zTrueend ifend if*/CGContextBeginPath( info.ctx )long if ( strokeFlag )CGContextSetLineWidth( info.ctx, info.line.width )CGContextSetRGBStrokeColor( info.ctx, info.strokeColor.red, info.strokeColor.green, info.strokeColor.blue, info.strokeColor.alpha )end iflong if ( fillFlag )CGContextSetRGBFillColor( info.ctx, info.fillColor.red, info.fillColor.green, info.fillColor.blue, info.fillColor.alpha )end ifif ( fillFlag ) then info.drawMode = _kCGPathFilllong if ( strokeFlag )if ( fillFlag ) then info.drawMode = _kCGPathFillStroke else info.drawMode = _kCGPathStrokeend iffn QuartzGetInfo( info, _zTrue )end ifend fnlocal modelocal fn QuartzEndPath(  x as single, y as single )'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )long if ( info.drawMode == _kCGPathStroke || info.drawMode == _kCGPathFillStroke )CGContextSetLineCap ( info.ctx, info.line.cap )end iflong if ( info.line.dash.count )CGContextSetLineDash( info.ctx, info.line.dash.phase, #[info.line.dash.lengths], info.line.dash.count )end ifCGContextDrawPath( info.ctx, info.drawMode )// transparency layer/*long if ( info.transLayer.set == _false )long if ( info.transLayer.begin )fn CGContextEndTransparencyLayer( info.ctx )info.transLayer.begin = _falseend ifend if*/CGContextSynchronize( info.ctx )CGContextRestoreGState( info.ctx )fn QDEndCGContext( window( _wndPort ), info.ctx )info.ctx = 0info.lastPoint.x = xinfo.lastPoint.y = yfn QuartzGetInfo( @info, _zTrue )end fn'~Ratio/*  QuartzSetRatio  Emulate FB ratio statement*/local modelocal fn QuartzSetRatio( x as single, y as single )'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )info.ratio = fn CGPointMake( x, y )fn QuartzGetInfo( @info, _zTrue )end fn/*local modelocal fn QuartzScale( x as single, y as single )'~'1end fn*/'~RGBA Colorlocal modelocal fn QuartzSetStrokeColor( red as single, green as single, blue as single, alpha as single )'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )info.strokeColor.red   = redinfo.strokeColor.green = greeninfo.strokeColor.blue  = blueinfo.strokeColor.alpha = alphafn QuartzGetInfo( @info, _zTrue )end fnlocal modelocal fn QuartzSetStrokeAlpha( alpha as single )'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )info.strokeColor.alpha = alphafn QuartzGetInfo( @info, _zTrue )end fnlocal modelocal fn QuartzSetFillColor( red as single, green as single, blue as single, alpha as single )'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )info.fillColor.red   = redinfo.fillColor.green = greeninfo.fillColor.blue  = blueinfo.fillColor.alpha = alphafn QuartzGetInfo( @info, _zTrue )end fnlocal modelocal fn QuartzSetFillAlpha( alpha as single )'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )info.fillColor.alpha = alphafn QuartzGetInfo( @info, _zTrue )end fn'~QD Colorlocal modelocal fn QuartzQDColorToRGBA( c as long, colour as ^QuartzRGBA )'~'1dim as QuartzRGBA  rgbaselect ccase _zWhitergba.red = 1.0 : rgba.green = 1.0 : rgba.blue = 1.0case _zYellowrgba.red = 64512 / 65535 : rgba.green = 62333 / 65535 : rgba.blue = 1327 / 65535case _zGreenrgba.red = 0.0 : rgba.green = 32768 / 65535 : rgba.blue = 4528 / 65535case _zCyanrgba.red = 577 / 65535 : rgba.green = 43860 / 65535 : rgba.blue = 60159 / 65535case _zBluergba.red = 0.0 : rgba.green = 0.0 : rgba.blue = 54272 / 65535case _zMagentargba.red = 62167 / 65535 : rgba.green = 2134 / 65535 : rgba.blue = 34028 / 65535case _zRedrgba.red = 56683 / 65535 : rgba.green = 2242 / 65535 : rgba.blue = 1698 / 65535case elsergba.red = 0.0 : rgba.green = 0.0 : rgba.blue = 0.0end selectrgba.alpha = 1.0BlockMove( @rgba, colour, sizeof(QuartzRGBA) )end fnlocal modelocal fn QuartzSetFillQDColor( c as long )'~'1dim as QuartzRGBA  rgbafn QuartzQDColorToRGBA( c, @rgba )fn QuartzSetFillColor( rgba.red, rgba.green, rgba.blue, rgba.alpha )end fnlocal modelocal fn QuartzSetStrokeQDColor( c as long )'~'1dim as QuartzRGBA  rgbafn QuartzQDColorToRGBA( c, @rgba )fn QuartzSetStrokeColor( rgba.red, rgba.green, rgba.blue, rgba.alpha )end fn/*  QuartzSetQDColor  Emulate FB color statement*/local modelocal fn QuartzSetQDColor( c as long )'~'1dim as QuartzRGBA  rgbafn QuartzQDColorToRGBA( c, @rgba )fn QuartzSetFillColor( rgba.red, rgba.green, rgba.blue, rgba.alpha )fn QuartzSetStrokeColor( rgba.red, rgba.green, rgba.blue, rgba.alpha )end fn/*  QuartzSetQDLongColor  Emulate FB long color statement*/local modelocal fn QuartzSetQDLongColor( blue as single, green as single, red as single )'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )info.strokeColor.red   = red / 65535info.strokeColor.green = green / 65535info.strokeColor.blue  = blue / 65535info.fillColor.red   = red / 65535info.fillColor.green = green / 65535info.fillColor.blue  = blue / 65535fn QuartzGetInfo( @info, _zTrue )end fn'~Shadowlocal modelocal fn QuartzShadowSetValues( offsetWidth as single, offsetHeight as single, blur as single, isColor as Boolean )'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )info.shadow.offset.width = offsetWidthinfo.shadow.offset.height = offsetHeightinfo.shadow.blur = blurinfo.shadow.isColor = isColorfn QuartzGetInfo( @info, _zTrue )end fnlocal modelocal fn QuartzShadowSetColor( red as single, green as single, blue as single, alpha as single )'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )info.shadow.colors[0] = redinfo.shadow.colors[1] = greeninfo.shadow.colors[2] = blueinfo.shadow.colors[3] = alphafn QuartzGetInfo( @info, _zTrue )end fnlocal modelocal fn QuartzSetShadow( set as Boolean )'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )info.shadow.set = setfn QuartzGetInfo( @info, _zTrue )end fn'~Transparency Layer/*  QuartzSetTransparencyLayer  Unfinished - please don't use*/local modelocal fn QuartzSetTransparencyLayer( set as Boolean )'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )info.transLayer.set = setfn QuartzGetInfo( @info, _zTrue )end fn'~Linelocal modelocal fn QuartzSetLineCap( lineCap as long )'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )info.line.cap = lineCapfn QuartzGetInfo( @info, _zTrue )end fnlocal modelocal fn QuartzSetLineDash( phase as single, lengths as pointer, count as long )'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )long if ( fn IsHandleValid( info.line.dash.lengths ) )DisposeHandle( info.line.dash.lengths )info.line.dash.lengths = 0end ifinfo.line.dash.count = countlong if ( count )info.line.dash.phase = phaseinfo.line.dash.lengths = fn NewHandle( 0 )fn PtrAndHand( lengths, info.line.dash.lengths, count*sizeof(single) )end iffn QuartzGetInfo( @info, _zTrue )end fnlocal modelocal fn QuartzClearLineDash'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )info.line.dash.count = 0long if ( fn IsHandleValid( info.line.dash.lengths ) )DisposeHandle( info.line.dash.lengths )info.line.dash.lengths = 0end iffn QuartzGetInfo( @info, _zTrue )end fnlocal modelocal fn QuartzSetLineWidth( w as single )'~'1dim as QuartzInfo  infofn QuartzGetInfo( @info, _false )info.line.width = wfn QuartzGetInfo( @info, _zTrue )end fnlocal modelocal fn QuartzLine( x1 as single, y1 as single, x2 as single, y2 as single )'~'1dim as QuartzInfo  infofn QuartzBeginPath( _false, _zTrue, @info )CGContextMoveToPoint( info.ctx, x1, y1 )CGContextAddLineToPoint( info.ctx, x2, y2 )fn QuartzEndPath( x2, y2 )end fnlocal modelocal fn QuartzLineTo( x2 as single, y2 as single )'~'1dim as QuartzInfo  infofn QuartzBeginPath( _false, _zTrue, @info )CGContextMoveToPoint( info.ctx, info.lastPoint.x, info.lastPoint.y )CGContextAddLineToPoint( info.ctx, x2, y2 )fn QuartzEndPath( x2, y2 )end fn'~Rectlocal modelocal fn QuartzRect( left as single, top as single, right as single, bottom as single, fillFlag as Boolean, strokeFlag as Boolean )'~'1dim as CGRect      rdim as QuartzInfo  infofn QuartzBeginPath( fillFlag, strokeFlag, @info )r = fn CGRectMake( left, top, right - left, bottom - top )if ( fillFlag ) then CGContextFillRect( info.ctx, r )if ( strokeFlag ) then CGContextStrokeRect( info.ctx, r )fn QuartzEndPath( r.origin.x + r.size.width, r.origin.y + r.size.height )end fn'~Rounded Rectlocal modelocal fn QuartzRoundedRectPath( ctx as CGContextRef, r1 as ^CGRect, ovalWidth as single, ovalHeight as single )'~'1dim as CGRect   r : r = r1dim as single   fw, fhif ( ovalWidth == 0.0 || ovalHeight == 0.0 ) then fn CGContextAddRect( ctx, r )CGContextSaveGState( ctx )CGContextTranslateCTM( ctx, r.origin.x, r.origin.y )CGContextScaleCTM( ctx, ovalWidth, ovalHeight )fw = r.size.width / ovalWidthfh = r.size.height / ovalHeightCGContextMoveToPoint( ctx, fw, fh/2 )CGContextAddArcToPoint( ctx, fw, fh, fw/2, fh, 1 )CGContextAddArcToPoint( ctx, 0, fh, 0, fh/2, 1 )CGContextAddArcToPoint( ctx, 0, 0, fw/2, 0, 1 )CGContextAddArcToPoint( ctx, fw, 0, fw, fh/2, 1 )CGContextClosePath( ctx )CGContextRestoreGState( ctx )end fnlocal modelocal fn QuartzRoundedRect( left as single, top as single, right as single, bottom as single, ovalWidth as single, ovalHeight as single, fillFlag as Boolean, strokeFlag as Boolean )'~'1dim as QuartzInfo  infodim as CGRect      rfn QuartzBeginPath( fillFlag, strokeFlag, @info )r = fn CGRectMake( left, top, right - left, bottom - top )fn QuartzRoundedRectPath( info.ctx, r, ovalWidth, ovalHeight )fn QuartzEndPath( r.origin.x + r.size.width, r.origin.y + r.size.height )end fn'~Ovallocal modelocal fn QuartzMakeOvalRect( x as single, y as single, radius as single, r as ^CGrect, rat as ^CGPoint ) // FBtoC: 'ratio' parm changed to 'rat''~'1dim as single  l, t, w, h, ratioX, ratioYdim as CGrect  rTempratioX = radius*rat.xratioY = radius*rat.yl =  x - ratioXt = y - ratioYw = x + ratioX - lh = y + ratioY - trTemp = fn CGRectMake( l, t, w, h )BlockMoveData( @rTemp, r, sizeof( CGrect ) )end fnlocal fn QuartzOvalPath( ctx as CGContextRef, r as ^CGRect )'~'1dim as CGAffineTransform  matrixCGContextSaveGState( ctx )matrix = fn CGAffineTransformMake( (r.size.width)/2, 0, 0, (r.size.height)/2, r.origin.x + (r.size.width)/2, r.origin.y + (r.size.height)/2 )CGContextConcatCTM( ctx, matrix )CGContextBeginPath( ctx )CGContextAddArc( ctx, 0, 0, 1, 0, 2 * PI, 0 )CGContextRestoreGState( ctx )end fnlocal modelocal fn QuartzOval( x as single, y as single, radius as single, fillFlag as Boolean, strokeFlag as Boolean )'~'1dim as CGRect      rdim as QuartzInfo  infofn QuartzBeginPath( fillFlag, strokeFlag, @info )fn QuartzMakeOvalRect( x, y, radius, @r, info.ratio )fn QuartzOvalPath( info.ctx, r )fn QuartzEndPath( r.origin.x + r.size.width, r.origin.y + r.size.height )end fn'~Arclocal modelocal fn QuartzArcPath( ctx as CGContextRef, r as ^CGRect, startAngle as short, arcAngle as short )'~'1dim as single             s, edim as CGAffineTransform  matrixCGContextSaveGState( ctx )matrix = fn CGAffineTransformMake( (r.size.width)/2, 0, 0, (r.size.height)/2, r.origin.x + (r.size.width)/2, r.origin.y + (r.size.height)/2 )CGContextConcatCTM( ctx, matrix )startAngle = -startAnglelong if ( arcAngle > 0 )s = fn QuartzDegreesToRadians( startAngle - arcAngle )e = fn QuartzDegreesToRadians( startAngle )xelses = fn QuartzDegreesToRadians( startAngle )e = fn QuartzDegreesToRadians( startAngle - arcAngle )end ifCGContextAddArc( ctx, 0, 0, 1, s, e, 0 )CGContextRestoreGState( ctx )end fnlocal modelocal fn QuartzArc( x as single, y as single, radius as single, startAngle as short, angleSize as short, arcTo as Boolean, fillFlag as Boolean, strokeFlag as Boolean )'~'1dim as QuartzInfo  infodim as CGRect      rdim as single      o, afn QuartzBeginPath( fillFlag, strokeFlag, @info )fn QuartzMakeOvalRect( x, y, radius, @r, info.ratio )CGContextMoveToPoint( info.ctx, r.origin.x + r.size.width/2, r.origin.y + r.size.height/2)fn QuartzArcPath( info.ctx, r, fn QuartzBradsToDegrees( startAngle ), fn QuartzBradsToDegrees( angleSize ) )long if ( strokeFlag )long if ( arcTo )CGContextMoveToPoint( info.ctx, x, y )o = sin( fn QuartzBradsToRadians( startAngle ) ) * ( radius * info.ratio.y )a = cos( fn QuartzBradsToRadians( startAngle ) ) * ( radius * info.ratio.x )CGContextAddLineToPoint( info.ctx, x + a, y - o )o = sin( fn QuartzBradsToRadians( startAngle + angleSize ) ) * ( radius * info.ratio.y )a = cos( fn QuartzBradsToRadians( startAngle + angleSize ) ) * ( radius * info.ratio.x )CGContextMoveToPoint( info.ctx, x + a, y - o )CGContextAddLineToPoint( info.ctx, x, y )end ifend iffn QuartzEndPath( x, y )end fn/*local modelocal fn QuartzFill( x as single, y as single )'~'1end fn*/fn QuartzSetDefaults// initialise