// pChess 1.9.4 UCI GUI// Display Module v3.4 (Quartz compliant.. mostly)// Written by: John Roland Penner <johnrolandpenner-at-gmail-dot-com>// This file is released under the GNU public license, 2012// Updated as of: February 18, 2012 (Toronto, Ontario, Canada)#if _buildAsUCIEngine == _falselocal fn clearScreenWINDOW #1// Default Colour of the Window bgB_board = 55769 : bgG_board = 46260 : bgR_board = 46260 fgB_board = 0 : fgG_board = 0 : fgR_board = 0 LONG COLOR bgB_board, bgG_board, bgR_board, _false LONG COLOR fgB_board, fgG_board, fgR_board, _true TEXT _FontFace, _FontSize, 0 cls : edit$(9)="" fn gameHistoryend fnlocal FN cheqBoard(board as ^boardRecord)// Graphics Depend on the existence of Adobe's free 'Cheq' font: // http://tug.ctan.org/tex-archive/fonts/chess/cheq/dim as long x, y, z, ndim as long xStartAdj, yStartAdjdim as long cellX, cellY, xMax, yMaxdim as long sqComp, Xloc, Ylocdim as str255 label// coord values for the 58pt CHEQ fontxStartAdj = 20 : yStartAdj = 20cellX = 64 : cellY = 64xMax = 512 : yMax = 512#if _buildPPC == _falseTEXT gCheqFont, _CheqSize, 0 : locate 0,0#endif#if _buildPPC == _trueTEXT _CheqFont, _CheqSize, 0 : locate 0,0#endif/*// coord values for the 48pt CHEQ fontxStartAdj = 20 : yStartAdj = 20cellX = 52 : cellY = 52xMax = 415 : yMax = 415*/// default bgColour & fgColourbgB_board = 55769 : bgG_board = 46260 : bgR_board = 46260bgB_bBoard = 28527 : bgG_bBoard = 23130 : bgR_bBoard = 19532fgB_board = 0 : fgG_board = 0 : fgR_board = 0bgB_bPiece = 65535 : bgG_bPiece = 0 : bgR_bPiece = 32768fgB_bPiece = 65535 : fgG_bPiece = 65535 : fgR_bPiece = 65535bgB_wPiece = 65535 : bgG_wPiece = 65535 : bgR_wPiece = 65535fgB_wPiece = 0 : fgG_wPiece = 0 : fgR_wPiece = 0LONG COLOR bgB_board, bgG_board, bgR_board, _falseLONG COLOR fgB_board, fgG_board, fgR_board, _truefn QuartzSetLineWidth( _penWidth )// DISPLAY THE BOARDfor y = 8 to 1 step -1for x = 1 to 8//swap up locations for flipped boardlong if gFlip = _FalseXloc = xStartAdj + (x-1) * cellX +1              '+1 = width of gridYloc = yStartAdj + (9*cellY) - (y*cellY) -5      '-5 for the baseline bugxelseXloc = xStartAdj + ((9-x)-1) * cellX +1          '+1 = width of gridYloc = yStartAdj + (9*cellY) - ((9-y)*cellY) -5  '-5 for the baseline bugend if//generate alternating square colourssqComp = ((x + (y mod 2)) mod 2) long if sqCompfn QuartzSetQDLongColor( 55769, 46260, 46260 )          'FG lavendar rectLONG COLOR bgB_board, bgG_board, bgR_board, _false      'BG lavenar text glyphxelsefn QuartzSetQDLongColor( bgB_bBoard, bgG_bBoard, bgR_bBoard )  'FG slate rectLONG COLOR bgB_bBoard, bgG_bBoard, bgR_bBoard, _false     'BG slate text glyphend if//paint in a background to cover the pixel crud left by print's inconsistent x-height. fn QuartzRect( Xloc, Yloc-cellY+6, Xloc+cellX-2, Yloc+4, _true, _false )n = (y*8 - (9-x))if board.square[n] > 0 then LONG COLOR fgB_bPiece, fgG_bPiece, fgR_bPiece, _trueif board.square[n] < 0 then LONG COLOR fgB_wPiece, fgG_wPiece, fgR_wPiece, _truecall MoveTo (Xloc, Yloc)select abs(board.square[n])case 0 : print " ";case 1 : print "P";      'pawn ('peschke')case 2 : print "L";      'bishop ('laufer')case 3 : print "S";      'knightcase 4 : print "T";      'rook ('turm')case 5 : print "Q";      'queencase 6 : print "K";      'kingend selectLONG COLOR bgB_board, bgG_board, bgR_board, _falseLONG COLOR fgB_board, fgG_board, fgR_board, _truenext xnext y// draw the gridfn QuartzSetQDColor( _zBlack )fn QuartzSetLineWidth( _penWidth )for z = 0 to 8Xloc = xStartAdj + (z * cellX )Yloc = yStartAdj + z * cellYfn QuartzLine( Xloc, yStartAdj, Xloc, yStartAdj + (8*cellY) )fn QuartzLine( xStartAdj, Yloc, xStartAdj + (8*cellX), Yloc )next z// set the colour of the who2move spotlong if board.who2move = _whiteefn QuartzSetQDLongColor( 65535, 65535, 65535 )xelsefn QuartzSetQDLongColor( bgB_bBoard, bgG_bBoard, bgR_bBoard )end if// draw the who2move spotfn QuartzOval( 565, 522, 10, _true, _false )//reset pen to default coloursLONG COLOR bgB_board, bgG_board, bgR_board, _falseLONG COLOR fgB_board, fgG_board, fgR_board, _trueTEXT _FontFace, _FontSize, 0//print algebraic axis labelslong if (_axisLabels == _True)LONG COLOR 28527, 23130, 19532, _true     //grey textlong if gFlip = _false//print white algebraic axis labelsfor y = 8 to 1 step -1//Xloc = xStartAdj + xMax + 5Xloc = xStartAdj - 20Yloc = yStartAdj + (9*cellY) - (y*cellY) + 0call MoveTo (Xloc, Yloc)print y; next ylabel="abcdefgh"for x = 1 to 8Xloc = xStartAdj + (x * cellX) - (cellX/2) -4Yloc = yStartAdj + yMax + 20long if (board.fischer) and ( (x=3) or (x=7) )call MoveTo (Xloc-6, Yloc)#if _buildPPC == _falseTEXT gCheqFont, _CheqCaptureSize-6, 0#endif#if _buildPPC == _trueTEXT _CheqFont, _CheqCaptureSize-6, 0#endifprint "K";TEXT _FontFace, _FontSize, 0xelsecall MoveTo (Xloc, Yloc)print mid$(label, x, 1); end ifnext xxelse//print black algebraic axis labelsfor y = 1 to 8//Xloc = xStartAdj + xMax + 5Xloc = xStartAdj - 20Yloc = yStartAdj + (9*cellY) - ((9-y)*cellY) + 0call MoveTo (Xloc, Yloc)print y; next ylabel="abcdefgh"for x = 8 to 1 step -1Xloc = xStartAdj + ((9-x) * cellX) - (cellX/2) -4Yloc = yStartAdj + yMax + 20long if (board.fischer) and ( (x=3) or (x=7) )call MoveTo (Xloc-6, Yloc)#if _buildPPC == _falseTEXT gCheqFont, _CheqCaptureSize-6, 0#endif#if _buildPPC == _trueTEXT _CheqFont, _CheqCaptureSize-6, 0#endifprint "K";TEXT _FontFace, _FontSize, 0xelsecall MoveTo (Xloc, Yloc)print mid$(label, x, 1); end ifnext xend ifLONG COLOR 65535, 65535, 65535, _true //white textend ifend FNlocal FN cheqOverlay(board as ^boardRecord, moves(_maxMoves) as moveRecord, numMoves as long, overlayInfo as boolean)dim as long xStartAdj, yStartAdjdim as long cellX, cellY, xMax, yMaxdim as long x1, y1, x2, y2 : x2=0 : y2=0dim as long n, fromPiece, toPiecedim as long Xloc1, Yloc1, Xloc2, Yloc2#if _buildPPC == _falseTEXT gCheqFont, _CheqSize, 0 : locate 0,0#endif#if _buildPPC == _trueTEXT _CheqFont, _CheqSize, 0 : locate 0,0#endif/*//coord values for the 48pt CHEQ fontxStartAdj = 20 : yStartAdj = 20cellX = 52 : cellY = 52xMax = 415 : yMax = 415*/// coord values for the 58pt CHEQ fontxStartAdj = 20 : yStartAdj = 20cellX = 64 : cellY = 64xMax = 512 : yMax = 512// default bgColour & fgColourbgB_board = 55769 : bgG_board = 46260 : bgR_board = 46260fgB_board = 0 : fgG_board = 0 : fgR_board = 0bgB_highlight = 0 : bgG_highlight = 42000 : bgR_highlight = 54199fgB_highlight = 65535 : fgG_highlight = 65535 : fgR_highlight = 65535// sanity check - don't display stuff that isnt thereif (numMoves < 1) then exit fnif (moves.fromSquare(0) = _noSuchSquare) or (moves.toSquare(0) = _noSuchSquare) then exit fnlong if (moves.fromSquare(0) = moves.toSquare(0))// SINGLE SQUARE ONLY//convert from index to xy coordinatesx1 = fn sq2X(moves.fromSquare(0)) +1y1 = fn sq2Y(moves.fromSquare(0)) +1fromPiece = board.square[moves.fromSquare(0)]// coordinates will be different if we are FLIPPEDlong if gFlip = _false//and then translate board coords into screen coords (flip set to WHITE)Xloc1 = xStartAdj + (x1-1) * cellX +1             '+1 = width of gridYloc1 = yStartAdj + (9*cellY) - (y1*cellY) -5     '-5 for the baseline bugfn QuartzSetQDLongColor( 0, 42000, 54199 )          'highlight Rect Colourfn QuartzRect( Xloc1, Yloc1-cellY+6, Xloc1+cellX-2, Yloc1+4, _true, _false )//display the square (with its existing piece) in the highlight colourlong color bgB_highlight, bgG_highlight, bgR_highlight, _falselong if (fromPiece < 0) long color fgB_wPiece, fgG_wPiece, fgR_wPiece, _truexelselong color fgB_bPiece, fgG_bPiece, fgR_bPiece, _trueend ifcall MoveTo (Xloc1, Yloc1)select abs(fromPiece)case 0 : print " ";case 1 : print "P";      'pawn ('peschke')case 2 : print "L";      'bishop ('laufer')case 3 : print "S";      'knightcase 4 : print "T";      'rook ('turm')case 5 : print "Q";      'queencase 6 : print "K";      'kingend select//reset ourselves to default colours after the operation going outlong color bgB_board, bgG_board, bgR_board, _falselong color fgB_board, fgG_board, fgR_board, _truexelse// SINGLE SQUARE, FLIP=BLACK//and then translate board coords into screen coords (flip set to BLACK)Xloc1 = xStartAdj + ((9-x1)-1) * cellX +1             '+1 = width of gridYloc1 = yStartAdj + (9*cellY) - ((9-y1)*cellY) -5     '-5 for the baseline bugfn QuartzSetQDLongColor( 0, 42000, 54199 )          'highlight Rect Colourfn QuartzRect( Xloc1, Yloc1-cellY+6, Xloc1+cellX-2, Yloc1+4, _true, _false )//display the square (with its existing piece) in the highlight colourLONG COLOR bgB_highlight, bgG_highlight, bgR_highlight, _falseLONG IF (fromPiece < 0)LONG COLOR fgB_wPiece, fgG_wPiece, fgR_wPiece, _truexelseLONG COLOR fgB_bPiece, fgG_bPiece, fgR_bPiece, _trueEND IFcall MoveTo (Xloc1, Yloc1)select abs(fromPiece)case 0 : print " ";case 1 : print "P";      'pawn ('peschke')case 2 : print "L";      'bishop ('laufer')case 3 : print "S";      'knightcase 4 : print "T";      'rook ('turm')case 5 : print "Q";      'queencase 6 : print "K";      'kingend select//reset ourselves to default colours after the operation going outLONG COLOR bgB_board, bgG_board, bgR_board, _falseLONG COLOR fgB_board, fgG_board, fgR_board, _trueend ifxelse//grab moves to processfor n=0 to numMoves-1//convert from index to xy coordinatesx1 = fn sq2X(moves.fromSquare(n)) +1y1 = fn sq2Y(moves.fromSquare(n)) +1x2 = fn sq2X(moves.toSquare(n)) +1y2 = fn sq2Y(moves.toSquare(n)) +1fromPiece = board.square[moves.fromSquare(n)]toPiece = board.square[moves.toSquare(n)]// coordinates will be different if we are FLIPPEDlong if gFlip = _false//and then translate board coords into screen coords (flip set to WHITE)Xloc1 = xStartAdj + (x1-1) * cellX +1             '+1 = width of gridYloc1 = yStartAdj + (9*cellY) - (y1*cellY) -5     '-5 for the baseline bugXloc2 = xStartAdj + (x2-1) * cellX +1             '+1 = width of gridYloc2 = yStartAdj + (9*cellY) - (y2*cellY) -5     '-5 for the baseline bugfn QuartzSetQDLongColor( 0, 42000, 54199 )          'highlight Rect Colourfn QuartzRect( Xloc1, Yloc1-cellY+6, Xloc1+cellX-2, Yloc1+4, _true, _false )fn QuartzRect( Xloc2, Yloc2-cellY+6, Xloc2+cellX-2, Yloc2+4, _true, _false )//LONG COLOR bgB_highlight, bgG_highlight, bgR_highlight, _true     'PaintRect uses FG (_true)//CALL SetRect(arect, Xloc1, Yloc1-cellY+6, Xloc1+cellX-2, Yloc1+4)//CALL PaintRect(arect)//CALL SetRect(arect, Xloc2, Yloc2-cellY+6, Xloc2+cellX-2, Yloc2+4)//CALL PaintRect(arect)//display the square (with its existing piece) in the highlight colourlong color bgB_highlight, bgG_highlight, bgR_highlight, _falselong if (fromPiece < 0) or (toPiece < 0)long color fgB_wPiece, fgG_wPiece, fgR_wPiece, _truexelselong color fgB_bPiece, fgG_bPiece, fgR_bPiece, _trueend ifcall MoveTo (Xloc1, Yloc1)select abs(fromPiece)case 0 : print " ";case 1 : print "P";      'pawn ('peschke')case 2 : print "L";      'bishop ('laufer')case 3 : print "S";      'knightcase 4 : print "T";      'rook ('turm')case 5 : print "Q";      'queencase 6 : print "K";      'kingend selectcall MoveTo (Xloc2, Yloc2)select abs(toPiece)case 0 : print " ";case 1 : print "P";      'pawn ('peschke')case 2 : print "L";      'bishop ('laufer')case 3 : print "S";      'knightcase 4 : print "T";      'rook ('turm')case 5 : print "Q";      'queencase 6 : print "K";      'kingend select//reset ourselves to default colours after the operation going outlong color bgB_board, bgG_board, bgR_board, _falselong color fgB_board, fgG_board, fgR_board, _truelong if (gOverLines = _true) and (numMoves > 0)//and then translate board coords into screen coordsXloc1 = xStartAdj + (x1-1) * cellX +1                 '+1 = width of gridYloc1 = yStartAdj + (9*cellY) - ((y1+1)*cellY) -5     '-5 for the baseline bugXloc2 = xStartAdj + (x2-1) * cellX +1                 '+1 = width of gridYloc2 = yStartAdj + (9*cellY) - ((y2+1)*cellY) -5     '-5 for the baseline bug//and make them aim at the centre of the cellsXloc1 = Xloc1 + cellX/2 : Yloc1 = Yloc1 + cellY/2Xloc2 = Xloc2 + cellX/2 : Yloc2 = Yloc2 + cellY/2//set the colour of the overLinefn QuartzSetLineWidth( _brainWidth )fn QuartzSetQDLongColor( 65535-(32768+(-900)), 65535-8192, 65535-(32768+(900)) )fn QuartzLine( Xloc1, Yloc1, Xloc2, Yloc2 )//long color 65535-(32768+(-900)), 65535-8192, 65535-(32768+(900)), _true     'FG (_true)//pensize(_brainWidth, _brainWidth)//moveto (Xloc1, Yloc1)//lineto (Xloc2, Yloc2)//reset ourselves to default colours after the operation going outlong color bgB_board, bgG_board, bgR_board, _falselong color fgB_board, fgG_board, fgR_board, _trueend ifxelse//and then translate board coords into screen coords (flip set to BLACK)Xloc1 = xStartAdj + ((9-x1)-1) * cellX +1             '+1 = width of gridYloc1 = yStartAdj + (9*cellY) - ((9-y1)*cellY) -5     '-5 for the baseline bugXloc2 = xStartAdj + ((9-x2)-1) * cellX +1             '+1 = width of gridYloc2 = yStartAdj + (9*cellY) - ((9-y2)*cellY) -5     '-5 for the baseline bugfn QuartzSetQDLongColor( 0, 42000, 54199 )          'highlight Rect Colourfn QuartzRect( Xloc1, Yloc1-cellY+6, Xloc1+cellX-2, Yloc1+4, _true, _false )fn QuartzRect( Xloc2, Yloc2-cellY+6, Xloc2+cellX-2, Yloc2+4, _true, _false )//display the square (with its existing piece) in the highlight colourLONG COLOR bgB_highlight, bgG_highlight, bgR_highlight, _falseLONG IF (fromPiece < 0) or (toPiece < 0)LONG COLOR fgB_wPiece, fgG_wPiece, fgR_wPiece, _truexelseLONG COLOR fgB_bPiece, fgG_bPiece, fgR_bPiece, _trueEND IFcall MoveTo (Xloc1, Yloc1)select abs(fromPiece)case 0 : print " ";case 1 : print "P";      'pawn ('peschke')case 2 : print "L";      'bishop ('laufer')case 3 : print "S";      'knightcase 4 : print "T";      'rook ('turm')case 5 : print "Q";      'queencase 6 : print "K";      'kingend selectcall MoveTo (Xloc2, Yloc2)select abs(toPiece)case 0 : print " ";case 1 : print "P";      'pawn ('peschke')case 2 : print "L";      'bishop ('laufer')case 3 : print "S";      'knightcase 4 : print "T";      'rook ('turm')case 5 : print "Q";      'queencase 6 : print "K";      'kingend select//reset ourselves to default colours after the operation going outLONG COLOR bgB_board, bgG_board, bgR_board, _falseLONG COLOR fgB_board, fgG_board, fgR_board, _truelong if (gOverLines = _True) and (numMoves > 0)Xloc1 = xStartAdj + ((9-x1)-1) * cellX +1             '+1 = width of gridYloc1 = yStartAdj + (9*cellY) - ((9-y1)*cellY) -5     '-5 for the baseline bugXloc2 = xStartAdj + ((9-x2)-1) * cellX +1             '+1 = width of gridYloc2 = yStartAdj + (9*cellY) - ((9-y2)*cellY) -5     '-5 for the baseline bug//and make them aim at the centre of the cellsXloc1 = Xloc1 + cellX/2 : Yloc1 = Yloc1 - cellY/2Xloc2 = Xloc2 + cellX/2 : Yloc2 = Yloc2 - cellY/2//set the colour of the overLinefn QuartzSetLineWidth( _brainWidth )fn QuartzSetQDLongColor( 65535-(32768+(-900)), 65535-8192, 65535-(32768+(900)) )fn QuartzLine( Xloc1, Yloc1, Xloc2, Yloc2 )//reset ourselves to default colours after the operation going outLONG COLOR bgB_board, bgG_board, bgR_board, _falseLONG COLOR fgB_board, fgG_board, fgR_board, _trueend ifend ifnext nend if// show overlay lineslong if (gOverLines = _true)long if gFlip = _false//and then translate board coords into screen coordsXloc1 = xStartAdj + (x1-1) * cellX +1     '+2 = width of gridYloc1 = yStartAdj + (9*cellY) - ((y1+1)*cellY) -5     '-4 for the baseline bugXloc2 = xStartAdj + (x2-1) * cellX +1     '+2 = width of gridYloc2 = yStartAdj + (9*cellY) - ((y2+1)*cellY) -5     '-4 for the baseline bug//and make them aim at the centre of the cellsXloc1 = Xloc1 + cellX/2 : Yloc1 = Yloc1 + cellY/2Xloc2 = Xloc2 + cellX/2 : Yloc2 = Yloc2 + cellY/2//set the colour of the overLinefn QuartzSetLineWidth( _brainWidth )fn QuartzSetQDLongColor( 65535-(32768+(-900)), 65535-8192, 65535-(32768+(900)) )fn QuartzLine( Xloc1, Yloc1, Xloc2, Yloc2 )//reset ourselves to default colours after the operation going outLONG COLOR bgB_board, bgG_board, bgR_board, _falseLONG COLOR fgB_board, fgG_board, fgR_board, _truexelseXloc1 = xStartAdj + ((9-x1)-1) * cellX +2     '+2 = width of gridYloc1 = yStartAdj + (9*cellY) - ((9-y1)*cellY) -4     '-4 for the baseline bugXloc2 = xStartAdj + ((9-x2)-1) * cellX +2     '+2 = width of gridYloc2 = yStartAdj + (9*cellY) - ((9-y2)*cellY) -4     '-4 for the baseline bug//and make them aim at the centre of the cellsXloc1 = Xloc1 + cellX/2 : Yloc1 = Yloc1 - cellY/2Xloc2 = Xloc2 + cellX/2 : Yloc2 = Yloc2 - cellY/2//set the colour of the overLinefn QuartzSetLineWidth( _brainWidth )fn QuartzSetQDLongColor( 65535-(32768+(-900)), 65535-8192, 65535-(32768+(900)) )fn QuartzLine( Xloc1, Yloc1, Xloc2, Yloc2 )//reset ourselves to default colours after the operation going outLONG COLOR bgB_board, bgG_board, bgR_board, _falseLONG COLOR fgB_board, fgG_board, fgR_board, _trueend ifend ifend fn//---| ASCII |-----------------------------------------------------//local FN asciiBoard(board as ^boardRecord) dim as short x, y, n dim as str255 RPad, LPad LPad=" " : RPad="" TEXT 22, 15, 0 : locate 0,0// default bgColour & fgColour  bgB_board = 65535 : bgG_board = 54483 : bgR_board = 54199  fgB_board = 0 : fgG_board = 0 : fgR_board = 0  bgB_bPiece = 65535 : bgG_bPiece = 0 : bgR_bPiece = 32768  fgB_bPiece = 65535 : fgG_bPiece = 65535 : fgR_bPiece = 65535  bgB_wPiece = 65535 : bgG_wPiece = 65535 : bgR_wPiece = 65535  fgB_wPiece = 0 : fgG_wPiece = 0 : fgR_wPiece = 0  LONG COLOR bgB_board, bgG_board, bgR_board, _false  LONG COLOR fgB_board, fgG_board, fgR_board, _true print LPad; "+---+---+---+---+---+---+---+---+"; RPad for x = 8 to 1 step -1locate 0,(17-x*2)print LPad$; for y = 0 to 7n = (x-1)*8 + yprint "|"; if board.square[n] > 0 then LONG COLOR bgB_wPiece, bgG_wPiece, bgR_wPiece, _false : LONG COLOR fgB_wPiece, fgG_wPiece, fgR_wPiece, _trueif board.square[n] < 0 then LONG COLOR bgB_bPiece, bgG_bPiece, bgR_bPiece, _false : LONG COLOR fgB_bPiece, fgG_bPiece, fgR_bPiece, _trueselect case abs(board.square[n] )case 0 : print "   "; case 1 : print " P "; case 2 : print " B "; case 3 : print " N "; case 4 : print " R "; case 5 : print " Q "; case 6 : print " K "; end selectLONG COLOR bgB_board, bgG_board, bgR_board, _falseLONG COLOR fgB_board, fgG_board, fgR_board, _true next yprint "|"; RPad$; xlocate 0,(17-x*2)+1print LPad; "+---+---+---+---+---+---+---+---+"; RPadnext xlocate 0,17print LPad; "  a   b   c   d   e   f   g   h  "; RPad;//who2move displayed in colourlong if board.who2move = _whitee     long color bgB_wPiece, bgG_wPiece, bgR_wPiece, _false : LONG COLOR fgB_wPiece, fgG_wPiece, fgR_wPiece, _true     xelse     long color bgB_bPiece, bgG_bPiece, bgR_bPiece, _false : LONG COLOR fgB_bPiece, fgG_bPiece, fgR_bPiece, _trueend ifprint board.who2movelong color bgB_board, bgG_board, bgR_board, _falselong color fgB_board, fgG_board, fgR_board, _trueprint : print "who2move: "; board.who2moveprint "halfMoves:"; board.halfMovesprint "wCastleK/Qside:"; board.wCastleKside; board.wCastleQsideprint "bCastleK/Qside:"; board.bCastleKside; board.bCastleQsideprint "enPassantSq:"; board.enPassantSqend FNlocal FN asciiOverlay(board as ^boardRecord, moves(_maxMoves) as moveRecord, numMoves as long)dim as str255 LPad, RPaddim as long x1, y1, x2, y2dim as long n, thePiecedim as long Xloc1, Yloc1, Xloc2, Yloc2dim as long fromPiece, toPiece// ASCII Board OverlayLPad=" " : RPad=""locate 0,0 : TEXT 22, 15, 0// default bgColour & fgColourbgB_board = 65535 : bgG_board = 54483 : bgR_board = 54199fgB_board = 0 : fgG_board = 0 : fgR_board = 0bgB_highlight = 0 : bgG_highlight = 42000 : bgR_highlight = 54199fgB_highlight = 65535 : fgG_highlight = 65535 : fgR_highlight = 65535// sanity check - don't display stuff that isnt thereif (numMoves < 1) or (moves.fromSquare(0) = moves.toSquare(0)) then exit fn// grab moves to processfor n=0 to numMoves-1'convert from index to xy coordinatesx1 = fn sq2X(moves.fromSquare(n)) +1y1 = fn sq2Y(moves.fromSquare(n)) +1x2 = fn sq2X(moves.toSquare(n)) +1y2 = fn sq2Y(moves.toSquare(n)) +1fromPiece = board.square[moves.fromSquare(n)]toPiece = board.square[moves.toSquare(n)]'and then translate board coords into screen coords Xloc1 = ((x1-1)*4)+1 + len(LPad) Yloc1 = 17-(y1*2) Xloc2 = ((x2-1)*4)+1 + len(LPad) Yloc2 = 17-(y2*2)//window #2 : print "Sq xy XYloc: "; moves.toSquare(n), x2; " "; y2, Xloc2; " "; Yloc2 : window #1// display the square (with its existing piece) in the highlight colour  LONG COLOR bgB_highlight, bgG_highlight, bgR_highlight, _false  LONG IF (fromPiece < 0) or (toPiece < 0)     LONG COLOR fgB_wPiece, fgG_wPiece, fgR_wPiece, _true    xelse     LONG COLOR fgB_bPiece, fgG_bPiece, fgR_bPiece, _true  END IF thePiece = abs( board.square[moves.fromSquare(n)] ) locate Xloc1, Yloc1 if thePiece = 0 then print "   "; if thePiece = 1 then print " P ";  if thePiece = 2 then print " B ";  if thePiece = 3 then print " N ";  if thePiece = 4 then print " R ";  if thePiece = 5 then print " Q ";  if thePiece = 6 then print " K ";  thePiece = abs( board.square[moves.toSquare(n)] ) locate Xloc2, Yloc2 if thePiece = 0 then print "   "; if thePiece = 1 then print " P ";  if thePiece = 2 then print " B ";  if thePiece = 3 then print " N ";  if thePiece = 4 then print " R ";  if thePiece = 5 then print " Q ";  if thePiece = 6 then print " K "; // reset to board colours after the operation going out LONG COLOR bgB_board, bgG_board, bgR_board, _false LONG COLOR fgB_board, fgG_board, fgR_board, _truenext nend fnLOCAL FN displayBoard(board as ^boardRecord)select case gBoardStylecase 0 : fn cheqBoard(board)case 1 : fn asciiBoard(board)end selectEND FNLOCAL FN displayOverlay(board as ^boardRecord, moves(_maxMoves) as moveRecord, numMoves as long, overlayInfo as boolean)long if (numMoves > 0)select case gBoardStylecase 0 : FN cheqOverlay(board, moves(0), numMoves, overlayInfo)case 1 : FN asciiOverlay(board, moves(0), numMoves)end selectend ifEND FNlocal fn audioBrainz(theMove as ^moveRecord, moveScore as long)// sound pitch, duration, volume, aSync  (negative pitch = note instead of frequency)// depth5 FEN: r1b1nrk1/pp3p1p/4p1p1/1P6/1PN5/4P3/4NPPP/R2R2K1 b -sound -noteTable(theMove.fromSquare), 1,,_falsesound -noteTable(theMove.toSquare), rnd(4),,_trueend fn// VISUAL BRAIN 1.0local fn visualBrainz(theMove as ^moveRecord)dim as long xStartAdj, yStartAdjdim as long cellX, cellY, xMax, yMaxdim as long x1, y1, x2, y2dim as long Xloc1, Yloc1, Xloc2, Yloc2dim as single colourR, colourG, colourB//coord values for the 48pt CHEQ font/*xStartAdj = 20 : yStartAdj = 20  cellX = 52 : cellY = 52  xMax = 415 : yMax = 415  */// coord values for the 58pt CHEQ font  xStartAdj = 20 : yStartAdj = 20  cellX = 64 : cellY = 64  xMax = 512 : yMax = 512//convert from index to xy coordinates  x1 = fn sq2X(theMove.fromSquare) +1  y1 = fn sq2Y(theMove.fromSquare) +1  x2 = fn sq2X(theMove.toSquare) +1  y2 = fn sq2Y(theMove.toSquare) +1long if gFlip = _false//and then translate board coords into screen coords  Xloc1 = xStartAdj + (x1-1) * cellX +1     '+2 = width of grid  Yloc1 = yStartAdj + (9*cellY) - ((y1+1)*cellY) -5     '-4 for the baseline bug  Xloc2 = xStartAdj + (x2-1) * cellX +1     '+2 = width of grid  Yloc2 = yStartAdj + (9*cellY) - ((y2+1)*cellY) -5     '-4 for the baseline bug//and make them aim at the centre of the cells  Xloc1 = Xloc1 + cellX/2 : Yloc1 = Yloc1 + cellY/2  Xloc2 = Xloc2 + cellX/2 : Yloc2 = Yloc2 + cellY/2xelse  Xloc1 = xStartAdj + ((9-x1)-1) * cellX +1     '+2 = width of grid  Yloc1 = yStartAdj + (9*cellY) - ((9-y1)*cellY) -5     '-4 for the baseline bug  Xloc2 = xStartAdj + ((9-x2)-1) * cellX +1     '+2 = width of grid  Yloc2 = yStartAdj + (9*cellY) - ((9-y2)*cellY) -5     '-4 for the baseline bug//and make them aim at the centre of the cells  Xloc1 = Xloc1 + cellX/2 : Yloc1 = Yloc1 - cellY/2  Xloc2 = Xloc2 + cellX/2 : Yloc2 = Yloc2 - cellY/2end if// the lovely linesfn QuartzSetLineWidth( _brainWidth )  colourB = 65535-(32768-theMove.moveScore*900)  colourG = 57343  colourR = 65535-(32768+theMove.moveScore*900)fn QuartzSetQDLongColor( colourB, colourG, colourR )fn QuartzLine( Xloc1, Yloc1, Xloc2, Yloc2 )//LONG COLOR 65535-(32768+(-theMove.moveScore*900)), 65535-8192, 65535-(32768+(theMove.moveScore*900)), _true     'FG (_true)//pensize(_brainWidth, _brainWidth)//moveto (Xloc1, Yloc1)//lineto (Xloc2, Yloc2)//reset ourselves to default colours after the operation going out  LONG COLOR bgB_board, bgG_board, bgR_board, _false  LONG COLOR fgB_board, fgG_board, fgR_board, _trueend fnlocal fn mouseTrapdim mAct as shortdim as point start, finishdim as moveRecord theMove, debugMoves(_maxMoves)dim as short xStartAdj, yStartAdj, cellX, cellY, xMax, yMaxdim as short xStart, yStart, x1, y1, x2, y2dim as short colStart, rowStart, colFinish, rowFinishdim as str255 moveStr// grab the actual mouse coordinatesmAct = mouse(0) 'Clear the QueueGetMouse(start)'Get Mouse Position//plot start.h, start.vxStart = start.hyStart = start.vxStartAdj = 0 : yStartAdj = 0cellX = 0 : cellY = 0 : xMax = 0 : yMax = 0select case gBoardStylecase 0// these values are for CHEQ (fontID=14558) @ 48pt/*xStartAdj = 20 : yStartAdj = 20  cellX = 52 : cellY = 52  xMax = 415 : yMax = 415 */// coord values for the 58pt CHEQ fontxStartAdj = 20 : yStartAdj = 20cellX = 64 : cellY = 64xMax = 512 : yMax = 512case 1//these values are for Courier (fontID=22) @ 15ptxStartAdj = 13 : yStartAdj = 11cellX = 36 : cellY = 30xMax = 287 : yMax = 240end selectx1 = xStart - xStartAdj : y1 = yStart - yStartAdjif x1 < 1 or x1 > xMax then exit fnif y1 < 1 or y1 > yMax then exit fncolStart = (x1/cellX)+1rowStart = (((yMax+1)-y1)/cellY)+1long if gFlip = _truecolStart = (9 - colStart)rowStart = (9 - rowStart)end iftheMove.fromSquare = ( ((rowStart-1)*8) + colStart ) - 1theMove.toSquare = theMove.fromSquare     'dummy value before we know wheretheMove.capturePiece = 0 : theMove.moveScore = 0// display overlay of the mouseDown clicklong if _dispEchoSpace = _Truefn displayBoard(gameBoards(gDispCount))debugMoves(0) = theMove fn displayOverlay(gameBoards(gDispCount), debugMoves(0), 1, _true )end ifwhile fn StillDown'draw only while mouse is downGetMouse(finish)'get mouse down positionlong if finish <> startstart = finish//uncomment the next line for free etch-a-sketch//plot to finish.h, finish.vend ifwend// convert xyStart & xyFinish cordinates in row x colx2 = finish.h - xStartAdj : y2 = finish.v - yStartAdjif x2 < 1 or x2 > xMax then exit fnif y2 < 1 or y2 > yMax then exit fncolFinish = (x2/cellX)+1rowFinish = (((yMax+1)-y2)/cellY)+1long if gFlip = _truecolFinish = (9 - colFinish)rowFinish = (9 - rowFinish)end iftheMove.toSquare = ( ((rowFinish-1)*8) + colFinish ) - 1//window #2 : print "theMove.fromSquare: "; theMove.fromSquare; " row"; rowStart; " col"; colStart : window #1// if user just clicked a square without Drag, just show available moves. long if theMove.fromSquare = theMove.toSquaremoveStr = FN move2Algebraic(theMove)moveStr = left$(moveStr, 2)fn parseMove(moveStr)exit fnend if// otherwise, we have a fromSq and a toSq, lets make the move. :DmoveStr = FN move2Algebraic(theMove)FN parseMove(moveStr)end fnlocal fn addToHistorylong if (gDispCount < gMoveCount)gMoveCount = gDispCountfn copyBoard(gameBoards(gDispCount), gBoard)end ifend fnlocal fn firstMovefn speak("first move", 0)gDispCount = 0fn displayBoard(gameBoards(gDispCount))fn gameHistoryedit$(8) = "Ply: " + str$(gDispCount) + " of" + str$(gMoveCount) : edit$(9)=""end fnlocal fn lastMovedim as long numMovesdim as moveRecord moves(_maxMoves)fn speak("last move", 0)gDispCount = gMoveCountfn displayBoard(gameBoards(gDispCount))fn gameHistoryedit$(8) = "Ply: " + str$(gDispCount) + " of" + str$(gMoveCount) : edit$(9)=""edit$(8) = edit$(8) + chr$(13) + "Last Move" : edit$(9)=""// display the overlaynumMoves = 1 : moves(0) = gMoveList(gDispCount)fn displayOverlay(gameBoards(gDispCount), moves(0), numMoves, _false )end fnlocal fn prevMovedim as long numMovesdim as moveRecord moves(_maxMoves)dim as moveRecord brainMovelong if gDispCount > 0gDispCount--xelsefn speak("first move", 0)edit$(8) = "Ply: " + str$(gDispCount) + " of" + str$(gMoveCount)if ( _showHash ) then edit$(8) = edit$(8) + "  (Hash:" + fn hashBoard( gameBoards(gDispCount) ) + ")"edit$(8) = edit$(8) + chr$(13) + "First Move" : edit$(9)="" : exit fnend ifedit$(8) = "Ply: " + str$(gDispCount) + " of" + str$(gMoveCount)if ( _showHash ) then edit$(8) = edit$(8) + "  (Hash:" + fn hashBoard( gameBoards(gDispCount) ) + ")"fn speak(str$(gDispCount),0)fn displayBoard(gameBoards(gDispCount))// display the overlaylong if (gDispCount > 0)numMoves = 1 : moves(0) = gMoveList(gDispCount)fn displayOverlay(gameBoards(gDispCount), moves(0), numMoves, _false )end ifif (audioBrain = 1) and (gDispCount > 0) then brainMove = moves(0) : fn audioBrainz( brainMove, brainMove.moveScore )fn gameHistoryend fnlocal fn nextMovedim as long numMovesdim as moveRecord moves(_maxMoves)dim as moveRecord brainMovedim as boolean speakFlagdim as str255 dispMovespeakFlag = _falselong if gDispCount < gMoveCountgDispCount++xelseif (right$(edit$(8),9) = "Last Move") then speakFlag = _true : exit iffn speak("last move", 0)edit$(8) = "Ply: " + str$(gDispCount) + " of" + str$(gMoveCount)if ( _showHash ) then edit$(8) = edit$(8) + "  (Hash:" + fn hashBoard( gameBoards(gDispCount) ) + ")"edit$(8) = edit$(8) + chr$(13) + "Last Move"exit fnend iflong if (speakFlag = _false)edit$(8) = "Ply: " + str$(gDispCount) + " of" + str$(gMoveCount)if ( _showHash ) then edit$(8) = edit$(8) + "  (Hash:" + fn hashBoard( gameBoards(gDispCount) ) + ")"fn speak(str$(gDispCount),0)fn displayBoard(gameBoards(gDispCount))end if// display the overlaynumMoves = 1 : moves(0) = gMoveList(gDispCount)fn displayOverlay(gameBoards(gDispCount), moves(0), numMoves, _false )// bleep the blipif (audioBrain = 1) then brainMove = moves(0) : fn audioBrainz( brainMove, brainMove.moveScore )// if already at LAST, then speak what that move waslong if (speakFlag = _true)dispMove = fn move2Std( moves(0), gameBoards(gMoveCount - 1) )FN speakMove( dispMove, gameBoards(gDispCount-1) )speakFlag = _falseend iffn gameHistoryend fnlocal fn setNowgMoveCount = gDispCountfn copyBoard(gameBoards(gDispCount), gBoard)fn speak("Current game set to Ply " + str$(gMoveCount), 0)fn gameHistoryfn displayBoard(gBoard)edit$(8)="Current game set to Ply " + str$(gMoveCount)edit$(9)=""gDirtyFlag = _true     'this has not yet been savedend fnlocal fn dispCapturedPieces( board as ^boardRecord )dim as rect arectdim as long querySquare, pieceType, cursorLoc, zdim as long wP, wB, wN, wR, wQ, bP, bB, bN, bR, bQdim as long wPcapt, wBcapt, wNcapt, wRcapt, wQcaptdim as long bPcapt, bBcapt, bNcapt, bRcapt, bQcaptlong if (_displayCaptures == _true) and (gDebug == 1) wP=0: wB=0: wN=0: wR=0: wQ=0 : bP=0: bB=0: bN=0: bR=0: bQ=0wPcapt=0 : wBCapt=0 : wNcapt=0 : wRcapt=0 : wQcapt=0bPcapt=0 : bBCapt=0 : bNcapt=0 : bRcapt=0 : bQcapt=0// bigRect to blank out previous displaybgB_board = 55769 : bgG_board = 46260 : bgR_board = 46260LONG COLOR bgB_board, bgG_board, bgR_board, _trueCALL SetRect(arect, _captX0, _captY - _captHeight, _captXX, _captYY)CALL PaintRect(arect)#if _buildPPC == _falseTEXT gCheqFont, _CheqCaptureSize, 0#endif#if _buildPPC == _trueTEXT _CheqFont, _CheqCaptureSize, 0#endif// first, find out what is actually on the boardfor querySquare = 0 to 63pieceType = board.square[querySquare]select case pieceTypecase 1 : wP++case 2 : wB++case 3 : wN++case 4 : wR++case 5 : wQ++case -1 : bP++case -2 : bB++case -3 : bN++case -4 : bR++case -5 : bQ++end selectnext querySquare// display nothing if nothing is captured//if (( wP + wB + wN + wR + bP + bB + bN + bR + bQ ) == 0 ) then exit fn// then compute how many are capturedwPcapt=8-wP : wBCapt=2-wB : wNcapt=2-wN : wRcapt=2-wR : wQcapt=1-wQbPcapt=8-bP : bBCapt=2-bB : bNcapt=2-bN : bRcapt=2-bR : bQcapt=1-bQ//--display white captures--LONG COLOR fgB_bPiece, fgG_bPiece, fgR_bPiece, _true// wPawns in col X0cursorLoc = _captYfor z = 1 to 8if (z <= wPcapt)LONG COLOR fgB_bPiece, fgG_bPiece, fgR_bPiece, _trueelseLONG COLOR 42000, 42000, 42000end ifcall MoveTo (_captX0, cursorLoc)print "P";      'pawn ('peschke')cursorLoc = cursorLoc + _captHeightnext z// big white pieces in col X1cursorLoc = _captYfor z = 1 to 2if (z <= wBcapt)LONG COLOR fgB_bPiece, fgG_bPiece, fgR_bPiece, _trueelseLONG COLOR 42000, 42000, 42000end ifcall MoveTo (_captX1, cursorLoc)print "L";      'pawn ('peschke')cursorLoc = cursorLoc + _captHeightnext zfor z = 1 to 2if (z <= wNcapt)LONG COLOR fgB_bPiece, fgG_bPiece, fgR_bPiece, _trueelseLONG COLOR 42000, 42000, 42000end ifcall MoveTo (_captX1, cursorLoc)print "S";      'knightcursorLoc = cursorLoc + _captHeightnext zfor z = 1 to 2if (z <= wRcapt)LONG COLOR fgB_bPiece, fgG_bPiece, fgR_bPiece, _trueelseLONG COLOR 42000, 42000, 42000end ifcall MoveTo (_captX1, cursorLoc)print "T";      'rook ('turm')cursorLoc = cursorLoc + _captHeightnext zfor z = 1 to 1if (z <= wQcapt)LONG COLOR fgB_bPiece, fgG_bPiece, fgR_bPiece, _trueelseLONG COLOR 42000, 42000, 42000end ifcall MoveTo (_captX1, cursorLoc)print "Q";      'queencursorLoc = cursorLoc + _captHeightnext z//--display black captures--LONG COLOR fgB_wPiece, fgG_wPiece, fgR_wPiece, _true// bPawns in col X2cursorLoc = _captYfor z = 1 to 8if (z <= bPcapt)LONG COLOR fgB_wPiece, fgG_wPiece, fgR_wPiece, _trueelseLONG COLOR 42000, 42000, 42000end ifcall MoveTo (_captX2, cursorLoc)print "P";      'pawn ('peschke')cursorLoc = cursorLoc + _captHeightnext z// big black pieces in col X3cursorLoc = _captYfor z = 1 to 2if (z <= bBcapt)LONG COLOR fgB_wPiece, fgG_wPiece, fgR_wPiece, _trueelseLONG COLOR 42000, 42000, 42000end ifcall MoveTo (_captX3, cursorLoc)print "L";      'pawn ('peschke')cursorLoc = cursorLoc + _captHeightnext zfor z = 1 to 2if (z <= bNcapt)LONG COLOR fgB_wPiece, fgG_wPiece, fgR_wPiece, _trueelseLONG COLOR 42000, 42000, 42000end ifcall MoveTo (_captX3, cursorLoc)print "S";      'knightcursorLoc = cursorLoc + _captHeightnext zfor z = 1 to 2if (z <= bRcapt)LONG COLOR fgB_wPiece, fgG_wPiece, fgR_wPiece, _trueelseLONG COLOR 42000, 42000, 42000end ifcall MoveTo (_captX3, cursorLoc)print "T";      'rook ('turm')cursorLoc = cursorLoc + _captHeightnext zfor z = 1 to 1if (z <= bQcapt)LONG COLOR fgB_wPiece, fgG_wPiece, fgR_wPiece, _trueelseLONG COLOR 42000, 42000, 42000end ifcall MoveTo (_captX3, cursorLoc)print "Q";      'queencursorLoc = cursorLoc + _captHeightnext zend if// reset fonts and coloursLONG COLOR 65535, 65535, 65535, _true //white texttext _FontFace, _FontSize, 0     //return to normal styleend fnlocal FN gameHistorydim as long n, mvNumdim as long startN, startNumdim as str255 moveDisp1, moveDisp2dim as rect arectlong if (gDebug == 1) // bigRect to blank out previous historybgB_board = 55769 : bgG_board = 46260 : bgR_board = 46260LONG COLOR bgB_board, bgG_board, bgR_board, _trueCALL SetRect(arect, _histX0, _histY - _lineHeight, _histXX, _histYY)CALL PaintRect(arect)mvNum = 0 : startNum = 0if gDispCount = 0 then exit fn//if gameFEN<>"" then edit$(8)="FEN: " + gameFENTEXT _MonoFace, _MonoSize, 0LONG COLOR 65535, 65535, 65535, _true //white textlong if (gDispCount mod 2) = 1// gDispCount is ODD -- display ending with WHITEif gDispCount > 44 then startN = gDispCount-44 else startN = 1for n = startN to (gDispCount -1) step 2mvNum = int((n+1)/2)startNum = int((startN+1)/2)moveDisp1 = fn move2Std( gMoveList(n), gameBoards(n-1) )moveDisp2 = fn move2Std( gMoveList(n+1), gameBoards(n+0) )//call MoveTo (_histX0, _histY + (mvNum-startN)*_lineHeight )call MoveTo (_histX0, _histY + (mvNum-startNum)*_lineHeight )print right$(str$(mvNum), len(str$(mvNum))-1 ); "."; call MoveTo (_histX1, _histY + (mvNum-startNum)*_lineHeight )print moveDisp1; call MoveTo (_histX2, _histY + (mvNum-startNum)*_lineHeight )print moveDisp2;next nlong if (gDispCount > 1)// the end of an odd number of elements to displaycall MoveTo (_histX0, _histY + (mvNum-startNum+1)*_lineHeight )print right$(str$(mvNum+1), len(str$(mvNum+1))-1 ); "."; LONG COLOR 0, 42000, 54199, _true      //orange textLONG COLOR 28527, 23130, 19532, _true     //grey texttext _MonoFace, _MonoSize, 1moveDisp1 = fn move2Std( gMoveList(n), gameBoards(n-1) )call MoveTo (_histX1, _histY + (mvNum-startNum+1)*_lineHeight )print moveDisp1; call MoveTo (_histX2, _histY + (mvNum-startNum+1)*_lineHeight)print ".. ";     // (in orange)LONG COLOR 65535, 65535, 65535, _true //white texttext _FontFace, _FontSize, 0     //return to normal stylexelse// there is only one move to displaycall MoveTo (_histX0, _histY + (mvNum-startNum)*_lineHeight )print right$(str$(mvNum+1), len(str$(mvNum+1))-1 ); "."; LONG COLOR 0, 42000, 54199, _true      //orange textLONG COLOR 28527, 23130, 19532, _true     //grey texttext _MonoFace, _MonoSize, 1moveDisp1 = fn move2Std( gMoveList(n), gameBoards(n-1) )call MoveTo (_histX1, _histY + (mvNum-startNum)*_lineHeight )print moveDisp1; call MoveTo (_histX2, _histY + (mvNum-startNum)*_lineHeight)print ".. ";     // (in orange)LONG COLOR 65535, 65535, 65535, _true //white texttext _FontFace, _FontSize, 0     //return to normal styleend ifxelse// gDispCount is EVEN -- display ending with BLACKif gDispCount > 45 then startN = gDispCount-45 else startN = 1for n = startN to gDispCount step 2mvNum = int((n+1)/2)startNum = int((startN+1)/2)moveDisp1 = fn move2Std( gMoveList(n), gameBoards(n-1) )moveDisp2 = fn move2Std( gMoveList(n+1), gameBoards(n+0) )//call MoveTo (_histX0, _histY + (mvNum-startN)*_lineHeight )call MoveTo (_histX0, _histY + (mvNum-startNum)*_lineHeight )print right$(str$(mvNum), len(str$(mvNum))-1 ); "."; //call MoveTo (_histX1, _histY + (mvNum-startN)*_lineHeight )call MoveTo (_histX1, _histY + (mvNum-startNum)*_lineHeight )print moveDisp1; long if (n = gDispCount-1)LONG COLOR 0, 42000, 54199, _true      //orange textLONG COLOR 28527, 23130, 19532, _true     //grey texttext _FontFace, _FontSize, 1end if//call MoveTo (_histX2, _histY + (mvNum-startN)*_lineHeight )call MoveTo (_histX2, _histY + (mvNum-startNum)*_lineHeight )print  moveDisp2; "  "; LONG COLOR 65535, 65535, 65535, _true //return to white textnext ntext _FontFace, _FontSize, 0     //return to normal styleend ifend iffn dispCapturedPieces( gameBoards(gDispCount) )end fn#endif