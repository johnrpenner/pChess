/*===| peaBrain (pChess UCI Engine) |======================================// *  *  peaBrain 2.0 (UCI Engine for pChess) *  Released under the GNU Public License 2012 *  UCI Interface APIs written by: Robert Purves, 2012. *  Adapted by: John Roland Penner *  Created: October 13, 2011 (Toronto Island) *  Updated: July 30, 2012 *  */#if _buildAsUCIEngine == _true#if compilerVersion < 161compile shutdown "Needs FBtoC build 161 or later for correct inkey$ operation"#endif#if _logCommandsReceiveddim as FSSpec  gLogFilefn FSMakeFSSpec( system( _aplVRefNum ), system( _aplParID ), "pChess.log", @gLogFile )open "O", 99, @gLogFile#endif// default file name and versionoutput file "pChess.command" : override _versionString$ = "2.0"/*For best speed (assuming Intel), use the following build settings [RP]: [1] set 'Optimization' to Fastest[2] set 64-bit mode by putting -m64 in 'More compiler options'[3] for Core i5 and i7 CPU, append  -DHAS_POPCNT  to 'More compiler options'[4] for best clang build, 'Source-file combining' OFF and use -flto    -m64 -DHAS_POPCNT -flto*///===| UCI INCLUDES |=========================================================//include "CommandLineTool"_numMovesAssumedForTimeControl = 32_infiniteTime = 99999999// ms_lf$ = 10_tab = 9_lf = 10_cr = 13_space = 32begin globals  dim as str255 sCommandReceivedWhilePolling  dim as long gUCItime  dim as str255 gameFEN  dim as boolean gFischerend globals//===| INCLUDES |=============================================================//// TIMER INCLUDEinclude "Tlbx Timer.incl"// OPENING BOOKinclude resources "pBook.txt"// SOURCE FILE INCLUDESinclude "declares.incl"include "moves.incl"include "attacks.incl"include "eval.incl"include "search.incl"include "book.incl"//===| FUNCTIONS |============================================================//// AbortSearch FNs used by POLLING & TIMER Interupt Functions// setter (TIMER only)local fn ClearAbortSearchsAbortSearch = _falseend fn// setter (TIMER only)local fn SetAbortSearchsAbortSearch = _trueend fn// accessor (TIMER & UCIpolling)local fn IsSearchAbortedend fn = sAbortSearch// setter (UCIpolling only)local fn SetSearchAborted( state as Boolean )sAbortSearch = stateend fn// accessor (UCI Polling only)local fn CommandReceivedWhilePolling as Str255end fn = sCommandReceivedWhilePolling// setter (UCI Polling only)local fn SetUpPollForCommandsCommandReceivedWhilePolling[0] = 0fn SetSearchAborted( _false )end fn// accessor (TIMER in GUI only)local modelocal fn CheckForAbortSignalif inkey$=chr$(27) then fn SetAbortSearch     // ESC keyend fn// UCI strip spaces and tabslocal fn StripLeftWhiteSpace( s as Str255 ) as Str255'~'1while ( s[0] != 0 and (s[1] == _space or s[1] == _tab) )s = mid$( s, 2, 1 )wendend fn = s// UCI get first wordlocal fn FirstWord( s as Str255 ) as Str255'~'1dim as SInt32  js = fn StripLeftWhiteSpace( s )j = instr( 1, s, " " )if ( j ) then s = left$( s, j - 1 )end fn = s// UCI poll for Commandlocal fn UCIpollForCommand'~'1dim as Str255  character, commandcharacter = inkey$if ( character[0] == 0 ) then exit fndolong if ( character[1] == _cr or character[1] == _lf )#if _logCommandsReceivedprint #99, sCommandReceivedWhilePolling#endifcommand = fn FirstWord( sCommandReceivedWhilePolling )select commandcase "quit"fn quitPeacase "isready"print "readyok" + _lf$;case "stop"fn SetSearchAborted( _true )case "debug"case "ponderhit"end selectsCommandReceivedWhilePolling[0] = 0exit fnend ifsCommandReceivedWhilePolling += charactercharacter = inkey$until ( character[0] == 0 )end fn'~'5local modelocal fn Milliseconds as long // time in ms since prog startdim as UnsignedWide usbegin globalsdim as double Ê Ê Ê sProgStartTimeend globalslong if ( sProgStartTime == 0.0 )Microseconds( @us )sProgStartTime = 4294967296.0*us.hi + us.loend ifMicroseconds( @us )end fn = (4294967296.0*us.hi + us.lo - sProgStartTime)*1e-3local modelocal FN copyBoard( source as ^boardRecord, dest as ^boardRecord )//dest.previousBoard = source // if you needed a linked listblockMoveData( source, dest, sizeof( boardRecord ) )end fn// inName is name of file in stand-alone app's folder,// or in bundled app's Contents/Resources folderlocal fn FSSpecFromSupportFileName( inName as Str255, outSpec as ^FSSpec )dim as OSStatus          errdim as CFURLRef          urldim as FSRef             fsRefdim as CFStringRef       cfStrdim as Boolean           refOKerr = _fnfErrcfStr = fn CFStringCreateWithPascalString( _kCFAllocatorDefault, inName, _kCFStringEncodingMacRoman )url = fn CFBundleCopyResourceURL( fn CFBundleGetMainBundle(), cfStr, 0, 0 )CFRelease( cfStr )if ( url == 0 ) then exit fnrefOK = fn CFURLGetFSRef( url, @fsRef )CFRelease( url )if ( refOK ) then err = fn FSGetCatalogInfo( @fsRef,  0, #0, #0, #outSpec, #0 )end fn = err local FN timeAdd(tOne as str255, tTwo as str255) as str255dim as long totalStartSecs, totalEndSecs, totalSecsdim as long startSec, startMin, startHrdim as long endSec, endMin, endHrdim as long deltaHr, deltaMin, deltaSecdim dum as str255startHr = val(mid$(tOne,1,2))startMin = val(mid$(tOne,4,2))startSec = val(mid$(tOne,7,2))totalStartSecs = startSec + startMin*60 + startHr *3600endHr = val(mid$(tTwo,1,2))endMin = val(mid$(tTwo,4,2))endSec = val(mid$(tTwo,7,2))totalEndSecs = endSec + endMin*60 + endHr*3600totalSecs = totalStartSecs + totalEndSecsdeltaHr = int(totalSecs / 3600)deltaMin = int( (totalSecs - (deltaHr*3600)) / 60 )deltaSec = totalSecs - (deltaHr*3600) - (deltaMin*60)dum = right$(str$(deltaHr),len(str$(deltaHr))-1) + ":"long if deltaMin < 10dum = dum + "0" + right$(str$(deltaMin),len(str$(deltaMin))-1) + ":"xelsedum = dum + right$(str$(deltaMin),len(str$(deltaMin))-1) + ":"end iflong if deltaSec < 10dum = dum + "0" + right$(str$(deltaSec),len(str$(deltaSec))-1)xelsedum = dum + right$(str$(deltaSec),len(str$(deltaSec))-1)end ifif deltaHr < 10 then dum = "0" + dumend fn = dumlocal FN timeDelta(tStart as str255, tEnd as str255) as str255dim as long startSec, startMin, startHrdim as long endSec, endMin, endHrdim as long totalStartSecs, totalEndSecsdim as long delta, deltaHr, deltaMin, deltaSecdim dum as str255startHr = val(mid$(tStart,1,2))startMin = val(mid$(tStart,4,2))startSec = val(mid$(tStart,7,2))totalStartSecs = startSec + startMin*60 + startHr *3600endHr = val(mid$(tEnd,1,2))endMin = val(mid$(tEnd,4,2))endSec = val(mid$(tEnd,7,2))totalEndSecs = endSec + endMin*60 + endHr*3600// IF IT ROLLS PAST MIDNIGHT > WE ASSUME NEXT DAYlong if totalEndSecs > totalStartSecs delta = totalEndSecs - totalStartSecsxelsedelta = (86400-totalStartSecs)+ totalEndSecsend ifif totalEndSecs = totalStartSecs then delta = 0deltaHr = int(delta / 3600)deltaMin = int( (delta - (deltaHr*3600)) / 60 )deltaSec = delta - (deltaHr*3600) - (deltaMin*60)dum = right$(str$(deltaHr),len(str$(deltaHr))-1) + ":"long if deltaMin < 10dum = dum + "0" + right$(str$(deltaMin),len(str$(deltaMin))-1) + ":"xelsedum = dum + right$(str$(deltaMin),len(str$(deltaMin))-1) + ":"end iflong if deltaSec < 10dum = dum + "0" + right$(str$(deltaSec),len(str$(deltaSec))-1)xelsedum = dum + right$(str$(deltaSec),len(str$(deltaSec))-1)end ifif deltaHr < 10 then dum = "0" + dumend fn = dumlocal fn alphaCol(column as long)//returns ascii values for ABCDEFGHdim as long alphaColalphaCol = 32if column = 1 then alphaCol = 97if column = 2 then alphaCol = 98if column = 3 then alphaCol = 99if column = 4 then alphaCol = 100if column = 5 then alphaCol = 101if column = 6 then alphaCol = 102if column = 7 then alphaCol = 103if column = 8 then alphaCol = 104end fn = alphaCollocal FN colVal(a as str255)dim x as longx=-1if a="a" or a="A" then x=1if a="b" or a="B" then x=2if a="c" or a="C" then x=3if a="d" or a="D" then x=4if a="e" or a="E" then x=5if a="f" or a="F" then x=6if a="g" or a="G" then x=7if a="h" or a="H" then x=8end FN = xlocal FN move2Algebraic(theMove as ^moveRecord) as str255dim as str255 moveStrdim as long fromX, fromYdim as long toX, toYmoveStr = ""fromX = fn sq2X(theMove.fromSquare) +1fromY = fn sq2Y(theMove.fromSquare) +1toX = fn sq2X(theMove.toSquare) +1toY = fn sq2Y(theMove.toSquare) +1moveStr = chr$(fn alphaCol(fromX))moveStr = moveStr + chr$(fromY + 48)moveStr = moveStr + chr$(fn alphaCol(toX))moveStr = moveStr + chr$(toY + 48)end fn = moveStr// NOTE! you must feed move2Std a board from BEFORE the move has been made!// as it can not disambiguate a move when the piece has already been moved. // thus, you typically call with something like: // moveDisp1 = fn move2Std( gMoveList(n), gameBoards(n-1) )local FN move2Std(theMove as ^moveRecord, theBoard as ^boardRecord) as str255dim as str255 AlgebMove, StdMovedim as str255 buildStr, pieceStrdim as long pieceTypedim as long checkReturndim as long numMovesdim as moveRecord moves(_maxMoves)dim as str255 Algeb1, Algeb2, toStrdim as boardRecord checkBoarddim as boolean gPromoTempAlgebMove = fn move2Algebraic( theMove )long if (_stdNotation == _true)buildStr = ""pieceType = theBoard.square[theMove.fromSquare]select abs(pieceType)case 0 : pieceStr = ""case 1 : pieceStr = ""case 2 : pieceStr = "B"case 3 : pieceStr = "N"case 4 : pieceStr = "R"case 5 : pieceStr = "Q"case 6 : pieceStr = "K"end selectbuildStr = pieceStr// DISAMBIGUATION iF necessary. // example 1: the following fen should yield the move: Nbxc6// fen: rnbnkb1r/p1p2ppp/2B5/4N3/4P1q1/1PN5/P1PP1PPP/R2QKB1R b KQkq// example 2: the following fen should yield the move: Rcxe8// fen: 2r1N1r1/2pn1k2/Bp6/p2p2Pp/P1NP1p1P/1P3P2/8/2R3K1 b -// example 3: the move Nd7 is ambiguous, so it should be: Nbd7// fen: rnbqkb1r/pp3p1p/3p1np1/2pP4/8/2N5/PP1NPPPP/R1BQKB1R b KQkqtoStr = right$(AlgebMove, 2)numMoves = 0 : blockZero( moves(0), sizeof( moveRecord ) )numMoves = fn isTarget(theMove.toSquare, theBoard, moves(0), pieceStr )long if (numMoves > 1) and (abs(pieceType) > 1)Algeb1 = FN move2Algebraic( moves(0) )Algeb2 = FN move2Algebraic( moves(1) )// FILE [A..D] is the same, thus disambig with RANK[1..6]long if ( mid$(Algeb1, 1, 1) = mid$(Algeb2, 1, 1) )if theMove.fromSquare = moves.fromSquare(0) then buildStr = buildStr + mid$(Algeb1, 2, 1)if theMove.fromSquare = moves.fromSquare(1) then buildStr = buildStr + mid$(Algeb2, 2, 1)xelse// otherwise disambiguate with FILE[A..D]if theMove.fromSquare = moves.fromSquare(0) then buildStr = buildStr + mid$(Algeb1, 1, 1)if theMove.fromSquare = moves.fromSquare(1) then buildStr = buildStr + mid$(Algeb2, 1, 1)end ifend if// indicate CAPTURE with a 'x' (pawns will always disambiguate with a FILE[A..H] )if ( abs(pieceType) == 1) and ( theMove.capturePiece <> 0 ) then buildStr = left$(AlgebMove, 1) + "x"if ( abs(pieceType) > 1 ) and ( theMove.capturePiece <> 0 ) then buildStr = buildStr + "x"// destination square only comes after all the abovebuildStr = buildStr + toStr// test for check/mate/stale// disambiguation requires board BEFORE the move// check testing requires board AFTER the movecheckBoard = theBoardgPromoTemp = gPromotion : gPromotion = _falsefn makeMove ( checkBoard, theMove )// suffix pawn-queen promotion//if gPromotion = _true then buildStr = buildStr + "=Q"if gPromotion = _true then buildStr = buildStr + "q"gPromotion = gPromoTemp// throw away all the above finegaling if it is actually a castling move// yes, we had to do all the above finegaling, in order to get the fromPiece// BUG (fixed): e1g1 should NOT = O-O: R7/p2k4/1pn5/2p1p3/7r/8/P6P/4R2K w -if ((AlgebMove="e1g1") or (AlgebMove="e8g8")) and (abs(theBoard.square[theMove.fromSquare])=6) then buildStr="O-O"if ((AlgebMove="e1c1") or (AlgebMove="e8c8")) and (abs(theBoard.square[theMove.fromSquare])=6) then buildStr="O-O-O"// fischer castlingif (theBoard.fischer == _true) and (abs(theBoard.square[theMove.fromSquare])=6) and (abs(theBoard.square[theMove.toSquare])=4) and ( (theMove.toSquare = theBoard.rookSq1) or (theMove.toSquare = theboard.rookSq1+56) ) then buildStr="O-O-O"if (theBoard.fischer == _true) and (abs(theBoard.square[theMove.fromSquare])=6) and (abs(theBoard.square[theMove.toSquare])=4) and ( (theMove.toSquare = theBoard.rookSq2) or (theMove.toSquare = theboard.rookSq2+56) ) then buildStr="O-O"// suffix checkcheckReturn = fn checkTest(checkBoard)if checkReturn = 1 then buildStr = buildStr + "+"if checkReturn = 2 then buildStr = buildStr + "#"if checkReturn = 3 then buildStr = buildStr + "-"StdMove = buildStrxelseStdMove = AlgebMoveend ifend fn = StdMovelocal FN std2algebraic(StdMoveIn as str255, inBoard as ^boardRecord) as str255dim as boardRecord theBoarddim as str255 pieceType, AlgebMovedim as str255 fromStr, toStr, StdMovedim as long x1, y1dim as long strLengthdim as long numMoves, querySquaredim as moveRecord moves(_maxMoves)dim as str255 disAmbig, Algeb1, Algeb2// FEN: r2q1rk1/pp2ppbp/1np2np1/2Q3B1/3PP1b1/2N2N2/PP3PPP/3RKB1R w -AlgebMove = "" : StdMove = StdMoveInFN copyBoard(inBoard, theBoard)// trap castling movesif (StdMove="O-O") and (theBoard.who2move == 1) then AlgebMove="e1g1" : exit fnif (StdMove="O-O") and (theBoard.who2move == -1) then AlgebMove="e8g8" : exit fnif (StdMove="O-O-O") and (theBoard.who2move == 1) then AlgebMove="e1c1" : exit fnif (StdMove="O-O-O") and (theBoard.who2move == -1) then AlgebMove="e8c8" : exit fn// remove check suffixesstrLength = len(StdMove)while ( right$(StdMove, 1) = "+" ) or ( right$(StdMove, 1) = "#" )strLength --StdMove = left$(StdMove, strLength)wend// remove pawn promotion suffixif mid$(StdMove, len(StdMove)-1, 1) = "=" then StdMove = left$(StdMove, len(StdMove)-2)// strip it all down to find out the toStringfromStr = "" : toStr = right$(StdMove, 2)// it is a simple pawn movelong if len(StdMove)=2pieceType = "P"// algebraic string coming in > square[0-63] going out. x1 = fn colVal(mid$(toStr,1,1))y1 = val(mid$(toStr,2,1))if x1 < 1 or x1 > 8 then AlgebMove = "" : exit fnif y1 < 1 or y1 > 8 then AlgebMove = "" : exit fnblockZero( moves(0), sizeof( moveRecord ) )numMoves = 0 : querySquare = (x1-1) + (y1-1)*8numMoves = fn isTarget(querySquare, theBoard, moves(0), pieceType )if (numMoves = 1) then AlgebMove = FN move2Algebraic( moves(0) ) : exit fnend if// disambiguate pawn moves, and send them on into the regular parser// this should take in moves like: axb5, dxc4 --to be like this--> Paxb5, Pdxc4if (asc(mid$(StdMove, 1, 1)) > 96) and (asc(mid$(StdMove, 1, 1)) < 105) and (mid$(StdMove, 2, 1) = "x") then StdMove = "P" + StdMove// All Moves (expect simple pawn moves)long if ( len(StdMove) > 2 ) pieceType = mid$(StdMove, 1, 1)// algebraic toString coming in > querySquare[0-63] going out. x1 = fn colVal(mid$(toStr,1,1))y1 = val(mid$(toStr,2,1))if x1 < 1 or x1 > 8 then AlgebMove = "" : exit fnif y1 < 1 or y1 > 8 then AlgebMove = "" : exit fnblockZero( moves(0), sizeof( moveRecord ) )numMoves = 0 : querySquare = (x1-1) + (y1-1)*8numMoves = fn isTarget(querySquare, theBoard, moves(0), pieceType )if (numMoves = 1) then AlgebMove = FN move2Algebraic( moves(0) ) : exit fn// disambiguate here, before getting move2Algebraic()long if (numMoves = 2)// relies on the fact that it will be there if there is > 1 move!!disAmbig = mid$(StdMove, 2, 1)Algeb1 = FN move2Algebraic( moves(0) )Algeb2 = FN move2Algebraic( moves(1) )// disAmbig character is a FILE [a..h]long if (asc(disAmbig) > 96) and (asc(disAmbig) < 105) if disAmbig = mid$(Algeb1, 1, 1) then AlgebMove = Algeb1if disAmbig = mid$(Algeb2, 1, 1) then AlgebMove = Algeb2exit fnend if// disAmbig character is a RANK [1..8]long if (asc(disAmbig) > 48) and (asc(disAmbig) < 57) if disAmbig = mid$(Algeb1, 2, 1) then AlgebMove = Algeb1if disAmbig = mid$(Algeb2, 2, 1) then AlgebMove = Algeb2exit fnend ifend ifend ifend fn = AlgebMove// TRIM > removes leading and trailing spaces (brendan ferguson)local fn trim (trimStr as str255) as str255dim as long strLengthstrLength = len(trimStr)// remove leading spaceswhile left$(trimStr, 1) = " "strLength --trimStr = right$(trimStr, strLength)wend// remove trailing spaceswhile right$(trimStr, 1) = " "strLength --trimStr = left$(trimStr, strLength)wendend fn = trimStrlocal fn numElements(a as str255)dim as long z, numSpaces// remove preceeding and trailing spacesa = fn trim(a)long if (len(a) => 1 )numSpaces = 1for z=1 to len(a)if mid$(a,z,1) = " " then numSpaces++next zxelsenumSpaces = 0end ifend fn = numSpaces// FN getWords() ASSUMES there is exactly ONE SPACE between words!!local fn getWords( a as str255, words(_maxWords) as str255 )dim as long numWords, z, mark1, mark2mark1 = 1 : mark2 = 1numWords = 0for z=0 to _maxWordswords(z)=""next z// strip leading and trailing spacesa = fn trim(a)for z = 1 to len(a)long if mid$(a,z,1)=" " or z=len(a)long if z=len(a)mark2 = zwords(numWords) = mid$(a, mark1, mark2-mark1+1)numWords++mark1 = mark2+1xelsemark2 = zwords(numWords) = mid$(a, mark1, mark2-mark1)numWords++mark1 = mark2+1end ifend ifnext zend fn = numWordslocal fn bufferLineIndex( index as long )dim as long lineIdxif ( index < 1 ) then lineIdx = -1 : exit fnlineIdx = (index-1) / 255end fn = lineIdxlocal fn bufferCharIndex( index as long )end fn = ((index-1) mod 255) + 1// a stringBuffer version of the mighty mid$( a$, z, n ) we all know and love. local fn midBuffer( strBuffer as ^stringBuffer, start as long, length as long ) as str255dim as str255 outStr : outStr = ""dim as long z, bufLineIdx, bufCharIdx// sanity check#if _LogCommandsReceivedif (start + length - 1 > strBuffer.index ) then print #99, "** midBuffer exceeded ** " start, length, strBuffer.index : exit fn#endiffor z = start to start+lengthbufLineIdx = fn bufferLineIndex( z )bufCharIdx = fn bufferCharIndex( z )outStr += mid$( strBuffer.str[bufLineIdx], bufCharIdx, 1 )next zend fn = outStrlocal fn getBufferWords( UCIcmd as ^stringBuffer, words(_maxUCIwords) as str255 )dim as long numWords, z, mark1, mark2dim as long bufLineIdx, bufCharIdxdim as long loopynumWords = 0 : mark1 = 1 : mark2 = 1for z=0 to _maxUCIwordswords(z)=""next z// show the full buffer in the log#if _LogCommandsReceivedprint #99, "--|" UCIcmd.index " -->|";for loopy = 1 to UCIcmd.indexbufLineIdx = fn bufferLineIndex( loopy )bufCharIdx = fn bufferCharIndex( loopy )print #99, mid$( UCIcmd.str[bufLineIdx], bufCharIdx, 1 ); next loopyprint #99,  "|<--"#endif// strip a single trailing spacebufLineIdx = fn bufferLineIndex( UCIcmd.index )bufCharIdx = fn bufferCharIndex( UCIcmd.index )if mid$( UCIcmd.str[bufLineIdx], bufCharIdx, 1 ) = " " then UCIcmd.index = UCIcmd.index - 1for z = 1 to UCIcmd.indexbufLineIdx = fn bufferLineIndex( z )bufCharIdx = fn bufferCharIndex( z )long if ( mid$( UCIcmd.str[bufLineIdx], bufCharIdx, 1 ) = " " ) or (z = UCIcmd.index)long if (z = UCIcmd.index)mark2 = zwords(numWords) = fn midBuffer( UCIcmd, mark1, mark2-mark1+1 )words(numWords) = fn trim( words(numWords) )numWords++mark1 = mark2 + 1xelsemark2 = zwords(numWords) = fn midBuffer( UCIcmd, mark1, mark2-mark1 )words(numWords) = fn trim( words(numWords) )numWords++mark1 = mark2 + 1end ifend ifnext zend fn = numWords'~'1LOCAL FN initBoard_classic (board as ^boardRecord)dim as long n // initialize game statescomputerTime = "00:00:00"userTime = "00:00:00"userStart = time$gPromotion = _falsegMoveCount = 0gDispCount = gMoveCountgWho2Move = _whiteegDispFlip = _whiteegameChain = ""gameFEN = ""gFischer = _false// stuff to record the game history in gameBoards()blockZero( gameBoards(0), sizeof(boardRecord) )// zero out move historyblockZero( gMoveList(0), sizeof(moveRecord) )// clear out first movegMoveList.fromSquare(0) = _noSuchSquaregMoveList.toSquare(0) = _noSuchSquaregMoveList.capturePiece(0) = 0gMoveList.promoPiece(0) = 0gMoveList.moveScore(0) = 0blockZero( board, sizeof( boardRecord ) )board.who2move = _whiteeboard.halfMoves = 0board.enPassantSq = _noSuchSquareboard.fiftyCount = 0board.hashCode = 0board.fischer = _falseboard.rookSq1 = _noSuchSquareboard.rookSq2 = _noSuchSquareboard.wCastleKside = _true     'start out able to castleboard.wCastleQside = _true     'start out able to castleboard.bCastleKside = _true     'start out able to castleboard.bCastleQside = _true     'start out able to castleboard.wHasCastled = _falseboard.bHasCastled = _false//setup pawnsfor n = 0 to 7board.square[n+8] = 1board.square[n+48] = -1 next n//init Classicboard.square[0] = 4 : board.square[56] = -4board.square[1] = 3 : board.square[57] = -3board.square[2] = 2 : board.square[58] = -2board.square[3] = 5 : board.square[59] = -5board.square[4] = 6 : board.square[60] = -6board.square[5] = 2 : board.square[61] = -2board.square[6] = 3 : board.square[62] = -3board.square[7] = 4 : board.square[63] = -4// make initial entry into the PREV NEXT historygameBoards(gMoveCount) = gBoard//gDirtyFlag = _falseend fnLOCAL FN initBoard_fischer (board as ^boardRecord)dim as long zdim as long diceSlots(8)dim as long dice1, dice2, dice3, dice4, dice5dim as long wIndx, bIndxdim as long slot, spaceCountdim as long qIndx, n1Indx, n2Indxdim as long r1Indx, kIndx, r2Indx// initialize game statescomputerTime = "00:00:00"userTime = "00:00:00"userStart = time$gPromotion = _falsegMoveCount = 0gDispCount = gMoveCountgWho2Move = _whiteegDispFlip = _whiteegameFEN = ""gameChain = ""gFischer = _true// disable opening book (fischer cant use it)gUseBook=_false// stuff to record the game history in gameBoards()blockZero( gameBoards(0), sizeof(boardRecord) )// zero out move historyblockZero( gMoveList(0), sizeof(moveRecord) )// clear out first movegMoveList.fromSquare(0) = _noSuchSquaregMoveList.toSquare(0) = _noSuchSquaregMoveList.capturePiece(0) = 0gMoveList.promoPiece(0) = 0gMoveList.moveScore(0) = 0// zero out the boardblockZero( board, sizeof( boardRecord ) )board.who2move = _whiteeboard.halfMoves = 0board.enPassantSq = _noSuchSquareboard.fiftyCount = 0 board.wCastleKside = _false     //fischer cant castle (yet!) board.wCastleQside = _false board.wHasCastled = _true board.bCastleKside = _false board.bCastleQside = _false board.bHasCastled = _true// roll in the fischer board (method by: Hans Bodlaender)for z=1 to 8diceSlots(z)=0next z     //zip out the dice slotsdice1=rnd(4)     //white bishop//edit$(8) = edit$(8) + str$(dice1)wIndx = (2*dice1)     //diceSpace to boardSpacediceSlots(wIndx)=2     //fill the slot w/bishopdice2=rnd(4)     //black bishop//edit$(8) = edit$(8) + str$(dice2)bIndx = (2*dice2)-1     //diceSpace to boardSpacediceSlots(bIndx)=2     //fill the slot w/bishopdice3=rnd(6)      //queen//edit$(8) = edit$(8) + str$(dice3)slot=0 : spaceCount=0while spaceCount < dice3slot++if diceSlots(slot)=0 then spaceCount++wendqIndx=slotdiceSlots(qIndx)=5dice4=rnd(5)     //first knight//edit$(8) = edit$(8) + str$(dice4)slot=0 : spaceCount=0while spaceCount < dice4slot++if diceSlots(slot)=0 then spaceCount++wendn1Indx=slotdiceSlots(n1Indx)=3dice5=rnd(4)     //second knight//edit$(8) = edit$(8) + str$(dice5)slot=0 : spaceCount=0while spaceCount < dice5slot++if diceSlots(slot)=0 then spaceCount++wendn2Indx=slotdiceSlots(n2Indx)=3// remaining squares will be rook-king-rookspaceCount=0 : r1Indx=0 : kIndx=0 : r2Indx=0for slot = 1 to 8if diceSlots(slot)=0 and spaceCount=2 then r2Indx = slot : spaceCount++if diceSlots(slot)=0 and spaceCount=1 then kIndx = slot : spaceCount++if diceSlots(slot)=0 and spaceCount=0 then r1Indx = slot : spaceCount++next zdiceSlots(r1Indx) = 4diceSlots(kIndx) = 6diceSlots(r2Indx) = 4// assign the diceSlots to the boardArray()for z = 1 to 8  board.square[z-1] = diceSlots(z)  board.square[z+7] = 1  board.square[z+47] = -1   board.square[z+55] = -diceSlots(z)next z// make initial entry into the PREV NEXT historygameBoards(gMoveCount) = gBoard// setup game FEN stringgameFEN = fn toFEN//gDirtyFlag = _falseend fnlocal FN toFEN as str255dim as str255 fen, bf, a, kqdim as long x, y, z, repdim as long n, thePiecedim as boardRecord fenBoarddim as str255 wRookAside, wRookHside, bRookAside, bRookHsidefen="" : bf="" : kq="" : n=0// the user may expect to see a FEN of the currently displayed boardlong if (gMoveCount = gDispCount)fn copyBoard(gBoard, fenBoard)xelsefn copyBoard( gameBoards(gDispCount), fenBoard )end if// generate the Raw FENfor y = 8 to 1 step -1for x = 1 to 8n = (y*8 - (9-x))thePiece = fenBoard.square[n]if thePiece = 0 then bf = bf + "-"if thePiece = 1 then bf = bf + "P"if thePiece = 2 then bf = bf + "B"if thePiece = 3 then bf = bf + "N"if thePiece = 4 then bf = bf + "R"if thePiece = 5 then bf = bf + "Q"if thePiece = 6 then bf = bf + "K"if thePiece = -1 then bf = bf + "p"if thePiece = -2 then bf = bf + "b"if thePiece = -3 then bf = bf + "n"if thePiece = -4 then bf = bf + "r"if thePiece = -5 then bf = bf + "q"if thePiece = -6 then bf = bf + "k"next xif y>1 then bf = bf + "/"next y// compact the raw FEN to regular FENz=0 : rep=0while z < len(bf)rep = 0inc(z)a = mid$(bf, z, 1)long if a = "-" rep = 0 while mid$(bf, z + rep, 1) = "-"  inc(rep) wend z = z + (rep-1)xelse fen = fen + aend ifif (rep > 0) then fen = fen + right$(str$(rep), len(str$(rep))-1 )wend// set COLOUR TO MOVElong if fenBoard.who2move = 1fen = fen + " w"xelsefen = fen + " b"end if// set CASTLING options// classic castling optionslong if (fenBoard.fischer == _false)if fenBoard.wCastleKside = _true then kq = kq + "K"if fenBoard.wCastleQside = _true then kq = kq + "Q"if fenBoard.bCastleKside = _true then kq = kq + "k"if fenBoard.bCastleQside = _true then kq = kq + "q"if kq="" then kq="-"fen = fen + " " + kqend if// fischer castling optionslong if (fenBoard.fischer == _true)wRookAside = "" : wRookHside = "" : bRookAside = "" : bRookHside = ""// set the column identifiers against which we match castling-flags if (fenBoard.rookSq1 <> _noSuchSquare) then wRookAside = chr$(65+fenBoard.rookSq1)if (fenBoard.rookSq2 <> _noSuchSquare) then wRookHside = chr$(65+fenBoard.rookSq2)if (fenBoard.rookSq1 <> _noSuchSquare) then bRookAside = chr$(97+fenBoard.rookSq1)if (fenBoard.rookSq2 <> _noSuchSquare) then bRookHside = chr$(97+fenBoard.rookSq2)// set the actual FEN flagsif fenBoard.wCastleQside = _true then kq = kq + wRookAsideif fenBoard.wCastleKside = _true then kq = kq + wRookHsideif fenBoard.bCastleQside = _true then kq = kq + bRookAsideif fenBoard.bCastleKside = _true then kq = kq + bRookHsideif kq="" then kq="-"fen = fen + " " + kqend if// set enPassant squareif fenBoard.enPassantSq = _noSuchSquare then fen = fen + " -"if fenBoard.enPassantSq = 24 then fen = fen + " a3"if fenBoard.enPassantSq = 25 then fen = fen + " b3"if fenBoard.enPassantSq = 26 then fen = fen + " c3"if fenBoard.enPassantSq = 27 then fen = fen + " d3"if fenBoard.enPassantSq = 28 then fen = fen + " e3"if fenBoard.enPassantSq = 29 then fen = fen + " f3"if fenBoard.enPassantSq = 30 then fen = fen + " g3"if fenBoard.enPassantSq = 31 then fen = fen + " h3"if fenBoard.enPassantSq = 32 then fen = fen + " a6"if fenBoard.enPassantSq = 33 then fen = fen + " b6"if fenBoard.enPassantSq = 34 then fen = fen + " c6"if fenBoard.enPassantSq = 35 then fen = fen + " d6"if fenBoard.enPassantSq = 36 then fen = fen + " e6"if fenBoard.enPassantSq = 37 then fen = fen + " f6"if fenBoard.enPassantSq = 38 then fen = fen + " g6"if fenBoard.enPassantSq = 39 then fen = fen + " h6"end fn = fenlocal fn fromFEN(fen as str255)dim board as boardRecorddim as str255 a, bf, kq, colour2movedim as long x, y, zdim as long n// Fischer FEN Detection Variablesdim as long wKingSq, bKingSqdim as long wRookCounter, bRookCounterdim as long wRook(64), bRook(64)      // there should NEVER be >64 rooks!dim as long numWordsdim as str255 bEnd, words(_maxWords)// initialize game statescomputerTime = "00:00:00"userTime = "00:00:00"userStart = time$gPromotion = _falsegMoveCount = 0gDispCount = gMoveCountgameFEN = fengameChain = ""gFischer = _true// Fischer FEN detection variables :: initializebKingSq = _noSuchSquare : wKingSq = _noSuchSquarewRook(0) = _noSuchSquare : wRook(1) = _noSuchSquarebRook(0) = _noSuchSquare : bRook(1) = _noSuchSquarewRookCounter = 0 : bRookCounter = 0// disable opening bookgUseBook=_false// stuff to record the game history in gameBoards()blockZero( gameBoards(0), sizeof(boardRecord) )// zero out move historyblockZero( gMoveList(0), sizeof(moveRecord) )// clear out first movegMoveList.fromSquare(0) = _noSuchSquaregMoveList.toSquare(0) = _noSuchSquaregMoveList.capturePiece(0) = 0gMoveList.promoPiece(0) = 0gMoveList.moveScore(0) = 0blockZero( board, sizeof( boardRecord ) )board.who2move = _whiteeboard.halfMoves = 0board.enPassantSq = _noSuchSquareboard.fiftyCount = 0board.hashCode = 0board.fischer = _trueboard.rookSq1 = _noSuchSquareboard.rookSq2 = _noSuchSquareboard.wCastleKside = _false     //cant castle unless FEN allows itboard.wCastleQside = _falseboard.wHasCastled  = _trueboard.bCastleKside = _falseboard.bCastleQside = _falseboard.bHasCastled  = _truea="" : bf="" : colour2move=""// break down the FEN into word elementsnumWords = fn getWords( fen, words(0) )// and expand the FEN$ into raw FENfor z = 1 to len( words(0) )a = mid$(fen, z, 1)long if val(a) > 0bf = bf + string$(val(a),"-")xelsebf = bf + aend ifnext z// maintaining the end part in original formbEnd = right$( fen, len(fen) - 72 )bf = bf + " " + bEnd// then drop the raw FEN into the boardRecordz = 1for y = 8 to 1 step -1for x = 1 to 8a = mid$(bf, z, 1)n = (y*8 - (9-x))if a="-" then board.square[n] = 0if a="P" then board.square[n] = 1if a="B" then board.square[n] = 2if a="N" then board.square[n] = 3if a="R" then board.square[n] = 4 : wRook(wRookCounter) = n : wRookCounter++if a="Q" then board.square[n] = 5if a="K" then board.square[n] = 6 : wKingSq = nif a="p" then board.square[n] = -1if a="b" then board.square[n] = -2if a="n" then board.square[n] = -3if a="r" then board.square[n] = -4 : bRook(bRookCounter) = n : bRookCounter++if a="q" then board.square[n] = -5if a="k" then board.square[n] = -6 : bKingSq = nz++next xz++next y// use info garnered above to setup for FISCHER FEN decodingif (wRookCounter > 0) and (wRook(0) < wKingSq) then board.rookSq1 = wRook(0) else board.rookSq2 = wRook(0)if (wRookCounter > 1) and (wRook(wRookCounter-1) > wKingSq) then board.rookSq2 = wRook(wRookCounter-1) else board.rookSq1 = wRook(wRookCounter-1)if (bRookCounter > 0) and (bRook(0) < bKingSq) then board.rookSq1 = bRook(0) - 56 else board.rookSq2 = bRook(0) - 56if (bRookCounter > 1) and (bRook(bRookCounter-1) > bKingSq) then board.rookSq2 = bRook(bRookCounter-1) - 56 else board.rookSq1 = bRook(bRookCounter-1) - 56// set colour to movelong if ( numWords => 1 )colour2move = words(1)if colour2move = "w" or colour2move = "W" then board.who2move = 1 : gFlip = _falseif colour2move = "b" or colour2move = "b" then board.who2move = -1 : gFlip = _trueend if// set castling optionslong if ( numWords => 2 )kq = words(2)long if (kq = "-")board.wCastleKside = _falseboard.wCastleQside = _falseboard.bCastleKside = _falseboard.bCastleQside = _falseboard.wHasCastled = _trueboard.bHasCastled = _trueend if// classic castling assignmentsfor z = 1 to len(kq)if mid$(kq, z, 1) = "K" then board.wCastleKside = _true : board.wHasCastled = _falseif mid$(kq, z, 1) = "Q" then board.wCastleQside = _true : board.wHasCastled = _falseif mid$(kq, z, 1) = "k" then board.bCastleKside = _true : board.bHasCastled = _falseif mid$(kq, z, 1) = "q" then board.bCastleQside = _true : board.bHasCastled = _falsenext z// fischer castling assignments// rook squares relative to king determined from above FEN// FEN: bqnbrnkr/pppppppp/8/8/8/8/PPPPPPPP/BQNBRNKR w Eh -dim as str255 wRookAside, wRookHside, bRookAside, bRookHsidewRookAside = "" : wRookHside = "" : bRookAside = "" : bRookHside = ""// set the column identifiers against which we match castling-status bits. if (board.rookSq1 <> _noSuchSquare) then wRookAside = chr$(65+board.rookSq1)if (board.rookSq2 <> _noSuchSquare) then wRookHside = chr$(65+board.rookSq2)if (board.rookSq1 <> _noSuchSquare) then bRookAside = chr$(97+board.rookSq1)if (board.rookSq2 <> _noSuchSquare) then bRookHside = chr$(97+board.rookSq2)for z = 1 to len(kq)if mid$(kq, z, 1) = wRookAside then board.wCastleQside = _true : board.wHasCastled = _falseif mid$(kq, z, 1) = wRookHside then board.wCastleKside = _true : board.wHasCastled = _falseif mid$(kq, z, 1) = bRookAside then board.bCastleQside = _true : board.bHasCastled = _falseif mid$(kq, z, 1) = bRookHside then board.bCastleKside = _true : board.bHasCastled = _falsenext zend if// decode enPassant square// For example, Pawn at c4 should have 2 possible moves: // 8/7p/p5pb/4k3/P1pPn3/8/P5PP/1rB2RK1 b - d3long if ( numWords => 3 )if words(3) = "-" then board.enPassantSq = _noSuchSquare : exit ifif words(3) = "a3" then board.enPassantSq = 24 : exit ifif words(3) = "b3" then board.enPassantSq = 25 : exit ifif words(3) = "c3" then board.enPassantSq = 26 : exit ifif words(3) = "d3" then board.enPassantSq = 27 : exit ifif words(3) = "e3" then board.enPassantSq = 28 : exit ifif words(3) = "f3" then board.enPassantSq = 29 : exit ifif words(3) = "g3" then board.enPassantSq = 30 : exit ifif words(3) = "h3" then board.enPassantSq = 31 : exit ifif words(3) = "a6" then board.enPassantSq = 32 : exit ifif words(3) = "b6" then board.enPassantSq = 33 : exit ifif words(3) = "c6" then board.enPassantSq = 34 : exit ifif words(3) = "d6" then board.enPassantSq = 35 : exit ifif words(3) = "e6" then board.enPassantSq = 36 : exit ifif words(3) = "f6" then board.enPassantSq = 37 : exit ifif words(3) = "g6" then board.enPassantSq = 38 : exit ifif words(3) = "h6" then board.enPassantSq = 39 : exit ifend if// assign result to the gBoardfn copyBoard(board, gBoard)userStart = time$// make initial entry into history and displaygMoveCount = 0 : gDispCount = 0gameBoards(gMoveCount) = gBoardgameFEN = fen// remember to set the gameFEN if there was one//gGame.gameFEN = fen//gGame.variant = "[Variant " + chr$(34) + "fischerandom" + chr$(34) + "]"// display the new board//fn displayBoard(gameBoards(gDispCount))//fn clearScreen//gDirtyFlag = _trueend fnlocal fn setupPosition( UCIcmd as ^stringBuffer )// parse strings like the following: // SIGMA Chess: position startpos moves e2e4 d7d5 d2d4 b8c6 g1f3 g8f6 f1b5// STOCKFISH 2: position fen rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 moves(8) e2e4 c7c5 f2f4 g7g6 g2g4 (13)// position..... moves(8) e2e4 c7c5 f2f4 g7g6 g2g4 (13)dim as long numWordsdim as str255 moveStr, words( _maxUCIwords )dim as long z, movePosdim as str255 fenStrfenStr = ""// break the position string into discrete wordsnumWords = fn getBufferWords( UCIcmd, words(0) )// assume the last move is the player's move being fed to us// moveStr = words(numWords-1)// fn userMove( moveStr ) : exit fn// find startpos or fen, and init board accordinglyselect words(1)case "startpos"fn initBoard_classic(gBoard)case "fen"fenStr = words(2) +" "+ words(3) +" "+ words(4) +" "+ words(5) +" "+ words(6) +" "+ words(7)fn fromFEN( fenStr )end select// find location of 'moves' within the position commandmovePos = 0for z = 0 to numWords-1if words(z) = "moves" then movePos = z : exit nextnext z// play out the game providedfor z = movePos+1 to numWords-1moveStr = words( z )fn userMove( moveStr )next z#if _logCommandsReceivedprint #99, "best move: " moveStr : print #99#endifend fn'~'2local FN quitPea#if _logCommandsReceivedclose #99#endif#if _buildAsUCIengineExitToShell() #endif#if _devLogfn e_xit( 0 ) // qdev version > quit at once!!#endifEND     // regular version of QUITend FN'~'2local fn infoToGUI ( moveIndex as long, dispMove as str255, depth as long, moveScore as long, nodes as long )dim as str255 UCIinfodim as long UCItimeNow, nodesSecdim as long hashFull// current movelong if (dispMove <> "")UCIinfo = "info currmove " + dispMove + " currmovenumber" + str$(moveIndex) + _lf$print UCIinfo;end ifUCItimeNow = fn MillisecondsnodesSec = (nodes / (UCItimeNow - gUCItime)) * 1000// find: not really accurate; need to get hash fully worknig first!! :-\hashFull = gNumPositionsSavedInHashTable / (_hashTableSize/50000)// depth score and nodesUCIinfo = "info score cp " + str$(moveScore) + " depth" + str$(depth) + " nodes" + str$(gNodes) + " nps" + str$(nodesSec) + " hashfull" + str$(hashFull) + _lf$print UCIinfo;end fn// UCI Chess Searchlocal fn UCIsearch as Str255dim as str255  moveStrgUCItime = fn MillisecondsmoveStr = "0000"moveStr = fn computerMove( gUseBook ) : exit fnwhile 1delay 5fn UCIpollForCommandif ( fn IsSearchAborted ) then exit fnwendend fn = moveStrlocal FN computerMove(useBookOpenings as boolean) as str255    // COMPUTER MAKES A MOVEdim as str255 moveStr, moveStd, bookStrdim as str255 startTime, endTime, elapsedTime//these are redeclared locally in computerSearch()dim as moveRecord theMovedim as str255 dispMovedim as moveRecord moves(_maxMoves)dim as long numMoves, checkFlag// TIMER Stufffn ClearAbortSearchfn SetupPollTime( 50, _false )// set up 50ms trap for ESC in Search()fn SetupPollTime2( gMaxEvalTime, _false ) // time limit setmoveStr="" : checkFlag = 0gMovesMade = 0 : gNodes = 0 : gqNodes = 0// CHECK THE OPENING BOOKlong if gUseBook = _truebookStr = FN pickBook(gameChain)     // gBookTitle gets set heremoveStr = FN std2algebraic( bookStr, gBoard )if moveStr <> "" then exit fnend if// GENERATE A MOVE WITH NEGAMAXlong if moveStr=""// is the Game Over? (return no move if it is)checkFlag = 0 : checkFlag = fn checkTest(gBoard)if checkFlag = 2 then exit fnif checkFlag = 3 then exit fn//edit$(8) = "NegaMax evaluating (depth" + str$(gDepth) + ").."startTime = time$// call NEGAMAX!!  :-)theMove = fn computerSearch( gBoard, gDepth )if (theMove.fromSquare = _noSuchSquare) or (theMove.toSquare = _noSuchSquare) then exit fnendTime = time$elapsedTime = fn timeDelta(startTime, endTime)// FIRST recording: generate an algebraic moveStr for the opening book..// but it is not actually involved in making the move. // **ONLY FOR PEA, moveStr IS the engine's actual output** :-D//moveStr = fn move2Std(theMove, gBoard) moveStr = fn move2Algebraic(theMove)gPromotion = _false : gInCheck = _false// MAKE the ACTUAL MOVE, and Display the BoardFN makeMove(gBoard, theMove)//FN displayBoard(gBoard)long if (gPromotion == _true)// this appendage to the moveStr is specific to UCI protocolmoveStr = moveStr + "q"gPromotion = _falseend if// SECOND recording: the Move into the gMoveList for the historygMoveList(gBoard.halfMoves) = theMove// THIRD: record the Move into the gameBoardsgMoveCount++ : gDispCount = gMoveCountgameBoards(gMoveCount) = gBoard// openingBook requires our move to be added to the gameChainlong if gameChain = "" gameChain = moveStdxelsegameChain = gameChain + " " + moveStdend ifuserStart = time$gBookTitle = ""end ifend FN = moveStrlocal FN userMove(moveStr as str255)dim as long x1, y1, x2, y2dim as long numMovesdim as moveRecord theMovedim as moveRecord moves(_maxMoves)dim as long checkFlagdim as str255 userEnd, elapsedTimedim as str255 dispMove, MoveStrStddim as long bookMatches// to play soundfile//dim as OSStatus err     //needed for sound fileblockZero( theMove, sizeof( moveRecord ) )blockZero( moves(0), sizeof( moveRecord ) )// algebraic string coming in > [0-63] going out. x1 = fn colVal(mid$(moveStr,1,1))y1 = val(mid$(moveStr,2,1))x2 = fn colVal(mid$(moveStr,3,1))y2 = val(mid$(moveStr,4,1))if x1 < 1 or x1 > 8 then exit fnif y1 < 1 or y1 > 8 then exit fnif x2 < 1 or x2 > 8 then exit fnif y2 < 1 or y2 > 8 then exit fn// Move TO MAKEtheMove.fromSquare = (x1-1) + (y1-1)*8theMove.toSquare = (x2-1) + (y2-1)*8theMove.capturePiece = gBoard.square[theMove.toSquare]theMove.moveScore = 0// used for the opening book comparisonmoveStrStd = fn move2Std(theMove, gBoard)gPromotion = _falseFN makeMove(gBoard, theMove)//FN displayBoard(gBoard)long if (gPromotion = _true)// play sound for promotiongPromotion = _falseend if// first: record the Move into the gMoveListgMoveList(gBoard.halfMoves) = theMove// second: record the Move into the gameBoardsgMoveCount++ : gDispCount = gMoveCountgameBoards(gMoveCount) = gBoard// third: record the Move into gameChain (to compare against opening book)long if gameChain = "" gameChain = moveStrStdxelsegameChain = gameChain + " " + moveStrStdend if// Update Status DisplaysdispMove = fn move2Std( theMove, gameBoards(gMoveCount - 1) )userEnd = time$ : elapsedTime = fn timeDelta(userStart, userEnd)userTime = fn timeAdd(elapsedTime, userTime)// show auxiliary debug infocomputerTime = fn timeAdd(computerTime, elapsedTime)gBookTitle = ""end fnLOCAL FN parseMove(moveStr as str255)dim as str255 fendim as long x1, y1, x2, y2dim as moveRecord editMovedim as moveRecord theMovedim as long z, testDepthdim as long editSquare, numLegaldim as long pieceType, pieceColourdim as str255 piecedim as long tmpX, tmpYdim as long perftDepthdim as long checkFlagdim as str255 tmpMovedim as long fromSquare, movePiecemoveStr = fn trim(moveStr)//if no move provided, then generate a move. long if moveStr="" or moveStr="go"moveStr = fn computerMove(gUseBook)exit fnend if// PARSE the incoming stringlong if left$(moveStr,3) = "fen" and len(moveStr)=3  fen = fn toFEN  exit fnend iflong if left$(moveStr,3) = "fen" and len(moveStr)=> 26fen = right$(moveStr, (len(moveStr)-4) )fn fromFEN(fen)exit fnend iflong if moveStr="new" or moveStr="classic"FN initBoard_classic(gBoard)exit fnend if long if moveStr="fischer"FN initBoard_fischer(gBoard)exit fnend ifif moveStr="white" then gBoard.who2move = 1if moveStr="black" then gBoard.who2move = -1long if len(moveStr)=7 and left$(moveStr, 5) = "depth"testDepth = val(right$(moveStr,1))if testDepth < 1 or testDepth > 9 then testDepth = 5//set the global search depthgDepth = testDepth     //change the DEPTHexit fnend ifif moveStr="book load" then FN loadBook : exit fnlong if moveStr = "book on" gUseBook=_trueexit fnend iflong if moveStr = "book off" gUseBook=_falseexit fnend ifIF moveStr="quit" or moveStr="exit" then fn quitPea// translate castling move (classical only; no fischer)if (moveStr = "OO" or moveStr = "O-O" or moveStr = "oo" or moveStr = "o-o") and gBoard.who2move = 1 then moveStr = "e1g1"if (moveStr = "OO" or moveStr = "O-O" or moveStr = "oo" or moveStr = "o-o") and gBoard.who2move = -1 then moveStr = "e8g8"if (moveStr = "OOO" or moveStr = "O-O-O" or moveStr = "ooo" or moveStr = "o-o-o") and gBoard.who2move = 1 then moveStr = "e1c1"if (moveStr = "OOO" or moveStr = "O-O-O" or moveStr = "ooo" or moveStr = "o-o-o") and gBoard.who2move = -1 then moveStr = "e8c8"// SAN (Standard Notation): prefix move with ( . ) to enter moves in Standard Notation// @StdMove - FEN: r2q1rk1/pp2ppbp/1np2np1/2Q3B1/3PP1b1/2N2N2/PP3PPP/3RKB1Rlong if (left$(moveStr, 1) = ".")FN userMove( FN std2algebraic(right$(moveStr, len(moveStr)-1), gBoard ) )exit fnend if// if none of the above, then we finally arrive at parsing the input as a MOVE. if len(moveStr)=4 then FN userMove(moveStr)END FNlocal fn initializedim as long z// Initialize Game Variables// piece names & weightsgPieceName(1) = "Pawn"   : gPieceWt(1) = _pawnWtgPieceName(2) = "Bishop" : gPieceWt(2) = _bishopWtgPieceName(3) = "Knight" : gPieceWt(3) = _knightWtgPieceName(4) = "Rook"   : gPieceWt(4) = _rookWtgPieceName(5) = "Queen"  : gPieceWt(5) = _queenWtgPieceName(6) = "King"   : gPieceWt(6) = _kingWt// WHITE PAWN TROPISM// as per: Tomasz Michniewski (Progszach)// ChessWiki > Simplified Evaluation Functiondata 0,  0,  0,  0,  0,  0,  0,  0 data 5, 10, 10,-20,-20, 10, 10,  5data 5, -5,-10,  0,  0,-10, -5,  5data 0,  0,  0, 20, 20,  0,  0,  0data 5,  5, 10, 25, 25, 10,  5,  5data 10, 10, 20, 30, 30, 20, 10, 10data 50, 50, 50, 50, 50, 50, 50, 50data  0,  0,  0,  0,  0,  0,  0,  0for z = 0 to 63read gWhitePawnTropism(z)next z// BLACK PAWN TROPSIMdata  0,  0,  0,  0,  0,  0,  0,  0data 50, 50, 50, 50, 50, 50, 50, 50data 10, 10, 20, 30, 30, 20, 10, 10data  5,  5, 10, 25, 25, 10,  5,  5data  0,  0,  0, 20, 20,  0,  0,  0data  5, -5,-10,  0,  0,-10, -5,  5data  5, 10, 10,-20,-20, 10, 10,  5data  0,  0,  0,  0,  0,  0,  0,  0for z = 0 to 63read gBlackPawnTropism(z)next z// WHITE KNIGHT TROPISM// as per: Tomasz Michniewski (Progszach)// ChessWiki > Simplified Evaluation Functiondata -40,-20,  0,  5,  5,  0,-20,-40data -30,  5, 10, 15, 15, 10,  5,-30data -30,  0, 15, 20, 20, 15,  0,-30data -30,  5, 15, 20, 20, 15,  5,-30data -30,  0, 10, 15, 15, 10,  0,-30data -30,  0, 10, 15, 15, 10,  0,-30data -40,-20,  0,  0,  0,  0,-20,-40data -50,-40,-30,-30,-30,-30,-40,-50for z = 0 to 63read gWhiteKnightTropism(z)next z// BLACK KNIGHT TROPSIMdata -50,-40,-30,-30,-30,-30,-40,-50data -40,-20,  0,  0,  0,  0,-20,-40data -30,  0, 10, 15, 15, 10,  0,-30data -30,  0, 10, 15, 15, 10,  0,-30data -30,  5, 15, 20, 20, 15,  5,-30data -30,  0, 15, 20, 20, 15,  0,-30data -30,  5, 10, 15, 15, 10,  5,-30data -40,-20,  0,  5,  5,  0,-20,-40for z = 0 to 63read gBlackKnightTropism(z)next z// sq2mask() transformation deltasdata 21, 22, 23, 24, 25, 26, 27, 28data 31, 32, 33, 34, 35, 36, 37, 38data 41, 42, 43, 44, 45, 46, 47, 48data 51, 52, 53, 54, 55, 56, 57, 58data 61, 62, 63, 64, 65, 66, 67, 68data 71, 72, 73, 74, 75, 76, 77, 78data 81, 82, 83, 84, 85, 86, 87, 88data 91, 92, 93, 94, 95, 96, 97, 98for z = 0 to 63read sq2Mask(z)next z// maskBoard() valuesdata -1,-1,-1,-1,-1,-1,-1,-1,-1,-1data -1,-1,-1,-1,-1,-1,-1,-1,-1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1, 1, 1, 1, 1, 1, 1, 1, 1,-1data -1,-1,-1,-1,-1,-1,-1,-1,-1,-1data -1,-1,-1,-1,-1,-1,-1,-1,-1,-1for z = 0 to 119read maskBoard(z)next z// King Tropism kZone2 Vectors (first set for 8x8; second set for 10x12)data 14, 15, 16, 17, 18, 10, 2, -6, -14, -15, -16, -17, -18, -10, -2, 6data 18, 19, 20, 21, 22, 12, 2, -8, -18, -19, -20, -21, -22, -12, -2, 8for z = 0 to 15read kZone2(z)next zfor z = 0 to 15read kZone220(z)next z// King Tropism kZone3 Vectors (first set for 8x8; second set for 10x12)data 7, 8, 9, 1, -7, -8, -9, -1, 0data 9, 10, 11, 1, -9, -10, -11, -1, 0for z = 0 to 8read kZone3(z)next zfor z = 0 to 8read kZone320(z)next z// Initialize Movement Vectors and Masks// wPawn Vectors & Masksdata 7, 9, 8, 16, -1, 1data 9, 11, 10, 20, -1, 1for z = 0 to 5read wPawnVect(z)next zfor z = 0 to 5read wPawnMask(z)next z// bPawn Vectors & Masksdata -9, -7, -8, -16, 1, -1data -11, -9, -10, -20, 1, -1for z = 0 to 5read bPawnVect(z)next zfor z = 0 to 5read bPawnMask(z)next z// bishop Vectors & Masksdata 7, 9, -7, -9data 9, 11, -9, -11for z = 0 to 3read bishopVect(z)next zfor z = 0 to 3read bishopMask(z)next z// knight Vectors & Masksdata 15, 17, 10, -6, -15, -17, -10, 6data 19, 21, 12, -8, -19, -21, -12, 8for z = 0 to 7read knightVect(z)next zfor z = 0 to 7read knightMask(z)next z// rook Vectors & Masksdata 8, 1, -1, -8data 10, 1, -1, -10for z = 0 to 3read rookVect(z)next zfor z = 0 to 3read rookMask(z)next z// king Vectors & Masksdata 7, 9, -7, -9, 8, -8, 1, -1data 9, 11, -9, -11, 10, -10, 1, -1for z = 0 to 7read kingVect(z)next zfor z = 0 to 7read kingMask(z)next z// pChess Pitch Table// IN: square 0..63 | eight note scale: A, Bb, B, C, D, E, F, G// OUT: sound pitch (negative values = notes instead of frequency)data 21, 22, 23, 24, 26, 28, 29, 31data 33, 34, 35, 36, 38, 40, 41, 43data 45, 46, 47, 48, 50, 52, 53, 55data 57, 58, 59, 60, 62, 64, 65, 67data 69, 70, 71, 72, 74, 76, 77, 79data 81, 82, 83, 84, 86, 88, 89, 91data 93, 94, 95, 96, 98, 100, 101, 103data 105, 106, 107, 108, 110, 112, 113, 115for z = 0 to 63read noteTable(z)next z// HASH: initialize the hash tablesfn initHashCodesend fnLOCAL FN initialize_UCI// INITIALIZE Variable Defaults from Preferences, and Set Menus  fn CFPrefsGetLong( "Book", @gUseBook, _gUseBook ) // if (gUseBook == 1) then menu 3,18,_checked else menu 3,18,_enable  fn CFPrefsGetLong( "Depth", @gDepth, _gDepth ) // menu 4,gDepth,_checked  gUseMoveSort = _useMoveSort  gUseQuiescence = _useQuiescence  gMaxEvalTime = _maxEvalTime  gBoardStyle = _boardStyle  gUCItime = fn Milliseconds// Load the OPENING BOOKif (gUseBook == _true) then FN loadBook// global variables for evaluationgWtTropism = _wtTropismgCastleBonus = _castleBonusgWtKingGravity = _wtKingGravitygWtPassedPawn = _wtPassedPawngWtDoubledPawn = _wtDoubledPawngWtKingShelter = _wtKingShelter// and start the gameFN initBoard_classic(gBoard)end fn//==| MAIN |======= FN initializeFN initialize_UCIdim as str255  command, firstWord, moveStr, moveCmddim as str255 cmdWords(_maxWords)dim as long numCmdWords, lineIndex, ndim as stringBuffer UCIcmddim as long UCIdepth, movesToGo, timeLimitblockZero( UCIcmd, sizeof(stringBuffer) )// UCI Command LoopdolineIndex = 0//zero out the UCIcmd line indexUCIcmd.index = 0input command#if _LogCommandsReceived  print #99, command#endif//firstWord = fn FirstWord( command )numCmdWords = fn getWords( command, cmdWords(0) )UCIcmd.str[lineIndex] = commandUCIcmd.index = command[0]// if position string >255, then load it into the UCIcmd Bufferlong if ( (cmdWords(0)="position") and (command[0] == 255 ) )while ( command[0] == 255 )lineIndex++input commandUCIcmd.str[lineIndex] = commandUCIcmd.index += command[0]wendend if// PARSE UCI COMMANDSselect cmdWords(0)case "uci"print "id name peaBrain " + _version$ + _lf$;print "id author John Roland Penner" + _lf$;print "option name UCI_EngineAbout type string default peaBrain 2.0 by John Roland Penner" + _lf$;print "option name Depth type string default 5" + _lf$;print "option name Book type check default true" + _lf$;print "option name UCI_Chess960 type check default false" + _lf$;print "uciok" + _lf$;case "isready"print "readyok" + _lf$;case "ucinewgame"FN initBoard_classic(gBoard)print "readyok" + _lf$;case "position"// parse strings like the following: // position startpos moves e2e4 d7d5 d2d4 b8c6 g1f3 g8f6 f1b5//fn setupPosition( command )fn setupPosition( UCIcmd )print "readyok" + _lf$;case "go"// go btime 418000 movestogo 56movesToGo = _numMovesAssumedForTimeControlUCIdepth ÊÊÊÊ= gDepth// parse subCommandsfor n = 1 to (numCmdWords-1)select cmdWords(n)Êcase "wtime" ÊÊÊÊ: timeLimit = val&( cmdWords(n+1) )Êcase "btime" ÊÊÊÊ: timeLimit = val&( cmdWords(n+1) )Êcase "movestogo" : movesToGo = val&( cmdWords(n+1) )Êcase "movetime" Ê: timeLimit = val&( cmdWords(n+1) ) : movesToGo = 1Êcase "depth" ÊÊÊÊ: UCIdepth  = val&( cmdWords(n+1) ) : timeLimit = _infiniteTime : movesToGo = 1Êcase "infinite" Ê: timeLimit = _infiniteTime : movesToGo = 1end selectnext n// Time ManagementtimeLimit = timeLimit*95/100/movesToGoif ( timeLimit == 0 ) then timeLimit = 100fn SetupPollTime2( timeLimit, _false )fn SetUpPollForCommandmoveStr = fn UCIsearchmoveCmd = "bestmove " + moveStr + _lf$print moveCmd;#if _LogCommandsReceivedprint #99, moveCmd#endifcase "setoption"// setoption name Depth value 5\nlong if (cmdWords(2) = "Depth")gDepth = val(cmdWords(4))end if#if _LogCommandsReceivedif (cmdWords(2) = "Depth") then print #99, "setoption | Depth set to:" val(cmdWords(4)) " ** "#endif// print "option name Book type check default true" + _lf$;long if (cmdWords(2) = "Book")if cmdWords(4) = "true" then gUseBook = _trueif cmdWords(4) = "false" then gUseBook = _falseend if// prit "option name UCI_Chess960 type check default false" + _lf$;long if (cmdWords(2) = "UCI_Chess960")if cmdWords(4) = "true" then gFischer = _trueif cmdWords(4) = "false" then gFischer = _falseend if#if _LogCommandsReceivedif (cmdWords(2) = "UCI_Chess960") then print #99, "setoption | UCI_Chess960 set to: " cmdWords(4) " ** "#endifcase "debug"case "ponderhit"end selectuntil ( cmdWords(0) == "quit" )fn quitPea#endif