// pChess 2.0// Move Generator v3.2 (vector-based generation with maskBounds)// Written By John Roland Penner <johnrolandpenner-at-gmail-dot-com>// This file is released under the GNU public license, 2011. // Created: March 22, 2010 (Toronto Island)// Updated as of: February 17, 2012local fn sq2X( index as long )end fn = index mod 8local fn sq2Y( index as long )  dim as long y   if ( index < 0 ) then y = -1 : exit fn  y = index/8end fn = ylocal fn wPawnMoves( theBoard as ^boardRecord, moves(_maxMoves) as moveRecord, numMoves as long, querySquare as long )dim as long moveIndex, pieceMoves, fromYdim as long testMask, newMask, testSquarepieceMoves = 0//pawn NW (captures)testMask = sq2Mask (querySquare)newMask = testMask + wPawnMask(0)testSquare = querySquare + wPawnVect(0)long if (maskBoard(newMask) = 1 )long if theBoard.square[testSquare] < 0//add pawnNW to the moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = testSquaremoves.capturePiece(moveIndex) = theBoard.square[testSquare]moves.moveScore(moveIndex) = 0pieceMoves++end ifend if//pawn NE (captures)testMask = sq2Mask (querySquare)newMask = testMask + wPawnMask(1)testSquare = querySquare + wPawnVect(1)long if (maskBoard(newMask) = 1 )long if theBoard.square[testSquare] < 0//add pawnNE to the moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = testSquaremoves.capturePiece(moveIndex) = theBoard.square[testSquare]moves.moveScore(moveIndex) = 0pieceMoves++end ifend if//pawn forward 1x (space)testMask = sq2Mask (querySquare)newMask = testMask + wPawnMask(2)testSquare = querySquare + wPawnVect(2)long if (maskBoard(newMask) = 1 )long if theBoard.square[testSquare] = 0//add pawnForward-1x to the moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = testSquaremoves.capturePiece(moveIndex) = 0moves.moveScore(moveIndex) = 0pieceMoves++end ifend if//pawn forward 2x (space)testMask = sq2Mask (querySquare)newMask = testMask + wPawnMask(3)testSquare = querySquare + wPawnVect(3)long if (maskBoard(newMask) = 1 )long if querySquare > 7 and querySquare < 16 and theBoard.square[testSquare] = 0 and theBoard.square[testSquare-8] = 0//add pawnForward-2x to the moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = testSquaremoves.capturePiece(moveIndex) = 0moves.moveScore(moveIndex) = 0pieceMoves++end ifend if//pawn enPassant-West (captures)testMask = sq2Mask (querySquare)newMask = testMask + wPawnMask(4)testSquare = querySquare + wPawnVect(4)fromY = fn sq2Y(querySquare)long if (maskBoard(newMask) = 1 )long if (fromY = 4) and (testSquare = theBoard.enPassantSq)//add enPassantWest to the moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = querySquare + 7 //legal cause Y=4 and enPasSq=onBoardmoves.capturePiece(moveIndex) = theBoard.square[testSquare]moves.moveScore(moveIndex) = 0pieceMoves++end ifend if//pawn enPassant-East (captures)testMask = sq2Mask (querySquare)newMask = testMask + wPawnMask(5)testSquare = querySquare + wPawnVect(5)fromY = fn sq2Y(querySquare)long if (maskBoard(newMask) = 1 )long if (fromY = 4) and (testSquare = theBoard.enPassantSq)//add enPassantEast to the moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = querySquare + 9 //legal cause Y=4 and enPasSq=onBoardmoves.capturePiece(moveIndex) = theBoard.square[testSquare]moves.moveScore(moveIndex) = 0pieceMoves++end ifend ifend fn = pieceMoveslocal fn bPawnMoves( theBoard as ^boardRecord, moves(_maxMoves) as moveRecord, numMoves as long, querySquare as long )dim as long moveIndex, pieceMoves, fromYdim as long testMask, newMask, testSquarepieceMoves = 0//black pawn SW (captures)testMask = sq2Mask (querySquare)newMask = testMask + bPawnMask(0)testSquare = querySquare + bPawnVect(0)long if (maskBoard(newMask) = 1 )long if theBoard.square[testSquare] > 0//add pawnSW to the moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = testSquaremoves.capturePiece(moveIndex) = theBoard.square[testSquare]moves.moveScore(moveIndex) = 0pieceMoves++end ifend if//black pawn SE (captures)testMask = sq2Mask (querySquare)newMask = testMask + bPawnMask(1)testSquare = querySquare + bPawnVect(1)long if (maskBoard(newMask) = 1 )long if theBoard.square[testSquare] > 0//add pawnSE to the moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = testSquaremoves.capturePiece(moveIndex) = theBoard.square[testSquare]moves.moveScore(moveIndex) = 0pieceMoves++end ifend if//black pawn forward 1x (space)testMask = sq2Mask (querySquare)newMask = testMask + bPawnMask(2)testSquare = querySquare + bPawnVect(2)long if (maskBoard(newMask) = 1 )long if theBoard.square[testSquare] = 0//add pawnForward-1x to the moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = testSquaremoves.capturePiece(moveIndex) = 0moves.moveScore(moveIndex) = 0pieceMoves++end ifend if//pawn forward 2x (space)testMask = sq2Mask (querySquare)newMask = testMask + bPawnMask(3)testSquare = querySquare + bPawnVect(3)long if (maskBoard(newMask) = 1 )long if querySquare > 47 and querySquare < 56 and theBoard.square[testSquare] = 0 and theBoard.square[testSquare+8] = 0//add pawnForward-2x to the moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = testSquaremoves.capturePiece(moveIndex) = 0moves.moveScore(moveIndex) = 0pieceMoves++end ifend if//pawn enPassant-East (captures)testMask = sq2Mask (querySquare)newMask = testMask + bPawnMask(4)testSquare = querySquare + bPawnVect(4)fromY = fn sq2Y(querySquare)long if (maskBoard(newMask) = 1 )long if (fromY = 3) and (testSquare = theBoard.enPassantSq)//add enPassantWest to the moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = querySquare - 7 //legal cause Y=3 and enPasSq=onBoardmoves.capturePiece(moveIndex) = theBoard.square[testSquare]moves.moveScore(moveIndex) = 0pieceMoves++end ifend if//pawn enPassant-West (captures)testMask = sq2Mask (querySquare)newMask = testMask + bPawnMask(5)testSquare = querySquare + bPawnVect(5)fromY = fn sq2Y(querySquare)long if (maskBoard(newMask) = 1 )long if fromY = 3 and testSquare = theBoard.enPassantSq//add enPassantWest to the moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = querySquare - 9 //legal cause Y=3 and enPasSq=onBoardmoves.capturePiece(moveIndex) = theBoard.square[testSquare]moves.moveScore(moveIndex) = 0pieceMoves++end ifend ifend fn = pieceMoveslocal fn bishopMoves( theBoard as ^boardRecord, moves(_maxMoves) as moveRecord, numMoves as long, querySquare as long, pieceColour as long )dim as long testSquare, moveIndexdim as long pieceMoves, pieceHitdim as long vectorCount, testMask, newMaskpieceMoves = 0for vectorCount = 0 to 3pieceHit = 0testSquare = querySquareDO//start by hitting ourselves onceif (pieceHit < 2) and ( (theBoard.square[testSquare] * pieceColour) > 0 ) then pieceHit++//bishop spacelong if (pieceHit < 2) and (theBoard.square[testSquare] = 0)moveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = testSquaremoves.capturePiece(moveIndex) = 0moves.moveScore(moveIndex) = 0pieceMoves++end if//bishop capturelong if (pieceHit < 2) and ( (theBoard.square[testSquare] * pieceColour) < 0 )pieceHit++moveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = testSquaremoves.capturePiece(moveIndex) = theBoard.square[testSquare]moves.moveScore(moveIndex) = 0pieceMoves++end if//set the next bishap vector and Do the Doodle Doo..testMask = sq2Mask(testSquare)newMask = testMask + bishopMask(vectorCount)testSquare = testSquare + bishopVect(vectorCount)until (piecehit=2) or (maskBoard(newMask) = -1 )next vectorCountend fn = pieceMoveslocal fn knightMoves( theBoard as ^boardRecord, moves(_maxMoves) as moveRecord, numMoves as long, querySquare as long, pieceColour as long )dim as long moveIndex, pieceMovesdim as long testMask, newMask, testSquare, vectorCountpieceMoves = 0for vectorCount = 0 to 7testMask = sq2Mask (querySquare)newMask = testMask + knightMask(vectorCount)testSquare = querySquare + knightVect(vectorCount)long if (maskBoard(newMask) = 1 )// the <1 allows for both knight capture and knight spacelong if ((theBoard.square[testSquare] * pieceColour) < 1)moveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = testSquaremoves.capturePiece(moveIndex) = theBoard.square[testSquare]moves.moveScore(moveIndex) = 0pieceMoves++end ifend ifnext vectorCountend fn = pieceMoveslocal fn rookMoves( theBoard as ^boardRecord, moves(_maxMoves) as moveRecord, numMoves as long, querySquare as long, pieceColour as long )dim as long testSquare, moveIndexdim as long pieceMoves, pieceHitdim as long vectorCount, testMask, newMaskpieceMoves = 0for vectorCount = 0 to 3pieceHit = 0testSquare = querySquareDO//start by hitting ourselves onceif (pieceHit < 2) and ( (theBoard.square[testSquare] * pieceColour) > 0 ) then pieceHit++//rook spacelong if (pieceHit < 2) and (theBoard.square[testSquare] = 0)moveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = testSquaremoves.capturePiece(moveIndex) = 0moves.moveScore(moveIndex) = 0pieceMoves++end if//rook capturelong if (pieceHit < 2) and ( (theBoard.square[testSquare] * pieceColour) < 0 )pieceHit++moveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = testSquaremoves.capturePiece(moveIndex) = theBoard.square[testSquare]moves.moveScore(moveIndex) = 0pieceMoves++end if//set the next rook vector and Do the Doodle Doo..testMask = sq2Mask(testSquare)newMask = testMask + rookMask(vectorCount)testSquare = testSquare + rookVect(vectorCount)until (piecehit=2) or (maskBoard(newMask) = -1 )next vectorCountend fn = pieceMoveslocal fn wKingMoves( theBoard as ^boardRecord, moves(_maxMoves) as moveRecord, numMoves as long, querySquare as long )dim as long moveIndex, pieceMovesdim as long testMask, newMask, testSquare, vectorCountdim as boolean sqAttacked1, sqAttacked2, sqAttacked3dim as long n, kingSq, holder(8)dim as boolean wKside, wQsidepieceMoves = 0for vectorCount = 0 to 7testMask = sq2Mask (querySquare)newMask = testMask + kingMask(vectorCount)testSquare = querySquare + kingVect(vectorCount)long if (maskBoard(newMask) = 1 )// the <1 allows for both king capture and king spacelong if (theBoard.square[testSquare] < 1)moveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = testSquaremoves.capturePiece(moveIndex) = theBoard.square[testSquare]moves.moveScore(moveIndex) = 0pieceMoves++end ifend ifnext vectorCountlong if (theBoard.fischer == _false)//king wCastleKside (classic)long if (querySquare = 4) and (theBoard.square[4]=6) and (theBoard.square[5]=0) and (theBoard.square[6]=0) and (theBoard.square[7]=4) and (theBoard.wCastleKside = _true)// setup dummy pieces for testSquares (and we could not get here if they were not empty!)theBoard.square[5] = 1theBoard.square[6] = 1theBoard.who2move = -theBoard.who2move// cant castle through check!!sqAttacked1 = fn isAttacked( 5, theBoard )sqAttacked2 = fn isAttacked( 6, theBoard )sqAttacked3 = _falselong if ( (sqAttacked1 == _false) and (sqAttacked2 == _false) and (gInCheck = _false) )// add wCastleKside to moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = 6moves.capturePiece(moveIndex) = 0moves.moveScore(moveIndex) = 0pieceMoves++end iftheBoard.square[5] = 0theBoard.square[6] = 0theBoard.who2move = -theBoard.who2moveend if//king wCastleQside (classic)long if (querySquare = 4) and (theBoard.square[4]=6) and (theBoard.square[3]=0) and (theBoard.square[2]=0) and (theBoard.square[1]=0) and (theBoard.square[0]=4) and (theBoard.wCastleQside = _true)// setup dummy pieces for testSquares (and we could not get here if they were not empty!)theBoard.who2move = -theBoard.who2movetheBoard.square[1] = 1theBoard.square[2] = 1theBoard.square[3] = 1// cant castle through check!!sqAttacked1 = fn isAttacked( 1, theBoard )sqAttacked2 = fn isAttacked( 2, theBoard )sqAttacked3 = fn isAttacked( 3, theBoard )long if ( (sqAttacked1 == _false) and (sqAttacked2 == _false) and (sqAttacked3 == _false) and (gInCheck = _false) )// add wCastleQside to moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = 2moves.capturePiece(moveIndex) = 0moves.moveScore(moveIndex) = 0pieceMoves++end iftheBoard.who2move = -theBoard.who2movetheBoard.square[1] = 0theBoard.square[2] = 0theBoard.square[3] = 0end ifend if// FISCHER CASTLING// FEN1: 2rk1r2/pppppppp/8/8/8/8/PPPPPPPP/2RK1R2 w CFcf -// FEN2: bbqrkrnn/pppppppp/8/8/8/8/PPPPPPPP/BBQRKRNN w DFdf - // determine kingSqkingSq = _noSuchSquarelong if (theBoard.fischer == _true) and (querySquare>0) and (querySquare<7) and (theBoard.square[querySquare]=6)kingSq = querySquareend if// fischer wCastleKsidelong if (theBoard.fischer == _true) and (kingSq <> _noSuchSquare) and (gInCheck = _false) and (theBoard.wCastleKside = _true)wKside = _true// determine if castle squares are emptyif (theBoard.square[5]<>6) and (theBoard.square[5]<>4) and (theBoard.square[5]<>0) then wKside = _falseif (theBoard.square[6]<>6) and (theBoard.square[6]<>4) and (theBoard.square[6]<>0) then wKside = _false// determine if squares between kingSq and rookSq2 are empty??for n = kingSq to theBoard.rookSq2if (theBoard.square[n]<>6) and (theBoard.square[n]<>4) and (theBoard.square[n]<>0) then wKside = _false : exit nextnext n// if we made it, HOLD the squares & SWAP who2movelong if (wKside)for n = kingSq to theBoard.rookSq2holder(n) = theBoard.square[n]theBoard.square[n] = 1next ntheBoard.who2move = -theBoard.who2move// and see if any of the squares are attacked (including CHECK!!)for n = kingSq to theBoard.rookSq2if (fn isAttacked(n,theBoard)) then wKside = _false : exit nextnext n// if we made it up to here > only then can we castle. long if (wKside)// add wCastleKside to moveList (king takes Kside ROOK!)moveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = theBoard.rookSq2moves.capturePiece(moveIndex) = 0moves.moveScore(moveIndex) = 0pieceMoves++end if// restore order to the universefor n = kingSq to theBoard.rookSq2theBoard.square[n] = holder(n)next ntheBoard.who2move = -theBoard.who2moveend ifend if// fischer  wCastleQsidelong if (theBoard.fischer == _true) and (kingSq <> _noSuchSquare) and (gInCheck = _false) and (theBoard.wCastleQside = _true)wQside = _true// determine if castle squares are emptyif (theBoard.square[2]<>6) and (theBoard.square[2]<>4) and (theBoard.square[2]<>0) then wQside = _falseif (theBoard.square[3]<>6) and (theBoard.square[3]<>4) and (theBoard.square[3]<>0) then wQside = _false// determine if squares between kingSq and rookSq2 are empty??for n = kingSq to theBoard.rookSq1 step -1if (theBoard.square[n]<>6) and (theBoard.square[n]<>4) and (theBoard.square[n]<>0) then wQside = _false : exit nextnext n// if we made it, HOLD the squares & SWAP who2movelong if (wQside)for n = kingSq to theBoard.rookSq1 step -1holder(n) = theBoard.square[n]theBoard.square[n] = 1next ntheBoard.who2move = -theBoard.who2move// and see if any of the squares are attacked (including CHECK!!)for n = kingSq to theBoard.rookSq1 step -1if (fn isAttacked(n,theBoard)) then wQside = _false : exit nextnext n// if we made it up to here > only then can we castle. long if (wQside)// add wCastleQside to moveList (king takes Qside ROOK!)moveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = theBoard.rookSq1moves.capturePiece(moveIndex) = 0moves.moveScore(moveIndex) = 0pieceMoves++end if// restore order to the universefor n = kingSq to theBoard.rookSq1 step -1theBoard.square[n] = holder(n)next ntheBoard.who2move = -theBoard.who2moveend ifend ifend fn = pieceMoveslocal fn bKingMoves( theBoard as ^boardRecord, moves(_maxMoves) as moveRecord, numMoves as long, querySquare as long )dim as long moveIndex, pieceMovesdim as long testMask, newMask, testSquare, vectorCountdim as boolean sqAttacked1, sqAttacked2, sqAttacked3dim as long n, kingSq, holder(8)dim as boolean bKside, bQsidepieceMoves = 0for vectorCount = 0 to 7testMask = sq2Mask (querySquare)newMask = testMask + kingMask(vectorCount)testSquare = querySquare + kingVect(vectorCount)long if (maskBoard(newMask) = 1 )// the >-1 allows for both king capture and king spacelong if (theBoard.square[testSquare] > -1)moveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = testSquaremoves.capturePiece(moveIndex) = theBoard.square[testSquare]moves.moveScore(moveIndex) = 0pieceMoves++end ifend ifnext vectorCountlong if (theBoard.fischer == _false)// black king bCastleKside (classic)long if (querySquare = 60) and (theBoard.square[60]=-6) and (theBoard.square[61]=0) and (theBoard.square[62]=0) and (theBoard.square[63]=-4) and (theBoard.bCastleKside = _true)// setup dummy pieces for testSquares (and we could not get here if they were not empty!)theBoard.who2move = -theBoard.who2movetheBoard.square[61] = -1theBoard.square[62] = -1// cant castle through check!!sqAttacked1 = fn isAttacked( 61, theBoard )sqAttacked2 = fn isAttacked( 62, theBoard )sqAttacked3 = _falselong if ( (sqAttacked1 == _false) and (sqAttacked2 == _false) and (gInCheck = _false) )// add bCastleKside to moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = 62moves.capturePiece(moveIndex) = 0moves.moveScore(moveIndex) = 0pieceMoves++end iftheBoard.who2move = -theBoard.who2movetheBoard.square[61] = 0theBoard.square[62] = 0end if// black king bCastleQside (classic)long if (querySquare = 60) and (theBoard.square[60]=-6) and (theBoard.square[59]=0) and (theBoard.square[58]=0) and (theBoard.square[57]=0) and (theBoard.square[56]=-4) and (theBoard.bCastleQside = _true)// setup dummy pieces for testSquares (and we could not get here if they were not empty!)theBoard.who2move = -theBoard.who2movetheBoard.square[57] = -1theBoard.square[58] = -1theBoard.square[59] = -1// cant castle through check!!sqAttacked1 = fn isAttacked( 57, theBoard )sqAttacked2 = fn isAttacked( 58, theBoard )sqAttacked3 = fn isAttacked( 59, theBoard )long if ( (sqAttacked1 == _false) and (sqAttacked2 == _false) and (sqAttacked3 = _false) and (gInCheck = _false) )// add bCastleQside to moveListmoveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = 58moves.capturePiece(moveIndex) = 0moves.moveScore(moveIndex) = 0pieceMoves++end iftheBoard.who2move = -theBoard.who2movetheBoard.square[57] = 0theBoard.square[58] = 0theBoard.square[59] = 0end ifend if// FISCHER CASTLING// FEN1: 2rk1r2/pppppppp/8/8/8/8/PPPPPPPP/2RK1R2 b CFcf -// FEN2: bbqrkrnn/pppppppp/8/8/8/8/PPPPPPPP/BBQRKRNN b DFdf - // determine kingSqkingSq = _noSuchSquarelong if (theBoard.fischer == _true) and (querySquare>56) and (querySquare<63) and (theBoard.square[querySquare]=-6)kingSq = querySquareend if// fischer bCastleKsidelong if (theBoard.fischer == _true) and (kingSq <> _noSuchSquare) and (gInCheck = _false) and (theBoard.bCastleKside = _true)bKside = _true// determine if castle squares are emptyif (theBoard.square[61]<>-6) and (theBoard.square[61]<>-4) and (theBoard.square[61]<>0) then bKside = _falseif (theBoard.square[62]<>-6) and (theBoard.square[62]<>-4) and (theBoard.square[62]<>0) then bKside = _false// determine if squares between kingSq and rookSq2 are empty??for n = kingSq to theBoard.rookSq2+56if (theBoard.square[n]<>-6) and (theBoard.square[n]<>-4) and (theBoard.square[n]<>0) then bKside = _false : exit nextnext n// if we made it, HOLD the squares & SWAP who2movelong if (bKside)for n = kingSq to theBoard.rookSq2+56holder(n-56) = theBoard.square[n]theBoard.square[n] = 1next ntheBoard.who2move = -theBoard.who2move// and see if any of the squares are attacked (including CHECK!!)for n = kingSq to theBoard.rookSq2+56if (fn isAttacked(n,theBoard)) then bKside = _false : exit nextnext n// if we made it up to here > only then can we castle. long if (bKside)// add bCastleKside to moveList (king takes Kside ROOK!)moveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = theBoard.rookSq2+56moves.capturePiece(moveIndex) = 0moves.moveScore(moveIndex) = 0pieceMoves++end if// restore order to the universefor n = kingSq to theBoard.rookSq2+56theBoard.square[n] = holder(n-56)next ntheBoard.who2move = -theBoard.who2moveend ifend if// fischer  bCastleQsidelong if (theBoard.fischer == _true) and (kingSq <> _noSuchSquare) and (gInCheck = _false) and (theBoard.bCastleQside = _true)bQside = _true// determine if castle squares are emptyif (theBoard.square[58]<>-6) and (theBoard.square[58]<>-4) and (theBoard.square[58]<>0) then bQside = _falseif (theBoard.square[59]<>-6) and (theBoard.square[59]<>-4) and (theBoard.square[59]<>0) then bQside = _false// determine if squares between kingSq and rookSq2 are empty??for n = kingSq to theBoard.rookSq1+56 step -1if (theBoard.square[n]<>-6) and (theBoard.square[n]<>-4) and (theBoard.square[n]<>0) then bQside = _false : exit nextnext n// if we made it, HOLD the squares & SWAP who2movelong if (bQside)for n = kingSq to theBoard.rookSq1+56 step -1holder(n-56) = theBoard.square[n]theBoard.square[n] = 1next ntheBoard.who2move = -theBoard.who2move// and see if any of the squares are attacked (including CHECK!!)for n = kingSq to theBoard.rookSq1+56 step -1if (fn isAttacked(n,theBoard)) then bQside = _false : exit nextnext n// if we made it up to here > only then can we castle. long if (bQside)// add bCastleQside to moveList (king takes Qside ROOK!)moveIndex = numMoves + pieceMovesmoves.fromSquare(moveIndex) = querySquaremoves.toSquare(moveIndex) = theBoard.rookSq1+56moves.capturePiece(moveIndex) = 0moves.moveScore(moveIndex) = 0pieceMoves++end if// restore order to the universefor n = kingSq to theBoard.rookSq1+56 step -1theBoard.square[n] = holder(n-56)next ntheBoard.who2move = -theBoard.who2moveend ifend ifend fn = pieceMoveslocal FN pieceTree(theBoard as ^boardRecord, moves(_maxMoves) as moveRecord, numMoves as long, querySquare as long)dim as long pieceMoves, pieceType, pieceColourpieceMoves = 0pieceType = theBoard.square[querySquare]// multiply by -1 to be passed to the move generatorsif pieceType > 0 then pieceColour = 1 else pieceColour = -1SELECT CASE CASE pieceType = 1     // White PAWN TESTSpieceMoves = fn wPawnMoves( theBoard, moves(0), numMoves, querySquare )exit fnCASE pieceType = -1     // Black PAWN TESTSpieceMoves = fn bPawnMoves( theBoard, moves(0), numMoves, querySquare )exit fnCASE abs(pieceType) = 2 // BISHOP TESTSpieceMoves = fn bishopMoves( theBoard, moves(0), numMoves, querySquare, pieceColour )exit fnCASE abs(pieceType) = 3     // KNIGHT TESTSpieceMoves = fn knightMoves( theBoard, moves(0), numMoves, querySquare, pieceColour )exit fnCASE abs(pieceType) = 4 // ROOK TESTSpieceMoves = fn rookMoves( theBoard, moves(0), numMoves, querySquare, pieceColour )exit fnCASE abs(pieceType) = 5 // QUEEN TESTSpieceMoves = fn bishopMoves( theBoard, moves(0), numMoves, querySquare, pieceColour )pieceMoves += fn rookMoves( theBoard, moves(pieceMoves), numMoves, querySquare, pieceColour )exit fnCASE pieceType = 6     // White KING TESTSpieceMoves = fn wKingMoves( theBoard, moves(0), numMoves, querySquare )exit fnCASE pieceType = -6     // Black KING TESTSpieceMoves = fn bKingMoves( theBoard, moves(0), numMoves, querySquare )exit fnend selectend FN = pieceMoveslocal fn isTarget( querySquare as long, inBoard as ^boardRecord, targetMoves(_maxMoves) as moveRecord, pieceType as str255 )dim as long n, sq, pieceColourdim as long numMoves, numTargetMovesdim as moveRecord moves(_maxMoves)dim as boardRecord theBoardpieceColour = inBoard.who2movenumMoves = 0 : numTargetMoves = 0fn copyBoard( inBoard, theBoard )// generate all the moves (or just for a specific pieceType)for sq = 0 to 63//white pawn targetslong if (theBoard.square[sq] = 1) and (pieceColour = 1) and (pieceType="" or pieceType="P")numMoves += fn wPawnMoves( theBoard, moves(0), numMoves, sq )end if//black pawn targetslong if (theBoard.square[sq] = -1) and (pieceColour = -1) and (pieceType="" or pieceType="P")numMoves += fn bPawnMoves( theBoard, moves(0), numMoves, sq )end if//bishop targetslong if (pieceType="" or pieceType="B")long if (theBoard.square[sq] * theBoard.who2move = 2)numMoves += fn bishopMoves( theBoard, moves(0), numMoves, sq, pieceColour )end ifend if//rook targetslong if (pieceType="" or pieceType="R")long if (theBoard.square[sq] * theBoard.who2move = 4)numMoves += fn rookMoves( theBoard, moves(0), numMoves, sq, pieceColour )end ifend if//queen diagonal and perpendicular targetslong if (pieceType="" or pieceType="Q")long if (theBoard.square[sq] * theBoard.who2move = 5)numMoves += fn bishopMoves( theBoard, moves(0), numMoves, sq, pieceColour )numMoves += fn rookMoves( theBoard, moves(0), numMoves, sq, pieceColour )end ifend if//knight targetslong if (theBoard.square[sq] * theBoard.who2move = 3) and (pieceType="" or pieceType="N")numMoves += fn knightMoves( theBoard, moves(0), numMoves, sq, pieceColour )end if//white king targetslong if (theBoard.square[sq] = 6) and (pieceColour = 1) and (pieceType="" or pieceType="K")numMoves += fn wKingMoves( theBoard, moves(0), numMoves, sq )end if//black king targetslong if (theBoard.square[sq] = -6) and (pieceColour = -1) and (pieceType="" or pieceType="K")numMoves += fn bKingMoves( theBoard, moves(0), numMoves, sq )end ifnext sq// once we've made all the moves, see if any of them hit the target! for n = 0 to numMoves-1long if moves.toSquare(n) = querySquaretargetMoves.fromSquare(numTargetMoves) = moves.fromSquare(n)targetMoves.toSquare(numTargetMoves) = moves.toSquare(n)targetMoves.capturePiece(numTargetMoves) = theBoard.square[moves.toSquare(n)]targetMoves.moveScore(numTargetMoves) = 0numTargetMoves++end ifnext n end fn = numTargetMoves