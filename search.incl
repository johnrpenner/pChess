// pChess 1.9.4// Search Module v2.1 (supports fischer castling)// John Roland Penner <johnrolandpenner-at-gmail-dot-com>// This file is released under the GNU public license, 2011. // Updated as of: February 19, 2012local FN makeMove(board as ^boardRecord, theMove as ^moveRecord)dim as long y1, y2dim as long pieceTypey1 = fn sq2Y(theMove.fromSquare) + 1y2 = fn sq2Y(theMove.toSquare) + 1pieceType = board.square[ theMove.fromSquare ]select case abs(pieceType)// KING CASTLINGcase 6long if (board.fischer == _false)// castling - white-kingSidelong if (theMove.fromSquare = 4) and (theMove.toSquare = 6) and (board.square[4]=6) and (board.square[7]=4) board.square[theMove.toSquare] = board.square[theMove.fromSquare] board.square[theMove.fromSquare] = 0 board.square[5] = 4     'a rook board.square[7] = 0     'blank it out board.wCastleKside = _false     'can no longer castle board.wCastleQside = _false     'can no longer castle board.wHasCastled = _true board.who2move = -board.who2move board.halfMoves++ exit fnend if// castling - white-queenSidelong if (theMove.fromSquare = 4) and (theMove.toSquare = 2) and (board.square[4]=6) and (board.square[0]=4) board.square[theMove.toSquare] = board.square[theMove.fromSquare] board.square[theMove.fromSquare] = 0 board.square[3] = 4     'a rook board.square[0] = 0     'blank it out board.wCastleKside = _false     'can no longer castle board.wCastleQside = _false     'can no longer castle board.wHasCastled = _true board.who2move = -board.who2move board.halfMoves++ exit fnend if// castling - black-kingSidelong if (theMove.fromSquare = 60) and (theMove.toSquare = 62) and (board.square[60]=-6) and (board.square[63]=-4) board.square[theMove.toSquare] = board.square[theMove.fromSquare] board.square[theMove.fromSquare] = 0 board.square[61] = -4     'a rook board.square[63] = 0     'blank it out board.bCastleKside = _false     'can no longer castle board.bCastleQside = _false     'can no longer castle board.bHasCastled = _true board.who2move = -board.who2move board.halfMoves++ exit fnend if// castling - black-queenSidelong if (theMove.fromSquare = 60) and (theMove.toSquare = 58) and (board.square[60]=-6) and (board.square[56]=-4) board.square[theMove.toSquare] = board.square[theMove.fromSquare] board.square[theMove.fromSquare] = 0 board.square[59] = -4     'a rook board.square[56] = 0     'blank it out board.bCastleKside = _false     'can no longer castle board.bCastleQside = _false     'can no longer castle board.bHasCastled = _true board.who2move = -board.who2move board.halfMoves++ exit fnend ifxelse//FIND: CASTLE FISCHER// fischer castling - white-kingSidelong if (board.square[theMove.fromSquare]=6) and (board.square[theMove.toSquare]=4) and (theMove.toSquare = board.rookSq2) board.square[theMove.fromSquare] = 0 board.square[board.rookSq2] = 0 board.square[6] = 6 board.square[5] = 4 board.wCastleKside = _false     'can no longer castle board.wCastleQside = _false     'can no longer castle board.wHasCastled = _true board.who2move = -board.who2move board.halfMoves++ exit fnend if// fischer castling - white-queenSidelong if (board.square[theMove.fromSquare]=6) and (board.square[theMove.toSquare]=4) and (theMove.toSquare = board.rookSq1) board.square[theMove.fromSquare] = 0 board.square[board.rookSq1] = 0 board.square[2] = 6 board.square[3] = 4 board.wCastleKside = _false     'can no longer castle board.wCastleQside = _false     'can no longer castle board.wHasCastled = _true board.who2move = -board.who2move board.halfMoves++ exit fnend if// fischer castling - black-kingSidelong if (board.square[theMove.fromSquare]=-6) and (board.square[theMove.toSquare]=-4) and (theMove.toSquare = board.rookSq2+56) board.square[theMove.fromSquare] = 0 board.square[board.rookSq2+56] = 0 board.square[62] = -6 board.square[61] = -4 board.bCastleKside = _false     'can no longer castle board.bCastleQside = _false     'can no longer castle board.bHasCastled = _true board.who2move = -board.who2move board.halfMoves++ exit fnend if// fischer castling - black-queenSide//long if (theMove.fromSquare = 60) and (theMove.toSquare = 58) and (board.square[60]=-6) and (board.square[56]=-4)long if (board.square[theMove.fromSquare]=-6) and (board.square[theMove.toSquare]=-4) and (theMove.toSquare = board.rookSq1+56) board.square[theMove.fromSquare] = 0 board.square[board.rookSq1+56] = 0 board.square[58] = -6 board.square[59] = -4 board.bCastleKside = _false     'can no longer castle board.bCastleQside = _false     'can no longer castle board.bHasCastled = _true board.who2move = -board.who2move board.halfMoves++ exit fnend ifend if// PAWNScase 1//test and take White enPassant Westlong if (theMove.fromSquare > 32) and (theMove.fromSquare < 40)long if (board.square[theMove.fromSquare] = 1) and board.square[theMove.fromSquare-1] = -1 and (theMove.toSquare - theMove.fromSquare = 7) and (theMove.fromSquare - 1 = board.enPassantSq)board.square[theMove.fromSquare - 1] = 0board.square[theMove.toSquare] = board.square[theMove.fromSquare]board.square[theMove.fromSquare] = 0board.halfMoves = board.halfMoves + 1board.who2move = -board.who2moveboard.enPassantSq = _noSuchSquareexit fnend ifend if//test and take White enPassant Eastlong if (theMove.fromSquare > 31) and (theMove.fromSquare < 39)long if (board.square[theMove.fromSquare] = 1) and board.square[theMove.fromSquare+1] = -1 and (theMove.toSquare - theMove.fromSquare = 9) and (theMove.fromSquare + 1 = board.enPassantSq)board.square[theMove.fromSquare + 1] = 0board.square[theMove.toSquare] = board.square[theMove.fromSquare]board.square[theMove.fromSquare] = 0board.halfMoves = board.halfMoves + 1board.who2move = -board.who2moveboard.enPassantSq = _noSuchSquareexit fnend ifend if//test and take Black enPassant Westlong if (theMove.fromSquare > 23) and (theMove.fromSquare < 31)long if (board.square[theMove.fromSquare] = -1) and board.square[theMove.fromSquare+1] = 1 and (theMove.fromSquare - theMove.toSquare = 7) and (theMove.fromSquare + 1 = board.enPassantSq)board.square[theMove.fromSquare +1] = 0board.square[theMove.toSquare] = board.square[theMove.fromSquare]board.square[theMove.fromSquare] = 0board.halfMoves = board.halfMoves + 1board.who2move = -board.who2moveboard.enPassantSq = _noSuchSquareexit fnend ifend if//test and take Black enPassant Eastlong if (theMove.fromSquare > 24) and (theMove.fromSquare < 32)long if (board.square[theMove.fromSquare] = -1) and board.square[theMove.fromSquare-1] = 1 and (theMove.fromSquare - theMove.toSquare = 9) and (theMove.fromSquare - 1 = board.enPassantSq)board.square[theMove.fromSquare -1] = 0board.square[theMove.toSquare] = board.square[theMove.fromSquare]board.square[theMove.fromSquare] = 0board.halfMoves = board.halfMoves + 1board.who2move = -board.who2moveboard.enPassantSq = _noSuchSquareexit fnend ifend ifend select//==| MAKE MOVE |========================================// if !funkyMove >> then make Regular Move and bump the moveRecord// HASH1: hash out the fromPiece by XORing the existing Hash Code//theBoard.hashCode = theBoard.hashCode xor gPieceHashCode(fromSquare, movingPiece, 1 - theBoard.my.side ) // hash removal of moving pieceboard.hashCode = board.hashCode xor gPieceHashCode(theMove.fromSquare, abs(board.square[theMove.fromSquare]), 1-board.who2move ) // hash 'removal' of moving piece// HASH2: hash out the capturelong if board.square[theMove.toSquare] <> 0//theBoard.hashCode = theBoard.hashCode xor gPieceHashCode(captSquare, capturedPiece, 1 - theBoard.opp.side ) // hash removal of captured pieceboard.hashCode = board.hashCode xor gPieceHashCode(theMove.toSquare, abs(board.square[theMove.toSquare]), 1-(-board.who2move) ) // hash removal of captured pieceend if// make the actual move board.square[theMove.toSquare] = board.square[theMove.fromSquare] board.square[theMove.fromSquare] = 0 board.who2move = -board.who2move board.hashCode = not( board.hashCode ) board.halfMoves++// Pawn to Queen Promotion (queen always assumed)if (pieceType = 1) and (y1=7) and (y2=8) then board.square[theMove.toSquare] = 5 : gPromotion = _true : theMove.promoPiece = 5if (pieceType = -1) and (y1=2) and (y2=1) then board.square[theMove.toSquare] = -5 : gPromotion = _true : theMove.promoPiece = -5// HASH3: hash in the new piece (must be after pawn promotion to ensure inclusion)//theBoard.hashCode = theBoard.hashCode xor gPieceHashCode(toSquare, movingPiece, 1 - theBoard.my.side ) // hash arrival of moving pieceboard.hashCode = board.hashCode xor gPieceHashCode(theMove.toSquare, abs(board.square[theMove.toSquare]), 1-board.who2move ) // hash arrival of moving piece//==========================================//if the King or either Rook has moved, we can no longer castleif (pieceType = 6) then board.wCastleKside = _false : board.wCastleQside = _falseif (pieceType = -6) then board.bCastleKside = _false : board.bCastleQside = _falselong if (board.fischer==_false)if (pieceType = 4) and (theMove.fromSquare=0) then board.wCastleQside = _falseif (pieceType = 4) and (theMove.fromSquare=7) then board.wCastleKside = _falseif (pieceType = -4) and (theMove.fromSquare=56) then board.bCastleQside = _falseif (pieceType = -4) and (theMove.fromSquare=63) then board.bCastleKside = _falseend iflong if (board.fischer==_true)if (pieceType = 4) and (theMove.fromSquare = board.rookSq1) then board.wCastleQside = _falseif (pieceType = 4) and (theMove.fromSquare = board.rookSq2) then board.wCastleKside = _falseif (pieceType = -4) and (theMove.fromSquare = board.rookSq1+56) then board.bCastleQside = _falseif (pieceType = -4) and (theMove.fromSquare = board.rookSq2+56) then board.bCastleKside = _falseend if//handle SETTING enPassant (into the new board)board.enPassantSq = _noSuchSquareif (pieceType =  1) and (y1=2) and (y2=4) then board.enPassantSq = theMove.toSquareif (pieceType = -1) and (y1=7) and (y2=5) then board.enPassantSq = theMove.toSquaregMovesMade++end FN//==| SORT MOVES |==================================================//    by insertion method (by robert purves)local fn sortMoves(moves(_maxMoves) as moveRecord, numMoves as long)dim as long i, jdim as moveRecord tempMovelong if gUseMoveSort=_truefor j = 1 to numMoves-1tempMove = moves(j)for i = j-1 to 0 step -1//need to compare abs() values, or else black & white get sorted differentlyif ( abs(moves.capturePiece(i)) => abs(tempMove.capturePiece) ) then exit nextmoves(i+1) = moves(i)next imoves(i+1) = tempMovenext jend ifend FNlocal fn putIndexMoveFirst( moves(_maxMoves) as moveRecord, bestIndex as long )dim as moveRecord tempMovetempMove = moves(bestIndex)BlockMoveData( @moves(0), @moves(1), bestIndex*sizeof( moveRecord ) )moves(0) = tempMoveend fnlocal fn putSuppliedMoveFirst( theMove as ^moveRecord, moves(_maxMoves) as moveRecord, numMoves as long ) as Booleandim as long jdim as Boolean found : found = _falsefor j = 0 to numMoves - 1long if ( moves.fromSquare(j) == theMove.fromSquare )found = ( moves.toSquare(j) == theMove.toSquare )long if ( found )BlockMoveData( @moves(0), @moves(1), j*sizeof( moveRecord ) )moves(0) = theMovegNumHashTableMovesUsed++exit fnend ifend ifnext jend fn = foundlocal fn isSideToMoveInCheck( board as ^boardRecord )dim as long     myKingSquaredim as Boolean  inCheckfor myKingSquare = 0 to 63long if ( board.square[myKingSquare] * board.who2move == 6 ) board.who2move = -board.who2moveinCheck = fn isAttacked( myKingSquare, board )board.who2move = -board.who2moveexit fnend ifnext//if no king, we cant be in check (allows debugging minus king values)inCheck = _falseend fn = inChecklocal fn isLegalPosition( board as ^boardRecord )dim as long     oppKingSquaredim as Boolean  legal// _false means that the last move was illegal. // i.e. the side to move can capture opposing Kfor oppKingSquare = 0 to 63long if ( board.square[oppKingSquare] * board.who2move == -6 ) legal = ( fn isAttacked( oppKingSquare, board ) == _false )exit fnend ifnext// if there is no king, the side to move cant capture itlegal = _trueend fn = legallocal fn attacks2moves( sq as long, theBoard as ^boardRecord, numCaptureMoves as long, attackedSquares(_maxMoves) as long, numMoves as long, moves(_maxMoves) as moveRecord )// adjunct to FN generateCaptureMoves()dim as long jfor j = 0 to numMoves -1Êmoves.fromSquare(numCaptureMoves) ÊÊ= sqÊmoves.toSquare(numCaptureMoves) ÊÊÊÊ= attackedSquares(j)Êmoves.capturePiece(numCaptureMoves) = theBoard.square[attackedSquares(j)]Êmoves.moveScore(numCaptureMoves) ÊÊÊ= 0 numCaptureMoves++next jend fn = numCaptureMoveslocal FN generateRawMoves(board as ^boardRecord, moves(_maxMoves) as moveRecord, numMoves as long)dim as long querySquaredim as long pieceMovesfor querySquare = 0 to 63pieceMoves = 0// generate white moveslong if (board.who2move = 1) and (board.square[querySquare] > 0)pieceMoves = FN pieceTree(board, moves(0), numMoves, querySquare )numMoves = numMoves + pieceMovesend if// generate black moveslong if (board.who2move = -1) and (board.square[querySquare] < 0)pieceMoves = FN pieceTree(board, moves(0), numMoves, querySquare )numMoves = numMoves + pieceMovesend ifnext querySquareend FN = numMoveslocal FN generateLegalMoves(board as ^boardRecord, moves(_maxMoves) as moveRecord )dim as long numRawMoves, n, numLegalMoves : numLegalMoves = 0dim as boardRecord testBoarddim as moveRecord theMovedim as moveRecord rawMoves(_maxMoves)numRawMoves = FN generateRawMoves( board, rawMoves(0), 0 )   //loop here to test legality..for n = 0 to numRawMoves-1fn copyBoard (board, testBoard)theMove = rawMoves(n)fn makeMove(testBoard, theMove)long if ( fn IsLegalPosition( testBoard ) )moves(numLegalMoves) = theMove : numLegalMoves++end ifnext nend FN = numLegalMoveslocal FN generateCaptureMoves(theBoard as ^boardRecord, moves(_maxMoves) as moveRecord )dim as long attackedSquares(_maxMoves)dim as long numMoves, numCaptureMovesdim as long sq, pieceType, pieceColournumMoves = 0 : numCaptureMoves = 0for sq = 0 to 63pieceColour = theBoard.who2movepieceType = theBoard.square[sq]//white pawn attackslong if (theBoard.square[sq] = 1) and (pieceColour = 1)numMoves = fn wPawnAttacks( sq, theBoard, attackedSquares(0), numMoves, pieceColour )numCaptureMoves = fn attacks2moves( sq, theBoard, numCaptureMoves, attackedSquares(0), numMoves, moves(0) )end if//black pawn attackslong if (theBoard.square[sq] = -1) and (pieceColour = -1)numMoves = fn bPawnAttacks( sq, theBoard, attackedSquares(0), numMoves, pieceColour )numCaptureMoves = fn attacks2moves( sq, theBoard, numCaptureMoves, attackedSquares(0), numMoves, moves(0) )end if//bishop (and diagonal queen) attackslong if (theBoard.square[sq] * pieceColour = 2)numMoves = fn bishopAttacks( sq, theBoard, attackedSquares(0), numMoves, pieceColour )numCaptureMoves = fn attacks2moves( sq, theBoard, numCaptureMoves, attackedSquares(0), numMoves, moves(0) )end if//knight attackslong if (theBoard.square[sq] * pieceColour = 3)numMoves = fn knightAttacks( sq, theBoard, attackedSquares(0), numMoves, pieceColour )numCaptureMoves = fn attacks2moves( sq, theBoard, numCaptureMoves, attackedSquares(0), numMoves, moves(0) )end if//rook (and perpendicular queen) attackslong if (theBoard.square[sq] * pieceColour = 4)numMoves = fn rookAttacks( sq, theBoard, attackedSquares(0), numMoves, pieceColour )numCaptureMoves = fn attacks2moves( sq, theBoard, numCaptureMoves, attackedSquares(0), numMoves, moves(0) )end if//queen attackslong if (theBoard.square[sq] * pieceColour = 5)numMoves = fn bishopAttacks( sq, theBoard, attackedSquares(0), numMoves, pieceColour )numMoves += fn rookAttacks( sq, theBoard, attackedSquares(0), numMoves, pieceColour )numCaptureMoves = fn attacks2moves( sq, theBoard, numCaptureMoves, attackedSquares(0), numMoves, moves(0) )end if//king attackslong if (theBoard.square[sq] * pieceColour = 6)numMoves = fn kingAttacks( sq, theBoard, attackedSquares(0), numMoves, pieceColour )numCaptureMoves = fn attacks2moves( sq, theBoard, numCaptureMoves, attackedSquares(0), numMoves, moves(0) )end ifnext sqend FN = numCaptureMoveslocal fn checkTest(theBoard as ^boardRecord)// this way of checkTesting is only for slow UI reportingdim as long numMovesdim as long checkFlag, checkReturndim as moveRecord moves(_maxMoves)// default 0 = NOT IN CHECKcheckFlag = 0 : checkReturn = 0// first Question: are there any legal moves available? numMoves = 0 : blockZero( moves(0), sizeof( moveRecord ) )numMoves = fn generateLegalMoves( theBoard, moves(0) )// second Question: are we in CHECK!?if (fn isSideToMoveInCheck( theBoard ) == _true) then checkFlag = 1// now that we know: i) numMoves, and ii) inCheck? -- we can return the status: if (checkFlag = 1) and (numMoves > 0) then checkReturn = 1 : exit fn  //checkif (checkFlag = 1) and (numMoves = 0) then checkReturn = 2 : exit fn  //mateif (checkFlag = 0) and (numMoves = 0) then checkReturn = 3 : exit fn  //staleend FN = checkReturn//---=< QUIESCENCE >=---// local fn quiescenceSearch( board as ^BoardRecord, alphaScore as long, betaScore as long, depth as long )dim as boardRecord testBoarddim as moveRecord theMovedim as moveRecord moves(_maxMoves)dim as long numMoves, moveIndex, moveScore, patScorepatScore = fn staticEval( board )long if ( depth < _minQSearchDepth ) // terminal node (depth limit exceeded) alphaScore = patScore exit fnend iflong if ( patScore > alphaScore ) alphaScore = patScore if ( alphaScore >= betaScore ) then exit fn // beta cutoffend ifnumMoves = fn generateCaptureMoves( board, moves(0) )long if ( numMoves == 0 ) // terminal node (no capture moves)alphaScore = patScoreexit fnend if//sort the moves (so highest value captures come first)fn sortMoves(moves(0), numMoves)for moveIndex = 0 to numMoves-1fn copyBoard (board, testBoard)theMove = moves(moveIndex)fn makeMove( testBoard, theMove )long if ( fn IsLegalPosition( testBoard ) )// count number of nodesgqNodes++moveScore = -fn quiescenceSearch( testBoard, -betaScore, -alphaScore, depth - 1 )long if ( moveScore > alphaScore )alphaScore = moveScoreif ( alphaScore >= betaScore ) then exit fn  // beta cutoffend ifend ifnext moveIndexend fn = alphaScore//---=< NEGAMAX >=---//local FN negaSearch(board as ^boardRecord, alphaScore as long, betaScore as long, depth as long, ply as long)dim as long  numRawMoves, moveIndex, moveScore, numLegal : numLegal = 0dim as moveRecord moves(_maxMoves)dim as moveRecord theMovedim as boardRecord testBoarddim as long hashScore, origAlphadim as moveRecord moveFromHashTable, moveForHashTabledim as str255 dispMove : dispMove = ""// if draw by 50; insufficient strength; or repetition > return 0 here. // check for abort without slowing searchif (fn PollTime) and (depth > 2) then fn CheckForAbortSignal // ESC Key Pressed? if (fn PollTime2) then fn SetAbortSearch // Timer Ran Out// quiescence Searchlong if (depth <= 0) or ( fn IsSearchAborted and gMaxEvalTime<>0 )alphaScore = fn quiescenceSearch( board, alphaScore, betaScore, depth - 1 )exit fnend if// HASH LookuphashScore = fn findHash( board.hashCode, @moveFromHashTable, alphaScore, betaScore, depth )long if ( hashScore != _positionNotFound and hashScore != _positionFoundButNotUseable )alphaScore = hashScore // A Useable Hash Hit!! :-Dexit fnend if// generate the moves we are going to evaluatenumRawMoves = FN generateRawMoves( board, moves(0), 0 )//sort the moves (so captures top the list, and speed the search)fn sortMoves( moves(0), numRawMoves )// HASH > move from hashtable should be first in list//if ( thisScore == _positionFoundButNotUseable ) then fn putSuppliedMoveFirst( @moveFromHashTable, moves(0), nRawMoves, inBoard )if ( hashScore == _positionFoundButNotUseable ) then fn putSuppliedMoveFirst( @moveFromHashTable, moves(0), numRawMoves )// HASH (save original alpha going in)origAlpha = alphaScorenumLegal = 0moveForHashTable.fromSquare = _noSuchSquarefor moveIndex = 0 to numRawMoves-1fn copyBoard(board, testBoard)theMove = moves(moveIndex)FN makeMove( testBoard, theMove )long if ( fn isLegalPosition( testBoard ) )numLegal++ : gNodes++moveScore = -FN negaSearch( testBoard, -betaScore, -alphaScore, depth - 1, ply + 1 )long if ( moveScore > alphaScore )alphaScore = moveScoretheMove.moveScore = moveScoremoveForHashTable = theMove#if _buildAsUCIEngine == _false// extraneous but cool schtuff if (visualBrain) then fn visualBrainz(theMove) if (audioBrain) and (depth > 3) then fn audioBrainz(theMove, moveScore) if (hyperView) and (depth > 3) then fn displayBoard(testBoard)#endifend ifif ( alphaScore => betaScore ) then exit next  // beta cutoffend ifnext moveIndexlong if (numLegal == 0) long if ( fn IsSideToMoveInCheck( board ) )alphaScore = _iAmMateScore + plyxelsealphaScore = _stalemateScoreend ifend if// HASH > save in hash table//fn saveHash( inBoard.hashCode, @moveForHashTable, alpha, origAlpha, beta, depth )fn saveHash( board.hashCode, @moveForHashTable, alphaScore, origAlpha, betaScore, depth )end FN = alphaScore//-----< end of negaSearch >-----//#if _iDeeplocal fn computerSearch( board as ^boardRecord, maxDepth as long ) as moveRecorddim as boardRecord testBoarddim as moveRecord Êmoves(_maxMoves), theMovedim as long ÊÊÊÊÊÊÊalphaScore, depth, numMoves, moveIndex, moveScoredim as Str255 ÊÊÊÊÊdispMove// first see if we are in check (used for kingMove generation ONLY)gInCheck = fn isSideToMoveInCheck( board )// and only then can we GENERATE ROOT MOVESnumMoves = fn generateLegalMoves( board, moves(0) )// default move which can be interpreted as mate or drawlong if ( numMoves == 0 )moves.fromSquare(0) = _noSuchSquaremoves.toSquare(0) ÊÊ= _noSuchSquarelong if ( gInCheck )moves.moveScore(0) = _iAmMateScorexelsemoves.moveScore(0) = _stalemateScoreend ifexit fnend ifif ( numMoves == 1 ) then maxDepth = 1 ÊÊÊÊ// dont go deep if only one move// put captures firstfn sortMoves(moves(0), numMoves)fn initHashTablefor depth = 1 to maxDepth ÊÊÊÊÊÊÊÊÊÊÊÊÊÊ//---| DEPTHS |---//if (_devLog) then print : print "-----| DEPTH" depth " |-----"alphaScore = -_infinity#if _buildAsUCIEngine == _falseedit$(8) = "IDEEP" + str$(depth) + " |"#endiffor moveIndex = 0 to numMoves-1 ÊÊÊÊÊÊÊÊÊ//---| MOVES |---//#if _buildAsUCIEngine == _falseedit$(8) = edit$(8) + str$(moveIndex+1) + ".. "#endiffn copyBoard(board, testBoard)theMove = moves(moveIndex)fn makeMove( testBoard, theMove )// search with beta fixed at -_infinitymoveScore = -fn negaSearch( testBoard, -_infinity, -alphaScore, depth, 1 )#if _buildASUCIEngine == _true dispMove = fn move2Algebraic( moves(moveIndex) ) fn infoToGUI( moveIndex, dispMove, depth, moveScore, gNodes )#endifif ( fn IsSearchAborted ) then exit nextmoves.moveScore(moveIndex) = moveScoreif (_devLog) then print moveIndex ". " fn move2Algebraic( moves(moveIndex) ) " " moveScorelong if ( moveScore > alphaScore )alphaScore = moveScorefn putIndexMoveFirst( moves(0), moveIndex ) if (_devLog) then print "  ---> " fn move2Algebraic( moves(0) ) "  " moveScore " <-----| best so far |----- "#if _buildAsUCIEngine == _false  dispMove = fn move2Algebraic( moves(0) )  edit$(8) = "IDEEP" + str$(depth) + " |" + str$(numMoves) + " Moves | Eval" + str$(moveIndex+1) + ": " + dispMove + " (score:" + str$(moveScore) + ")" + chr$(13)  if ( visualBrain ) then fn displayBoard(testBoard)#endifend ifnext moveIndex#if _buildASUCIEngine == _true dispMove = fn move2Algebraic( moves(0) ) fn infoToGUI( moveIndex, dispMove, depth, moveScore, gNodes )#endifif ( fn IsSearchAborted ) then exit nextnext depthif (_devLog) then print "RESULT: " fn move2Algebraic( moves(0) ) "  " moves.moveScore(0) " <----------| FINAL |----" : printend fn = moves(0)#endif//---| ORIGINAL (WORKING!!) COMPUTER SEARCH |---//#if _iDeep == _falselocal FN computerSearch(board as ^boardRecord, depth as long) as moveRecorddim as boardRecord testBoarddim as moveRecord moves(_maxMoves), theMovedim as long alphaScore, betaScoredim as long numMoves, moveIndex, moveScore, highMovedim as str255 dispMove// GENERATE A MOVE WITH NEGAMAXfn initHashTable//initialize the negaSearchhighMove = 0 : alphaScore = -_infinity : betaScore = _infinity// first see if we are in check (used for kingMove generation ONLY)gInCheck = _false : gInCheck = fn isSideToMoveInCheck( board )// and only then can we GENERATE ROOT MOVESnumMoves = 0 : blockZero( moves(0), sizeof( moveRecord ) )numMoves = fn generateLegalMoves(board, moves(0) )if ( numMoves == 0 ) then exit fnfn sortMoves(moves(0), numMoves)for moveIndex = 0 to numMoves-1#if _buildAsUCIEngine == _false edit$(8) = edit$(8) + str$(moveIndex+1) + ".. "#endif fn copyBoard(board, testBoard) theMove = moves(moveIndex) FN makeMove( testBoard, theMove )//call negaMax!! :-D moveScore = -FN negaSearch( testBoard, -betaScore, -alphaScore, depth, 1 ) long if ( moveScore > alphaScore ) alphaScore = moveScore highMove = moveIndex moves.moveScore(moveIndex) = moveScore     //needed to return the true moveScore. #if _buildAsUCIEngine == _false dispMove = fn move2Algebraic( moves(highMove) ) edit$(8) = str$(numMoves) + " Moves | Evaluating " + str$(moveIndex+1) + ": " + dispMove + " (score:" + str$(moveScore) + ")" + chr$(13) if (visualBrain = 1) then fn displayBoard(testBoard)#endif#if _buildASUCIEngine == _true// info currmovenumber 1 currmove e2e4 depth 2 score cp 214 nodes 2124  dispMove = fn move2Algebraic( moves(0) )  fn infoToGUI( moveIndex, dispMove, depth, moveScore, gNodes )#endifend ifif ( alphaScore => betaScore ) then exit next  // beta cutoff next moveIndex// CREATE THE MOVE ENTRYtheMove.fromSquare = moves.fromSquare(highMove) theMove.toSquare = moves.toSquare(highMove)theMove.capturePiece = moves.capturePiece(highMove)theMove.moveScore = moves.moveScore(highMove)end FN = theMove#endif